// Code generated from GroovyParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // GroovyParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type GroovyParser struct {
	MyGroovyParser
}

var GroovyParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func groovyparserParserInit() {
	staticData := &GroovyParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "'as'", "'def'", "'in'", "'trait'", "'threadsafe'",
		"'var'", "", "'abstract'", "'assert'", "'break'", "'yield'", "'case'",
		"'catch'", "'class'", "'const'", "'continue'", "'default'", "'do'",
		"'else'", "'enum'", "'extends'", "'final'", "'finally'", "'for'", "'if'",
		"'goto'", "'implements'", "'import'", "'instanceof'", "'interface'",
		"'native'", "'new'", "'non-sealed'", "'package'", "'permits'", "'private'",
		"'protected'", "'public'", "'record'", "'return'", "'sealed'", "'static'",
		"'strictfp'", "'super'", "'switch'", "'synchronized'", "'this'", "'throw'",
		"'throws'", "'transient'", "'try'", "'void'", "'volatile'", "'while'",
		"", "", "", "'null'", "'..'", "'<..'", "'..<'", "'<..<'", "'*.'", "'?.'",
		"", "'??.'", "'?:'", "'.&'", "'::'", "'=~'", "'==~'", "'**'", "'**='",
		"'<=>'", "'==='", "'==>'", "'!=='", "'->'", "'!instanceof'", "'!in'",
		"", "", "", "", "", "", "';'", "','", "", "'='", "'>'", "'<'", "'!'",
		"'~'", "'?'", "':'", "'=='", "'<='", "'>='", "'!='", "'&&'", "'||'",
		"'++'", "'--'", "'+'", "'-'", "'*'", "", "'&'", "'|'", "'^'", "'%'",
		"'+='", "'-='", "'*='", "'/='", "'&='", "'|='", "'^='", "'%='", "'<<='",
		"'>>='", "'>>>='", "'?='", "", "", "'@'", "'...'",
	}
	staticData.SymbolicNames = []string{
		"", "StringLiteral", "GStringBegin", "GStringEnd", "GStringPart", "GStringPathPart",
		"RollBackOne", "AS", "DEF", "IN", "TRAIT", "THREADSAFE", "VAR", "BuiltInPrimitiveType",
		"ABSTRACT", "ASSERT", "BREAK", "YIELD", "CASE", "CATCH", "CLASS", "CONST",
		"CONTINUE", "DEFAULT", "DO", "ELSE", "ENUM", "EXTENDS", "FINAL", "FINALLY",
		"FOR", "IF", "GOTO", "IMPLEMENTS", "IMPORT", "INSTANCEOF", "INTERFACE",
		"NATIVE", "NEW", "NON_SEALED", "PACKAGE", "PERMITS", "PRIVATE", "PROTECTED",
		"PUBLIC", "RECORD", "RETURN", "SEALED", "STATIC", "STRICTFP", "SUPER",
		"SWITCH", "SYNCHRONIZED", "THIS", "THROW", "THROWS", "TRANSIENT", "TRY",
		"VOID", "VOLATILE", "WHILE", "IntegerLiteral", "FloatingPointLiteral",
		"BooleanLiteral", "NullLiteral", "RANGE_INCLUSIVE", "RANGE_EXCLUSIVE_LEFT",
		"RANGE_EXCLUSIVE_RIGHT", "RANGE_EXCLUSIVE_FULL", "SPREAD_DOT", "SAFE_DOT",
		"SAFE_INDEX", "SAFE_CHAIN_DOT", "ELVIS", "METHOD_POINTER", "METHOD_REFERENCE",
		"REGEX_FIND", "REGEX_MATCH", "POWER", "POWER_ASSIGN", "SPACESHIP", "IDENTICAL",
		"IMPLIES", "NOT_IDENTICAL", "ARROW", "NOT_INSTANCEOF", "NOT_IN", "LPAREN",
		"RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK", "SEMI", "COMMA", "DOT",
		"ASSIGN", "GT", "LT", "NOT", "BITNOT", "QUESTION", "COLON", "EQUAL",
		"LE", "GE", "NOTEQUAL", "AND", "OR", "INC", "DEC", "ADD", "SUB", "MUL",
		"DIV", "BITAND", "BITOR", "XOR", "MOD", "ADD_ASSIGN", "SUB_ASSIGN",
		"MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN",
		"MOD_ASSIGN", "LSHIFT_ASSIGN", "RSHIFT_ASSIGN", "URSHIFT_ASSIGN", "ELVIS_ASSIGN",
		"CapitalizedIdentifier", "Identifier", "AT", "ELLIPSIS", "WS", "NL",
		"SH_COMMENT", "UNEXPECTED_CHAR",
	}
	staticData.RuleNames = []string{
		"compilationUnit", "scriptStatements", "scriptStatement", "packageDeclaration",
		"importDeclaration", "typeDeclaration", "modifier", "modifiersOpt",
		"modifiers", "classOrInterfaceModifiersOpt", "classOrInterfaceModifiers",
		"classOrInterfaceModifier", "variableModifier", "variableModifiersOpt",
		"variableModifiers", "typeParameters", "typeParameter", "typeBound",
		"typeList", "classDeclaration", "classBody", "enumConstants", "enumConstant",
		"classBodyDeclaration", "memberDeclaration", "methodDeclaration", "compactConstructorDeclaration",
		"methodName", "returnType", "fieldDeclaration", "variableDeclarators",
		"variableDeclarator", "variableDeclaratorId", "variableInitializer",
		"variableInitializers", "emptyDims", "emptyDimsOpt", "standardType",
		"type", "generalClassOrInterfaceType", "standardClassOrInterfaceType",
		"primitiveType", "typeArguments", "typeArgument", "annotatedQualifiedClassName",
		"qualifiedClassNameList", "formalParameters", "formalParameterList",
		"thisFormalParameter", "formalParameter", "methodBody", "qualifiedName",
		"qualifiedNameElement", "qualifiedNameElements", "qualifiedClassName",
		"qualifiedStandardClassName", "literal", "gstring", "gstringValue",
		"gstringPath", "lambdaExpression", "standardLambdaExpression", "lambdaParameters",
		"standardLambdaParameters", "lambdaBody", "closure", "closureOrLambdaExpression",
		"blockStatementsOpt", "blockStatements", "annotationsOpt", "annotation",
		"elementValues", "annotationName", "elementValuePairs", "elementValuePair",
		"elementValuePairName", "elementValue", "elementValueArrayInitializer",
		"block", "blockStatement", "localVariableDeclaration", "variableDeclaration",
		"typeNamePairs", "typeNamePair", "variableNames", "conditionalStatement",
		"ifElseStatement", "switchStatement", "loopStatement", "continueStatement",
		"breakStatement", "yieldStatement", "tryCatchStatement", "assertStatement",
		"statement", "catchClause", "catchType", "finallyBlock", "resources",
		"resourceList", "resource", "switchBlockStatementGroup", "switchLabel",
		"forControl", "enhancedForControl", "classicalForControl", "forInit",
		"forUpdate", "castParExpression", "parExpression", "expressionInPar",
		"expressionList", "expressionListElement", "enhancedStatementExpression",
		"statementExpression", "postfixExpression", "switchExpression", "switchBlockStatementExpressionGroup",
		"switchExpressionLabel", "expression", "castOperandExpression", "commandExpression",
		"commandArgument", "pathExpression", "pathElement", "namePart", "dynamicMemberName",
		"indexPropertyArgs", "namedPropertyArgs", "primary", "namedPropertyArgPrimary",
		"namedArgPrimary", "commandPrimary", "list", "map", "mapEntryList",
		"namedPropertyArgList", "mapEntry", "namedPropertyArg", "namedArg",
		"mapEntryLabel", "namedPropertyArgLabel", "namedArgLabel", "creator",
		"dim", "arrayInitializer", "anonymousInnerClassDeclaration", "createdName",
		"nonWildcardTypeArguments", "typeArgumentsOrDiamond", "arguments", "argumentList",
		"enhancedArgumentListInPar", "firstArgumentListElement", "argumentListElement",
		"enhancedArgumentListElement", "stringLiteral", "className", "identifier",
		"builtInType", "keywords", "rparen", "nls", "sep",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 138, 1812, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 1, 0, 1, 0, 1, 0, 3, 0, 332, 8, 0, 3, 0, 334, 8, 0,
		1, 0, 3, 0, 337, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 345, 8,
		1, 10, 1, 12, 1, 348, 9, 1, 1, 1, 3, 1, 351, 8, 1, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 3, 2, 358, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 3,
		4, 367, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 374, 8, 4, 1, 5, 1, 5,
		1, 5, 1, 6, 1, 6, 3, 6, 381, 8, 6, 1, 7, 1, 7, 1, 7, 3, 7, 386, 8, 7, 1,
		8, 1, 8, 1, 8, 1, 8, 5, 8, 392, 8, 8, 10, 8, 12, 8, 395, 9, 8, 1, 9, 1,
		9, 5, 9, 399, 8, 9, 10, 9, 12, 9, 402, 9, 9, 3, 9, 404, 8, 9, 1, 10, 1,
		10, 1, 10, 1, 10, 5, 10, 410, 8, 10, 10, 10, 12, 10, 413, 9, 10, 1, 11,
		1, 11, 3, 11, 417, 8, 11, 1, 12, 1, 12, 3, 12, 421, 8, 12, 1, 13, 1, 13,
		1, 13, 3, 13, 426, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 5, 14, 432, 8, 14,
		10, 14, 12, 14, 435, 9, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 5, 15, 444, 8, 15, 10, 15, 12, 15, 447, 9, 15, 1, 15, 1, 15, 1, 15,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 458, 8, 16, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 5, 17, 465, 8, 17, 10, 17, 12, 17, 468, 9, 17,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 475, 8, 18, 10, 18, 12, 18, 478,
		9, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 3, 19, 493, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		3, 19, 499, 8, 19, 1, 19, 1, 19, 1, 19, 3, 19, 504, 8, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 3, 19, 511, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 3, 19, 518, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 525, 8,
		19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		3, 20, 537, 8, 20, 1, 20, 3, 20, 540, 8, 20, 1, 20, 3, 20, 543, 8, 20,
		1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 549, 8, 20, 10, 20, 12, 20, 552, 9,
		20, 3, 20, 554, 8, 20, 1, 20, 3, 20, 557, 8, 20, 1, 20, 1, 20, 1, 21, 1,
		21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 567, 8, 21, 10, 21, 12, 21, 570,
		9, 21, 1, 22, 1, 22, 1, 22, 3, 22, 575, 8, 22, 1, 22, 3, 22, 578, 8, 22,
		1, 23, 1, 23, 3, 23, 582, 8, 23, 1, 23, 1, 23, 3, 23, 586, 8, 23, 1, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 593, 8, 24, 3, 24, 595, 8, 24, 1, 25,
		1, 25, 3, 25, 599, 8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 604, 8, 25, 1, 25,
		1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3,
		25, 617, 8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 622, 8, 25, 1, 26, 1, 26, 1,
		26, 1, 26, 1, 27, 1, 27, 3, 27, 630, 8, 27, 1, 28, 1, 28, 3, 28, 634, 8,
		28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 643, 8, 30,
		10, 30, 12, 30, 646, 9, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3,
		31, 654, 8, 31, 1, 32, 1, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34,
		1, 34, 1, 34, 5, 34, 666, 8, 34, 10, 34, 12, 34, 669, 9, 34, 1, 34, 1,
		34, 3, 34, 673, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 4, 35, 679, 8, 35, 11,
		35, 12, 35, 680, 1, 36, 3, 36, 684, 8, 36, 1, 37, 1, 37, 1, 37, 3, 37,
		689, 8, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 3, 38, 696, 8, 38, 1, 38,
		3, 38, 699, 8, 38, 1, 38, 1, 38, 1, 39, 1, 39, 3, 39, 705, 8, 39, 1, 40,
		1, 40, 3, 40, 709, 8, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 5, 42, 720, 8, 42, 10, 42, 12, 42, 723, 9, 42, 1, 42,
		1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 735,
		8, 43, 3, 43, 737, 8, 43, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 5, 45, 747, 8, 45, 10, 45, 12, 45, 750, 9, 45, 1, 46, 1, 46,
		3, 46, 754, 8, 46, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 760, 8, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 5, 47, 766, 8, 47, 10, 47, 12, 47, 769, 9, 47, 1,
		48, 1, 48, 1, 48, 1, 49, 1, 49, 3, 49, 776, 8, 49, 1, 49, 3, 49, 779, 8,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 787, 8, 49, 1, 50,
		1, 50, 1, 51, 1, 51, 1, 51, 5, 51, 794, 8, 51, 10, 51, 12, 51, 797, 9,
		51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 804, 8, 52, 1, 53, 1, 53,
		1, 53, 5, 53, 809, 8, 53, 10, 53, 12, 53, 812, 9, 53, 1, 54, 1, 54, 1,
		54, 1, 55, 1, 55, 1, 55, 1, 55, 5, 55, 821, 8, 55, 10, 55, 12, 55, 824,
		9, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 831, 8, 56, 1, 57, 1,
		57, 1, 57, 1, 57, 5, 57, 837, 8, 57, 10, 57, 12, 57, 840, 9, 57, 1, 57,
		1, 57, 1, 58, 1, 58, 3, 58, 846, 8, 58, 1, 59, 1, 59, 5, 59, 850, 8, 59,
		10, 59, 12, 59, 853, 9, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 63, 1, 63, 3, 63,
		871, 8, 63, 1, 64, 1, 64, 3, 64, 875, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65,
		1, 65, 3, 65, 882, 8, 65, 1, 65, 1, 65, 3, 65, 886, 8, 65, 1, 65, 3, 65,
		889, 8, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 3, 66, 896, 8, 66, 1, 67,
		3, 67, 899, 8, 67, 1, 68, 1, 68, 1, 68, 1, 68, 5, 68, 905, 8, 68, 10, 68,
		12, 68, 908, 9, 68, 1, 68, 3, 68, 911, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69,
		5, 69, 917, 8, 69, 10, 69, 12, 69, 920, 9, 69, 1, 69, 1, 69, 3, 69, 924,
		8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 931, 8, 70, 1, 70, 1,
		70, 3, 70, 935, 8, 70, 1, 71, 1, 71, 3, 71, 939, 8, 71, 1, 72, 1, 72, 1,
		73, 1, 73, 1, 73, 5, 73, 946, 8, 73, 10, 73, 12, 73, 949, 9, 73, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 3, 75, 959, 8, 75, 1,
		76, 1, 76, 1, 76, 3, 76, 964, 8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 5, 77,
		970, 8, 77, 10, 77, 12, 77, 973, 9, 77, 1, 77, 3, 77, 976, 8, 77, 3, 77,
		978, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78, 3, 78, 984, 8, 78, 1, 78, 1, 78,
		1, 78, 1, 79, 1, 79, 3, 79, 991, 8, 79, 1, 80, 1, 80, 1, 80, 1, 81, 1,
		81, 1, 81, 3, 81, 999, 8, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81,
		1, 81, 3, 81, 1008, 8, 81, 1, 81, 1, 81, 1, 81, 3, 81, 1013, 8, 81, 1,
		82, 1, 82, 1, 82, 1, 82, 5, 82, 1019, 8, 82, 10, 82, 12, 82, 1022, 9, 82,
		1, 82, 1, 82, 1, 83, 3, 83, 1027, 8, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1,
		84, 1, 84, 4, 84, 1035, 8, 84, 11, 84, 12, 84, 1036, 1, 84, 1, 84, 1, 85,
		1, 85, 3, 85, 1043, 8, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3,
		86, 1051, 8, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 1057, 8, 86, 1, 87,
		1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 4, 87, 1065, 8, 87, 11, 87, 12, 87,
		1066, 1, 87, 1, 87, 3, 87, 1071, 8, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1,
		88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88,
		1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1094, 8, 88, 1, 89, 1,
		89, 3, 89, 1098, 8, 89, 1, 90, 1, 90, 3, 90, 1102, 8, 90, 1, 91, 1, 91,
		1, 91, 1, 92, 1, 92, 3, 92, 1109, 8, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1,
		92, 5, 92, 1116, 8, 92, 10, 92, 12, 92, 1119, 9, 92, 1, 92, 1, 92, 1, 92,
		3, 92, 1124, 8, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3,
		93, 1133, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94,
		1, 94, 1, 94, 1, 94, 3, 94, 1146, 8, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1,
		94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94,
		3, 94, 1163, 8, 94, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 1169, 8, 95, 1,
		95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 5, 96, 1179, 8, 96,
		10, 96, 12, 96, 1182, 9, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98,
		1, 98, 1, 98, 3, 98, 1192, 8, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1,
		99, 5, 99, 1200, 8, 99, 10, 99, 12, 99, 1203, 9, 99, 1, 100, 1, 100, 3,
		100, 1207, 8, 100, 1, 101, 1, 101, 1, 101, 1, 101, 5, 101, 1213, 8, 101,
		10, 101, 12, 101, 1216, 9, 101, 1, 101, 1, 101, 1, 101, 1, 102, 1, 102,
		1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 1227, 8, 102, 1, 103, 1, 103, 3,
		103, 1231, 8, 103, 1, 104, 1, 104, 3, 104, 1235, 8, 104, 1, 104, 1, 104,
		1, 104, 1, 104, 1, 105, 3, 105, 1242, 8, 105, 1, 105, 1, 105, 3, 105, 1246,
		8, 105, 1, 105, 1, 105, 3, 105, 1250, 8, 105, 1, 106, 1, 106, 3, 106, 1254,
		8, 106, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109,
		1, 110, 1, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111,
		5, 111, 1273, 8, 111, 10, 111, 12, 111, 1276, 9, 111, 1, 112, 3, 112, 1279,
		8, 112, 1, 112, 1, 112, 1, 113, 1, 113, 3, 113, 1285, 8, 113, 1, 114, 1,
		114, 1, 115, 1, 115, 3, 115, 1291, 8, 115, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 5, 116, 1299, 8, 116, 10, 116, 12, 116, 1302, 9, 116, 1,
		116, 1, 116, 1, 116, 1, 117, 1, 117, 1, 117, 4, 117, 1310, 8, 117, 11,
		117, 12, 117, 1311, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118, 3, 118, 1319,
		8, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 3, 119, 1341, 8, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 3, 119, 1368, 8, 119, 1, 119, 3, 119, 1371,
		8, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 1441, 8, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 1, 119, 5, 119, 1457, 8, 119, 10, 119, 12,
		119, 1460, 9, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120,
		1, 120, 1, 120, 1, 120, 3, 120, 1472, 8, 120, 1, 121, 1, 121, 1, 121, 1,
		121, 3, 121, 1478, 8, 121, 1, 121, 5, 121, 1481, 8, 121, 10, 121, 12, 121,
		1484, 9, 121, 1, 122, 1, 122, 4, 122, 1488, 8, 122, 11, 122, 12, 122, 1489,
		1, 122, 3, 122, 1493, 8, 122, 1, 123, 1, 123, 1, 123, 3, 123, 1498, 8,
		123, 1, 123, 1, 123, 1, 123, 5, 123, 1503, 8, 123, 10, 123, 12, 123, 1506,
		9, 123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124,
		1, 124, 1, 124, 1, 124, 3, 124, 1519, 8, 124, 1, 124, 1, 124, 1, 124, 1,
		124, 1, 124, 3, 124, 1526, 8, 124, 3, 124, 1528, 8, 124, 1, 124, 1, 124,
		1, 124, 1, 124, 1, 124, 1, 124, 3, 124, 1536, 8, 124, 1, 124, 1, 124, 1,
		124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 3, 124, 1547, 8, 124,
		1, 125, 1, 125, 1, 125, 1, 125, 3, 125, 1553, 8, 125, 1, 126, 1, 126, 3,
		126, 1557, 8, 126, 1, 127, 1, 127, 3, 127, 1561, 8, 127, 1, 127, 1, 127,
		1, 128, 1, 128, 1, 128, 3, 128, 1568, 8, 128, 1, 128, 1, 128, 1, 129, 1,
		129, 3, 129, 1574, 8, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129,
		1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 3, 129, 1589, 8,
		129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 1597, 8, 130,
		1, 131, 1, 131, 1, 131, 3, 131, 1602, 8, 131, 1, 132, 1, 132, 1, 132, 3,
		132, 1607, 8, 132, 1, 133, 1, 133, 3, 133, 1611, 8, 133, 1, 133, 3, 133,
		1614, 8, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 3, 134, 1621, 8,
		134, 1, 134, 3, 134, 1624, 8, 134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135,
		5, 135, 1631, 8, 135, 10, 135, 12, 135, 1634, 9, 135, 1, 136, 1, 136, 1,
		136, 5, 136, 1639, 8, 136, 10, 136, 12, 136, 1642, 9, 136, 1, 137, 1, 137,
		1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137,
		1654, 8, 137, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 1,
		138, 1, 138, 1, 138, 3, 138, 1666, 8, 138, 1, 139, 1, 139, 1, 139, 1, 139,
		1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 1678, 8, 139, 1,
		140, 1, 140, 3, 140, 1682, 8, 140, 1, 141, 1, 141, 3, 141, 1686, 8, 141,
		1, 142, 1, 142, 3, 142, 1690, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143, 3,
		143, 1696, 8, 143, 1, 143, 4, 143, 1699, 8, 143, 11, 143, 12, 143, 1700,
		1, 143, 1, 143, 1, 143, 3, 143, 1706, 8, 143, 3, 143, 1708, 8, 143, 1,
		144, 1, 144, 1, 144, 3, 144, 1713, 8, 144, 1, 144, 1, 144, 1, 145, 1, 145,
		1, 145, 1, 145, 1, 145, 3, 145, 1722, 8, 145, 1, 145, 1, 145, 1, 146, 1,
		146, 1, 147, 1, 147, 1, 147, 1, 147, 3, 147, 1732, 8, 147, 3, 147, 1734,
		8, 147, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 149, 1, 149,
		1, 149, 3, 149, 1745, 8, 149, 1, 150, 1, 150, 3, 150, 1749, 8, 150, 1,
		150, 3, 150, 1752, 8, 150, 1, 150, 1, 150, 1, 151, 1, 151, 1, 151, 1, 151,
		1, 151, 5, 151, 1761, 8, 151, 10, 151, 12, 151, 1764, 9, 151, 1, 152, 1,
		152, 1, 152, 1, 152, 1, 152, 5, 152, 1771, 8, 152, 10, 152, 12, 152, 1774,
		9, 152, 1, 153, 1, 153, 3, 153, 1778, 8, 153, 1, 154, 1, 154, 3, 154, 1782,
		8, 154, 1, 155, 1, 155, 1, 155, 3, 155, 1787, 8, 155, 1, 156, 1, 156, 1,
		157, 1, 157, 1, 158, 1, 158, 1, 159, 1, 159, 1, 160, 1, 160, 1, 161, 1,
		161, 1, 162, 5, 162, 1802, 8, 162, 10, 162, 12, 162, 1805, 9, 162, 1, 163,
		4, 163, 1808, 8, 163, 11, 163, 12, 163, 1809, 1, 163, 0, 1, 238, 164, 0,
		2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
		40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
		76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
		110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
		140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
		170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
		200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
		230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
		260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288,
		290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318,
		320, 322, 324, 326, 0, 24, 6, 0, 8, 8, 12, 12, 37, 37, 52, 52, 56, 56,
		59, 59, 6, 0, 14, 14, 23, 23, 28, 28, 39, 39, 42, 44, 47, 49, 6, 0, 8,
		8, 12, 12, 14, 14, 28, 28, 42, 44, 48, 49, 2, 0, 27, 27, 50, 50, 2, 0,
		94, 94, 102, 102, 2, 0, 9, 9, 102, 102, 1, 0, 109, 110, 2, 0, 84, 84, 102,
		102, 1, 0, 99, 100, 1, 0, 109, 112, 2, 0, 113, 114, 118, 118, 1, 0, 111,
		112, 1, 0, 65, 68, 4, 0, 9, 9, 86, 86, 97, 98, 104, 105, 4, 0, 80, 81,
		83, 83, 103, 103, 106, 106, 1, 0, 76, 77, 3, 0, 7, 7, 35, 35, 85, 85, 3,
		0, 79, 79, 96, 96, 119, 130, 3, 0, 69, 70, 72, 72, 95, 95, 2, 0, 71, 71,
		91, 91, 8, 0, 7, 7, 9, 10, 12, 12, 17, 17, 41, 41, 45, 45, 47, 47, 131,
		132, 2, 0, 13, 13, 58, 58, 2, 0, 7, 60, 63, 64, 2, 0, 93, 93, 136, 136,
		1916, 0, 328, 1, 0, 0, 0, 2, 340, 1, 0, 0, 0, 4, 357, 1, 0, 0, 0, 6, 359,
		1, 0, 0, 0, 8, 363, 1, 0, 0, 0, 10, 375, 1, 0, 0, 0, 12, 380, 1, 0, 0,
		0, 14, 385, 1, 0, 0, 0, 16, 387, 1, 0, 0, 0, 18, 403, 1, 0, 0, 0, 20, 405,
		1, 0, 0, 0, 22, 416, 1, 0, 0, 0, 24, 420, 1, 0, 0, 0, 26, 425, 1, 0, 0,
		0, 28, 427, 1, 0, 0, 0, 30, 436, 1, 0, 0, 0, 32, 451, 1, 0, 0, 0, 34, 459,
		1, 0, 0, 0, 36, 469, 1, 0, 0, 0, 38, 492, 1, 0, 0, 0, 40, 529, 1, 0, 0,
		0, 42, 560, 1, 0, 0, 0, 44, 571, 1, 0, 0, 0, 46, 585, 1, 0, 0, 0, 48, 594,
		1, 0, 0, 0, 50, 596, 1, 0, 0, 0, 52, 623, 1, 0, 0, 0, 54, 629, 1, 0, 0,
		0, 56, 633, 1, 0, 0, 0, 58, 635, 1, 0, 0, 0, 60, 637, 1, 0, 0, 0, 62, 647,
		1, 0, 0, 0, 64, 655, 1, 0, 0, 0, 66, 657, 1, 0, 0, 0, 68, 659, 1, 0, 0,
		0, 70, 678, 1, 0, 0, 0, 72, 683, 1, 0, 0, 0, 74, 685, 1, 0, 0, 0, 76, 692,
		1, 0, 0, 0, 78, 702, 1, 0, 0, 0, 80, 706, 1, 0, 0, 0, 82, 710, 1, 0, 0,
		0, 84, 712, 1, 0, 0, 0, 86, 736, 1, 0, 0, 0, 88, 738, 1, 0, 0, 0, 90, 741,
		1, 0, 0, 0, 92, 751, 1, 0, 0, 0, 94, 759, 1, 0, 0, 0, 96, 770, 1, 0, 0,
		0, 98, 773, 1, 0, 0, 0, 100, 788, 1, 0, 0, 0, 102, 790, 1, 0, 0, 0, 104,
		803, 1, 0, 0, 0, 106, 810, 1, 0, 0, 0, 108, 813, 1, 0, 0, 0, 110, 816,
		1, 0, 0, 0, 112, 830, 1, 0, 0, 0, 114, 832, 1, 0, 0, 0, 116, 845, 1, 0,
		0, 0, 118, 847, 1, 0, 0, 0, 120, 854, 1, 0, 0, 0, 122, 860, 1, 0, 0, 0,
		124, 866, 1, 0, 0, 0, 126, 870, 1, 0, 0, 0, 128, 874, 1, 0, 0, 0, 130,
		876, 1, 0, 0, 0, 132, 895, 1, 0, 0, 0, 134, 898, 1, 0, 0, 0, 136, 900,
		1, 0, 0, 0, 138, 923, 1, 0, 0, 0, 140, 925, 1, 0, 0, 0, 142, 938, 1, 0,
		0, 0, 144, 940, 1, 0, 0, 0, 146, 942, 1, 0, 0, 0, 148, 950, 1, 0, 0, 0,
		150, 958, 1, 0, 0, 0, 152, 963, 1, 0, 0, 0, 154, 965, 1, 0, 0, 0, 156,
		981, 1, 0, 0, 0, 158, 990, 1, 0, 0, 0, 160, 992, 1, 0, 0, 0, 162, 1012,
		1, 0, 0, 0, 164, 1014, 1, 0, 0, 0, 166, 1026, 1, 0, 0, 0, 168, 1030, 1,
		0, 0, 0, 170, 1042, 1, 0, 0, 0, 172, 1044, 1, 0, 0, 0, 174, 1058, 1, 0,
		0, 0, 176, 1093, 1, 0, 0, 0, 178, 1095, 1, 0, 0, 0, 180, 1099, 1, 0, 0,
		0, 182, 1103, 1, 0, 0, 0, 184, 1106, 1, 0, 0, 0, 186, 1125, 1, 0, 0, 0,
		188, 1162, 1, 0, 0, 0, 190, 1164, 1, 0, 0, 0, 192, 1175, 1, 0, 0, 0, 194,
		1183, 1, 0, 0, 0, 196, 1187, 1, 0, 0, 0, 198, 1195, 1, 0, 0, 0, 200, 1206,
		1, 0, 0, 0, 202, 1208, 1, 0, 0, 0, 204, 1226, 1, 0, 0, 0, 206, 1230, 1,
		0, 0, 0, 208, 1232, 1, 0, 0, 0, 210, 1241, 1, 0, 0, 0, 212, 1253, 1, 0,
		0, 0, 214, 1255, 1, 0, 0, 0, 216, 1257, 1, 0, 0, 0, 218, 1261, 1, 0, 0,
		0, 220, 1263, 1, 0, 0, 0, 222, 1267, 1, 0, 0, 0, 224, 1278, 1, 0, 0, 0,
		226, 1284, 1, 0, 0, 0, 228, 1286, 1, 0, 0, 0, 230, 1288, 1, 0, 0, 0, 232,
		1292, 1, 0, 0, 0, 234, 1309, 1, 0, 0, 0, 236, 1318, 1, 0, 0, 0, 238, 1340,
		1, 0, 0, 0, 240, 1471, 1, 0, 0, 0, 242, 1473, 1, 0, 0, 0, 244, 1485, 1,
		0, 0, 0, 246, 1497, 1, 0, 0, 0, 248, 1546, 1, 0, 0, 0, 250, 1552, 1, 0,
		0, 0, 252, 1556, 1, 0, 0, 0, 254, 1558, 1, 0, 0, 0, 256, 1564, 1, 0, 0,
		0, 258, 1588, 1, 0, 0, 0, 260, 1596, 1, 0, 0, 0, 262, 1601, 1, 0, 0, 0,
		264, 1606, 1, 0, 0, 0, 266, 1608, 1, 0, 0, 0, 268, 1617, 1, 0, 0, 0, 270,
		1627, 1, 0, 0, 0, 272, 1635, 1, 0, 0, 0, 274, 1653, 1, 0, 0, 0, 276, 1665,
		1, 0, 0, 0, 278, 1677, 1, 0, 0, 0, 280, 1681, 1, 0, 0, 0, 282, 1685, 1,
		0, 0, 0, 284, 1689, 1, 0, 0, 0, 286, 1691, 1, 0, 0, 0, 288, 1709, 1, 0,
		0, 0, 290, 1716, 1, 0, 0, 0, 292, 1725, 1, 0, 0, 0, 294, 1727, 1, 0, 0,
		0, 296, 1735, 1, 0, 0, 0, 298, 1744, 1, 0, 0, 0, 300, 1746, 1, 0, 0, 0,
		302, 1755, 1, 0, 0, 0, 304, 1765, 1, 0, 0, 0, 306, 1777, 1, 0, 0, 0, 308,
		1781, 1, 0, 0, 0, 310, 1786, 1, 0, 0, 0, 312, 1788, 1, 0, 0, 0, 314, 1790,
		1, 0, 0, 0, 316, 1792, 1, 0, 0, 0, 318, 1794, 1, 0, 0, 0, 320, 1796, 1,
		0, 0, 0, 322, 1798, 1, 0, 0, 0, 324, 1803, 1, 0, 0, 0, 326, 1807, 1, 0,
		0, 0, 328, 333, 3, 324, 162, 0, 329, 331, 3, 6, 3, 0, 330, 332, 3, 326,
		163, 0, 331, 330, 1, 0, 0, 0, 331, 332, 1, 0, 0, 0, 332, 334, 1, 0, 0,
		0, 333, 329, 1, 0, 0, 0, 333, 334, 1, 0, 0, 0, 334, 336, 1, 0, 0, 0, 335,
		337, 3, 2, 1, 0, 336, 335, 1, 0, 0, 0, 336, 337, 1, 0, 0, 0, 337, 338,
		1, 0, 0, 0, 338, 339, 5, 0, 0, 1, 339, 1, 1, 0, 0, 0, 340, 346, 3, 4, 2,
		0, 341, 342, 3, 326, 163, 0, 342, 343, 3, 4, 2, 0, 343, 345, 1, 0, 0, 0,
		344, 341, 1, 0, 0, 0, 345, 348, 1, 0, 0, 0, 346, 344, 1, 0, 0, 0, 346,
		347, 1, 0, 0, 0, 347, 350, 1, 0, 0, 0, 348, 346, 1, 0, 0, 0, 349, 351,
		3, 326, 163, 0, 350, 349, 1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 3, 1,
		0, 0, 0, 352, 358, 3, 8, 4, 0, 353, 358, 3, 10, 5, 0, 354, 355, 4, 2, 0,
		0, 355, 358, 3, 50, 25, 0, 356, 358, 3, 188, 94, 0, 357, 352, 1, 0, 0,
		0, 357, 353, 1, 0, 0, 0, 357, 354, 1, 0, 0, 0, 357, 356, 1, 0, 0, 0, 358,
		5, 1, 0, 0, 0, 359, 360, 3, 138, 69, 0, 360, 361, 5, 40, 0, 0, 361, 362,
		3, 102, 51, 0, 362, 7, 1, 0, 0, 0, 363, 364, 3, 138, 69, 0, 364, 366, 5,
		34, 0, 0, 365, 367, 5, 48, 0, 0, 366, 365, 1, 0, 0, 0, 366, 367, 1, 0,
		0, 0, 367, 368, 1, 0, 0, 0, 368, 373, 3, 102, 51, 0, 369, 370, 5, 95, 0,
		0, 370, 374, 5, 113, 0, 0, 371, 372, 5, 7, 0, 0, 372, 374, 3, 316, 158,
		0, 373, 369, 1, 0, 0, 0, 373, 371, 1, 0, 0, 0, 373, 374, 1, 0, 0, 0, 374,
		9, 1, 0, 0, 0, 375, 376, 3, 18, 9, 0, 376, 377, 3, 38, 19, 0, 377, 11,
		1, 0, 0, 0, 378, 381, 3, 22, 11, 0, 379, 381, 7, 0, 0, 0, 380, 378, 1,
		0, 0, 0, 380, 379, 1, 0, 0, 0, 381, 13, 1, 0, 0, 0, 382, 383, 3, 16, 8,
		0, 383, 384, 3, 324, 162, 0, 384, 386, 1, 0, 0, 0, 385, 382, 1, 0, 0, 0,
		385, 386, 1, 0, 0, 0, 386, 15, 1, 0, 0, 0, 387, 393, 3, 12, 6, 0, 388,
		389, 3, 324, 162, 0, 389, 390, 3, 12, 6, 0, 390, 392, 1, 0, 0, 0, 391,
		388, 1, 0, 0, 0, 392, 395, 1, 0, 0, 0, 393, 391, 1, 0, 0, 0, 393, 394,
		1, 0, 0, 0, 394, 17, 1, 0, 0, 0, 395, 393, 1, 0, 0, 0, 396, 400, 3, 20,
		10, 0, 397, 399, 5, 136, 0, 0, 398, 397, 1, 0, 0, 0, 399, 402, 1, 0, 0,
		0, 400, 398, 1, 0, 0, 0, 400, 401, 1, 0, 0, 0, 401, 404, 1, 0, 0, 0, 402,
		400, 1, 0, 0, 0, 403, 396, 1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404, 19, 1,
		0, 0, 0, 405, 411, 3, 22, 11, 0, 406, 407, 3, 324, 162, 0, 407, 408, 3,
		22, 11, 0, 408, 410, 1, 0, 0, 0, 409, 406, 1, 0, 0, 0, 410, 413, 1, 0,
		0, 0, 411, 409, 1, 0, 0, 0, 411, 412, 1, 0, 0, 0, 412, 21, 1, 0, 0, 0,
		413, 411, 1, 0, 0, 0, 414, 417, 3, 140, 70, 0, 415, 417, 7, 1, 0, 0, 416,
		414, 1, 0, 0, 0, 416, 415, 1, 0, 0, 0, 417, 23, 1, 0, 0, 0, 418, 421, 3,
		140, 70, 0, 419, 421, 7, 2, 0, 0, 420, 418, 1, 0, 0, 0, 420, 419, 1, 0,
		0, 0, 421, 25, 1, 0, 0, 0, 422, 423, 3, 28, 14, 0, 423, 424, 3, 324, 162,
		0, 424, 426, 1, 0, 0, 0, 425, 422, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426,
		27, 1, 0, 0, 0, 427, 433, 3, 24, 12, 0, 428, 429, 3, 324, 162, 0, 429,
		430, 3, 24, 12, 0, 430, 432, 1, 0, 0, 0, 431, 428, 1, 0, 0, 0, 432, 435,
		1, 0, 0, 0, 433, 431, 1, 0, 0, 0, 433, 434, 1, 0, 0, 0, 434, 29, 1, 0,
		0, 0, 435, 433, 1, 0, 0, 0, 436, 437, 5, 98, 0, 0, 437, 438, 3, 324, 162,
		0, 438, 445, 3, 32, 16, 0, 439, 440, 5, 94, 0, 0, 440, 441, 3, 324, 162,
		0, 441, 442, 3, 32, 16, 0, 442, 444, 1, 0, 0, 0, 443, 439, 1, 0, 0, 0,
		444, 447, 1, 0, 0, 0, 445, 443, 1, 0, 0, 0, 445, 446, 1, 0, 0, 0, 446,
		448, 1, 0, 0, 0, 447, 445, 1, 0, 0, 0, 448, 449, 3, 324, 162, 0, 449, 450,
		5, 97, 0, 0, 450, 31, 1, 0, 0, 0, 451, 452, 3, 138, 69, 0, 452, 457, 3,
		314, 157, 0, 453, 454, 5, 27, 0, 0, 454, 455, 3, 324, 162, 0, 455, 456,
		3, 34, 17, 0, 456, 458, 1, 0, 0, 0, 457, 453, 1, 0, 0, 0, 457, 458, 1,
		0, 0, 0, 458, 33, 1, 0, 0, 0, 459, 466, 3, 76, 38, 0, 460, 461, 5, 115,
		0, 0, 461, 462, 3, 324, 162, 0, 462, 463, 3, 76, 38, 0, 463, 465, 1, 0,
		0, 0, 464, 460, 1, 0, 0, 0, 465, 468, 1, 0, 0, 0, 466, 464, 1, 0, 0, 0,
		466, 467, 1, 0, 0, 0, 467, 35, 1, 0, 0, 0, 468, 466, 1, 0, 0, 0, 469, 476,
		3, 76, 38, 0, 470, 471, 5, 94, 0, 0, 471, 472, 3, 324, 162, 0, 472, 473,
		3, 76, 38, 0, 473, 475, 1, 0, 0, 0, 474, 470, 1, 0, 0, 0, 475, 478, 1,
		0, 0, 0, 476, 474, 1, 0, 0, 0, 476, 477, 1, 0, 0, 0, 477, 37, 1, 0, 0,
		0, 478, 476, 1, 0, 0, 0, 479, 480, 5, 20, 0, 0, 480, 493, 6, 19, -1, 0,
		481, 482, 5, 36, 0, 0, 482, 493, 6, 19, -1, 0, 483, 484, 5, 26, 0, 0, 484,
		493, 6, 19, -1, 0, 485, 486, 5, 133, 0, 0, 486, 487, 5, 36, 0, 0, 487,
		493, 6, 19, -1, 0, 488, 489, 5, 10, 0, 0, 489, 493, 6, 19, -1, 0, 490,
		491, 5, 45, 0, 0, 491, 493, 6, 19, -1, 0, 492, 479, 1, 0, 0, 0, 492, 481,
		1, 0, 0, 0, 492, 483, 1, 0, 0, 0, 492, 485, 1, 0, 0, 0, 492, 488, 1, 0,
		0, 0, 492, 490, 1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494, 498, 3, 316, 158,
		0, 495, 496, 3, 324, 162, 0, 496, 497, 3, 30, 15, 0, 497, 499, 1, 0, 0,
		0, 498, 495, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0, 499, 503, 1, 0, 0, 0, 500,
		501, 3, 324, 162, 0, 501, 502, 3, 92, 46, 0, 502, 504, 1, 0, 0, 0, 503,
		500, 1, 0, 0, 0, 503, 504, 1, 0, 0, 0, 504, 510, 1, 0, 0, 0, 505, 506,
		3, 324, 162, 0, 506, 507, 5, 27, 0, 0, 507, 508, 3, 324, 162, 0, 508, 509,
		3, 36, 18, 0, 509, 511, 1, 0, 0, 0, 510, 505, 1, 0, 0, 0, 510, 511, 1,
		0, 0, 0, 511, 517, 1, 0, 0, 0, 512, 513, 3, 324, 162, 0, 513, 514, 5, 33,
		0, 0, 514, 515, 3, 324, 162, 0, 515, 516, 3, 36, 18, 0, 516, 518, 1, 0,
		0, 0, 517, 512, 1, 0, 0, 0, 517, 518, 1, 0, 0, 0, 518, 524, 1, 0, 0, 0,
		519, 520, 3, 324, 162, 0, 520, 521, 5, 41, 0, 0, 521, 522, 3, 324, 162,
		0, 522, 523, 3, 36, 18, 0, 523, 525, 1, 0, 0, 0, 524, 519, 1, 0, 0, 0,
		524, 525, 1, 0, 0, 0, 525, 526, 1, 0, 0, 0, 526, 527, 3, 324, 162, 0, 527,
		528, 3, 40, 20, 0, 528, 39, 1, 0, 0, 0, 529, 530, 5, 89, 0, 0, 530, 542,
		3, 324, 162, 0, 531, 532, 4, 20, 1, 1, 532, 536, 3, 42, 21, 0, 533, 534,
		3, 324, 162, 0, 534, 535, 5, 94, 0, 0, 535, 537, 1, 0, 0, 0, 536, 533,
		1, 0, 0, 0, 536, 537, 1, 0, 0, 0, 537, 539, 1, 0, 0, 0, 538, 540, 3, 326,
		163, 0, 539, 538, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 543, 1, 0, 0,
		0, 541, 543, 1, 0, 0, 0, 542, 531, 1, 0, 0, 0, 542, 541, 1, 0, 0, 0, 543,
		553, 1, 0, 0, 0, 544, 550, 3, 46, 23, 0, 545, 546, 3, 326, 163, 0, 546,
		547, 3, 46, 23, 0, 547, 549, 1, 0, 0, 0, 548, 545, 1, 0, 0, 0, 549, 552,
		1, 0, 0, 0, 550, 548, 1, 0, 0, 0, 550, 551, 1, 0, 0, 0, 551, 554, 1, 0,
		0, 0, 552, 550, 1, 0, 0, 0, 553, 544, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0,
		554, 556, 1, 0, 0, 0, 555, 557, 3, 326, 163, 0, 556, 555, 1, 0, 0, 0, 556,
		557, 1, 0, 0, 0, 557, 558, 1, 0, 0, 0, 558, 559, 5, 90, 0, 0, 559, 41,
		1, 0, 0, 0, 560, 568, 3, 44, 22, 0, 561, 562, 3, 324, 162, 0, 562, 563,
		5, 94, 0, 0, 563, 564, 3, 324, 162, 0, 564, 565, 3, 44, 22, 0, 565, 567,
		1, 0, 0, 0, 566, 561, 1, 0, 0, 0, 567, 570, 1, 0, 0, 0, 568, 566, 1, 0,
		0, 0, 568, 569, 1, 0, 0, 0, 569, 43, 1, 0, 0, 0, 570, 568, 1, 0, 0, 0,
		571, 572, 3, 138, 69, 0, 572, 574, 3, 316, 158, 0, 573, 575, 3, 300, 150,
		0, 574, 573, 1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 577, 1, 0, 0, 0, 576,
		578, 3, 292, 146, 0, 577, 576, 1, 0, 0, 0, 577, 578, 1, 0, 0, 0, 578, 45,
		1, 0, 0, 0, 579, 580, 5, 48, 0, 0, 580, 582, 3, 324, 162, 0, 581, 579,
		1, 0, 0, 0, 581, 582, 1, 0, 0, 0, 582, 583, 1, 0, 0, 0, 583, 586, 3, 156,
		78, 0, 584, 586, 3, 48, 24, 0, 585, 581, 1, 0, 0, 0, 585, 584, 1, 0, 0,
		0, 586, 47, 1, 0, 0, 0, 587, 595, 3, 50, 25, 0, 588, 595, 3, 58, 29, 0,
		589, 592, 3, 14, 7, 0, 590, 593, 3, 38, 19, 0, 591, 593, 3, 52, 26, 0,
		592, 590, 1, 0, 0, 0, 592, 591, 1, 0, 0, 0, 593, 595, 1, 0, 0, 0, 594,
		587, 1, 0, 0, 0, 594, 588, 1, 0, 0, 0, 594, 589, 1, 0, 0, 0, 595, 49, 1,
		0, 0, 0, 596, 598, 3, 14, 7, 0, 597, 599, 3, 30, 15, 0, 598, 597, 1, 0,
		0, 0, 598, 599, 1, 0, 0, 0, 599, 603, 1, 0, 0, 0, 600, 601, 3, 56, 28,
		0, 601, 602, 3, 324, 162, 0, 602, 604, 1, 0, 0, 0, 603, 600, 1, 0, 0, 0,
		603, 604, 1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605, 606, 3, 54, 27, 0, 606,
		621, 3, 92, 46, 0, 607, 608, 5, 23, 0, 0, 608, 609, 3, 324, 162, 0, 609,
		610, 3, 152, 76, 0, 610, 622, 1, 0, 0, 0, 611, 612, 3, 324, 162, 0, 612,
		613, 5, 55, 0, 0, 613, 614, 3, 324, 162, 0, 614, 615, 3, 90, 45, 0, 615,
		617, 1, 0, 0, 0, 616, 611, 1, 0, 0, 0, 616, 617, 1, 0, 0, 0, 617, 618,
		1, 0, 0, 0, 618, 619, 3, 324, 162, 0, 619, 620, 3, 100, 50, 0, 620, 622,
		1, 0, 0, 0, 621, 607, 1, 0, 0, 0, 621, 616, 1, 0, 0, 0, 621, 622, 1, 0,
		0, 0, 622, 51, 1, 0, 0, 0, 623, 624, 3, 54, 27, 0, 624, 625, 3, 324, 162,
		0, 625, 626, 3, 100, 50, 0, 626, 53, 1, 0, 0, 0, 627, 630, 3, 316, 158,
		0, 628, 630, 3, 312, 156, 0, 629, 627, 1, 0, 0, 0, 629, 628, 1, 0, 0, 0,
		630, 55, 1, 0, 0, 0, 631, 634, 3, 74, 37, 0, 632, 634, 5, 58, 0, 0, 633,
		631, 1, 0, 0, 0, 633, 632, 1, 0, 0, 0, 634, 57, 1, 0, 0, 0, 635, 636, 3,
		162, 81, 0, 636, 59, 1, 0, 0, 0, 637, 644, 3, 62, 31, 0, 638, 639, 5, 94,
		0, 0, 639, 640, 3, 324, 162, 0, 640, 641, 3, 62, 31, 0, 641, 643, 1, 0,
		0, 0, 642, 638, 1, 0, 0, 0, 643, 646, 1, 0, 0, 0, 644, 642, 1, 0, 0, 0,
		644, 645, 1, 0, 0, 0, 645, 61, 1, 0, 0, 0, 646, 644, 1, 0, 0, 0, 647, 653,
		3, 64, 32, 0, 648, 649, 3, 324, 162, 0, 649, 650, 5, 96, 0, 0, 650, 651,
		3, 324, 162, 0, 651, 652, 3, 66, 33, 0, 652, 654, 1, 0, 0, 0, 653, 648,
		1, 0, 0, 0, 653, 654, 1, 0, 0, 0, 654, 63, 1, 0, 0, 0, 655, 656, 3, 316,
		158, 0, 656, 65, 1, 0, 0, 0, 657, 658, 3, 226, 113, 0, 658, 67, 1, 0, 0,
		0, 659, 667, 3, 66, 33, 0, 660, 661, 3, 324, 162, 0, 661, 662, 5, 94, 0,
		0, 662, 663, 3, 324, 162, 0, 663, 664, 3, 66, 33, 0, 664, 666, 1, 0, 0,
		0, 665, 660, 1, 0, 0, 0, 666, 669, 1, 0, 0, 0, 667, 665, 1, 0, 0, 0, 667,
		668, 1, 0, 0, 0, 668, 670, 1, 0, 0, 0, 669, 667, 1, 0, 0, 0, 670, 672,
		3, 324, 162, 0, 671, 673, 5, 94, 0, 0, 672, 671, 1, 0, 0, 0, 672, 673,
		1, 0, 0, 0, 673, 69, 1, 0, 0, 0, 674, 675, 3, 138, 69, 0, 675, 676, 5,
		91, 0, 0, 676, 677, 5, 92, 0, 0, 677, 679, 1, 0, 0, 0, 678, 674, 1, 0,
		0, 0, 679, 680, 1, 0, 0, 0, 680, 678, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0,
		681, 71, 1, 0, 0, 0, 682, 684, 3, 70, 35, 0, 683, 682, 1, 0, 0, 0, 683,
		684, 1, 0, 0, 0, 684, 73, 1, 0, 0, 0, 685, 688, 3, 138, 69, 0, 686, 689,
		3, 82, 41, 0, 687, 689, 3, 80, 40, 0, 688, 686, 1, 0, 0, 0, 688, 687, 1,
		0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 691, 3, 72, 36, 0, 691, 75, 1, 0, 0,
		0, 692, 698, 3, 138, 69, 0, 693, 696, 3, 82, 41, 0, 694, 696, 5, 58, 0,
		0, 695, 693, 1, 0, 0, 0, 695, 694, 1, 0, 0, 0, 696, 699, 1, 0, 0, 0, 697,
		699, 3, 78, 39, 0, 698, 695, 1, 0, 0, 0, 698, 697, 1, 0, 0, 0, 699, 700,
		1, 0, 0, 0, 700, 701, 3, 72, 36, 0, 701, 77, 1, 0, 0, 0, 702, 704, 3, 108,
		54, 0, 703, 705, 3, 84, 42, 0, 704, 703, 1, 0, 0, 0, 704, 705, 1, 0, 0,
		0, 705, 79, 1, 0, 0, 0, 706, 708, 3, 110, 55, 0, 707, 709, 3, 84, 42, 0,
		708, 707, 1, 0, 0, 0, 708, 709, 1, 0, 0, 0, 709, 81, 1, 0, 0, 0, 710, 711,
		5, 13, 0, 0, 711, 83, 1, 0, 0, 0, 712, 713, 5, 98, 0, 0, 713, 714, 3, 324,
		162, 0, 714, 721, 3, 86, 43, 0, 715, 716, 5, 94, 0, 0, 716, 717, 3, 324,
		162, 0, 717, 718, 3, 86, 43, 0, 718, 720, 1, 0, 0, 0, 719, 715, 1, 0, 0,
		0, 720, 723, 1, 0, 0, 0, 721, 719, 1, 0, 0, 0, 721, 722, 1, 0, 0, 0, 722,
		724, 1, 0, 0, 0, 723, 721, 1, 0, 0, 0, 724, 725, 3, 324, 162, 0, 725, 726,
		5, 97, 0, 0, 726, 85, 1, 0, 0, 0, 727, 737, 3, 76, 38, 0, 728, 729, 3,
		138, 69, 0, 729, 734, 5, 101, 0, 0, 730, 731, 7, 3, 0, 0, 731, 732, 3,
		324, 162, 0, 732, 733, 3, 76, 38, 0, 733, 735, 1, 0, 0, 0, 734, 730, 1,
		0, 0, 0, 734, 735, 1, 0, 0, 0, 735, 737, 1, 0, 0, 0, 736, 727, 1, 0, 0,
		0, 736, 728, 1, 0, 0, 0, 737, 87, 1, 0, 0, 0, 738, 739, 3, 138, 69, 0,
		739, 740, 3, 108, 54, 0, 740, 89, 1, 0, 0, 0, 741, 748, 3, 88, 44, 0, 742,
		743, 5, 94, 0, 0, 743, 744, 3, 324, 162, 0, 744, 745, 3, 88, 44, 0, 745,
		747, 1, 0, 0, 0, 746, 742, 1, 0, 0, 0, 747, 750, 1, 0, 0, 0, 748, 746,
		1, 0, 0, 0, 748, 749, 1, 0, 0, 0, 749, 91, 1, 0, 0, 0, 750, 748, 1, 0,
		0, 0, 751, 753, 5, 87, 0, 0, 752, 754, 3, 94, 47, 0, 753, 752, 1, 0, 0,
		0, 753, 754, 1, 0, 0, 0, 754, 755, 1, 0, 0, 0, 755, 756, 3, 322, 161, 0,
		756, 93, 1, 0, 0, 0, 757, 760, 3, 98, 49, 0, 758, 760, 3, 96, 48, 0, 759,
		757, 1, 0, 0, 0, 759, 758, 1, 0, 0, 0, 760, 767, 1, 0, 0, 0, 761, 762,
		5, 94, 0, 0, 762, 763, 3, 324, 162, 0, 763, 764, 3, 98, 49, 0, 764, 766,
		1, 0, 0, 0, 765, 761, 1, 0, 0, 0, 766, 769, 1, 0, 0, 0, 767, 765, 1, 0,
		0, 0, 767, 768, 1, 0, 0, 0, 768, 95, 1, 0, 0, 0, 769, 767, 1, 0, 0, 0,
		770, 771, 3, 76, 38, 0, 771, 772, 5, 53, 0, 0, 772, 97, 1, 0, 0, 0, 773,
		775, 3, 26, 13, 0, 774, 776, 3, 76, 38, 0, 775, 774, 1, 0, 0, 0, 775, 776,
		1, 0, 0, 0, 776, 778, 1, 0, 0, 0, 777, 779, 5, 134, 0, 0, 778, 777, 1,
		0, 0, 0, 778, 779, 1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 786, 3, 64, 32,
		0, 781, 782, 3, 324, 162, 0, 782, 783, 5, 96, 0, 0, 783, 784, 3, 324, 162,
		0, 784, 785, 3, 238, 119, 0, 785, 787, 1, 0, 0, 0, 786, 781, 1, 0, 0, 0,
		786, 787, 1, 0, 0, 0, 787, 99, 1, 0, 0, 0, 788, 789, 3, 156, 78, 0, 789,
		101, 1, 0, 0, 0, 790, 795, 3, 104, 52, 0, 791, 792, 5, 95, 0, 0, 792, 794,
		3, 104, 52, 0, 793, 791, 1, 0, 0, 0, 794, 797, 1, 0, 0, 0, 795, 793, 1,
		0, 0, 0, 795, 796, 1, 0, 0, 0, 796, 103, 1, 0, 0, 0, 797, 795, 1, 0, 0,
		0, 798, 804, 3, 316, 158, 0, 799, 804, 5, 8, 0, 0, 800, 804, 5, 9, 0, 0,
		801, 804, 5, 7, 0, 0, 802, 804, 5, 10, 0, 0, 803, 798, 1, 0, 0, 0, 803,
		799, 1, 0, 0, 0, 803, 800, 1, 0, 0, 0, 803, 801, 1, 0, 0, 0, 803, 802,
		1, 0, 0, 0, 804, 105, 1, 0, 0, 0, 805, 806, 3, 104, 52, 0, 806, 807, 5,
		95, 0, 0, 807, 809, 1, 0, 0, 0, 808, 805, 1, 0, 0, 0, 809, 812, 1, 0, 0,
		0, 810, 808, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811, 107, 1, 0, 0, 0, 812,
		810, 1, 0, 0, 0, 813, 814, 3, 106, 53, 0, 814, 815, 3, 316, 158, 0, 815,
		109, 1, 0, 0, 0, 816, 817, 3, 106, 53, 0, 817, 822, 3, 314, 157, 0, 818,
		819, 5, 95, 0, 0, 819, 821, 3, 314, 157, 0, 820, 818, 1, 0, 0, 0, 821,
		824, 1, 0, 0, 0, 822, 820, 1, 0, 0, 0, 822, 823, 1, 0, 0, 0, 823, 111,
		1, 0, 0, 0, 824, 822, 1, 0, 0, 0, 825, 831, 5, 61, 0, 0, 826, 831, 5, 62,
		0, 0, 827, 831, 3, 312, 156, 0, 828, 831, 5, 63, 0, 0, 829, 831, 5, 64,
		0, 0, 830, 825, 1, 0, 0, 0, 830, 826, 1, 0, 0, 0, 830, 827, 1, 0, 0, 0,
		830, 828, 1, 0, 0, 0, 830, 829, 1, 0, 0, 0, 831, 113, 1, 0, 0, 0, 832,
		833, 5, 2, 0, 0, 833, 838, 3, 116, 58, 0, 834, 835, 5, 4, 0, 0, 835, 837,
		3, 116, 58, 0, 836, 834, 1, 0, 0, 0, 837, 840, 1, 0, 0, 0, 838, 836, 1,
		0, 0, 0, 838, 839, 1, 0, 0, 0, 839, 841, 1, 0, 0, 0, 840, 838, 1, 0, 0,
		0, 841, 842, 5, 3, 0, 0, 842, 115, 1, 0, 0, 0, 843, 846, 3, 118, 59, 0,
		844, 846, 3, 130, 65, 0, 845, 843, 1, 0, 0, 0, 845, 844, 1, 0, 0, 0, 846,
		117, 1, 0, 0, 0, 847, 851, 3, 316, 158, 0, 848, 850, 5, 5, 0, 0, 849, 848,
		1, 0, 0, 0, 850, 853, 1, 0, 0, 0, 851, 849, 1, 0, 0, 0, 851, 852, 1, 0,
		0, 0, 852, 119, 1, 0, 0, 0, 853, 851, 1, 0, 0, 0, 854, 855, 3, 124, 62,
		0, 855, 856, 3, 324, 162, 0, 856, 857, 5, 84, 0, 0, 857, 858, 3, 324, 162,
		0, 858, 859, 3, 128, 64, 0, 859, 121, 1, 0, 0, 0, 860, 861, 3, 126, 63,
		0, 861, 862, 3, 324, 162, 0, 862, 863, 5, 84, 0, 0, 863, 864, 3, 324, 162,
		0, 864, 865, 3, 128, 64, 0, 865, 123, 1, 0, 0, 0, 866, 867, 3, 92, 46,
		0, 867, 125, 1, 0, 0, 0, 868, 871, 3, 92, 46, 0, 869, 871, 3, 64, 32, 0,
		870, 868, 1, 0, 0, 0, 870, 869, 1, 0, 0, 0, 871, 127, 1, 0, 0, 0, 872,
		875, 3, 156, 78, 0, 873, 875, 3, 228, 114, 0, 874, 872, 1, 0, 0, 0, 874,
		873, 1, 0, 0, 0, 875, 129, 1, 0, 0, 0, 876, 885, 5, 89, 0, 0, 877, 881,
		3, 324, 162, 0, 878, 879, 3, 94, 47, 0, 879, 880, 3, 324, 162, 0, 880,
		882, 1, 0, 0, 0, 881, 878, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882, 883,
		1, 0, 0, 0, 883, 884, 5, 84, 0, 0, 884, 886, 1, 0, 0, 0, 885, 877, 1, 0,
		0, 0, 885, 886, 1, 0, 0, 0, 886, 888, 1, 0, 0, 0, 887, 889, 3, 326, 163,
		0, 888, 887, 1, 0, 0, 0, 888, 889, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890,
		891, 3, 134, 67, 0, 891, 892, 5, 90, 0, 0, 892, 131, 1, 0, 0, 0, 893, 896,
		3, 130, 65, 0, 894, 896, 3, 120, 60, 0, 895, 893, 1, 0, 0, 0, 895, 894,
		1, 0, 0, 0, 896, 133, 1, 0, 0, 0, 897, 899, 3, 136, 68, 0, 898, 897, 1,
		0, 0, 0, 898, 899, 1, 0, 0, 0, 899, 135, 1, 0, 0, 0, 900, 906, 3, 158,
		79, 0, 901, 902, 3, 326, 163, 0, 902, 903, 3, 158, 79, 0, 903, 905, 1,
		0, 0, 0, 904, 901, 1, 0, 0, 0, 905, 908, 1, 0, 0, 0, 906, 904, 1, 0, 0,
		0, 906, 907, 1, 0, 0, 0, 907, 910, 1, 0, 0, 0, 908, 906, 1, 0, 0, 0, 909,
		911, 3, 326, 163, 0, 910, 909, 1, 0, 0, 0, 910, 911, 1, 0, 0, 0, 911, 137,
		1, 0, 0, 0, 912, 918, 3, 140, 70, 0, 913, 914, 3, 324, 162, 0, 914, 915,
		3, 140, 70, 0, 915, 917, 1, 0, 0, 0, 916, 913, 1, 0, 0, 0, 917, 920, 1,
		0, 0, 0, 918, 916, 1, 0, 0, 0, 918, 919, 1, 0, 0, 0, 919, 921, 1, 0, 0,
		0, 920, 918, 1, 0, 0, 0, 921, 922, 3, 324, 162, 0, 922, 924, 1, 0, 0, 0,
		923, 912, 1, 0, 0, 0, 923, 924, 1, 0, 0, 0, 924, 139, 1, 0, 0, 0, 925,
		926, 5, 133, 0, 0, 926, 934, 3, 144, 72, 0, 927, 928, 3, 324, 162, 0, 928,
		930, 5, 87, 0, 0, 929, 931, 3, 142, 71, 0, 930, 929, 1, 0, 0, 0, 930, 931,
		1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932, 933, 3, 322, 161, 0, 933, 935, 1,
		0, 0, 0, 934, 927, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 935, 141, 1, 0, 0,
		0, 936, 939, 3, 146, 73, 0, 937, 939, 3, 152, 76, 0, 938, 936, 1, 0, 0,
		0, 938, 937, 1, 0, 0, 0, 939, 143, 1, 0, 0, 0, 940, 941, 3, 108, 54, 0,
		941, 145, 1, 0, 0, 0, 942, 947, 3, 148, 74, 0, 943, 944, 5, 94, 0, 0, 944,
		946, 3, 148, 74, 0, 945, 943, 1, 0, 0, 0, 946, 949, 1, 0, 0, 0, 947, 945,
		1, 0, 0, 0, 947, 948, 1, 0, 0, 0, 948, 147, 1, 0, 0, 0, 949, 947, 1, 0,
		0, 0, 950, 951, 3, 150, 75, 0, 951, 952, 3, 324, 162, 0, 952, 953, 5, 96,
		0, 0, 953, 954, 3, 324, 162, 0, 954, 955, 3, 152, 76, 0, 955, 149, 1, 0,
		0, 0, 956, 959, 3, 316, 158, 0, 957, 959, 3, 320, 160, 0, 958, 956, 1,
		0, 0, 0, 958, 957, 1, 0, 0, 0, 959, 151, 1, 0, 0, 0, 960, 964, 3, 154,
		77, 0, 961, 964, 3, 140, 70, 0, 962, 964, 3, 238, 119, 0, 963, 960, 1,
		0, 0, 0, 963, 961, 1, 0, 0, 0, 963, 962, 1, 0, 0, 0, 964, 153, 1, 0, 0,
		0, 965, 977, 5, 91, 0, 0, 966, 971, 3, 152, 76, 0, 967, 968, 5, 94, 0,
		0, 968, 970, 3, 152, 76, 0, 969, 967, 1, 0, 0, 0, 970, 973, 1, 0, 0, 0,
		971, 969, 1, 0, 0, 0, 971, 972, 1, 0, 0, 0, 972, 975, 1, 0, 0, 0, 973,
		971, 1, 0, 0, 0, 974, 976, 5, 94, 0, 0, 975, 974, 1, 0, 0, 0, 975, 976,
		1, 0, 0, 0, 976, 978, 1, 0, 0, 0, 977, 966, 1, 0, 0, 0, 977, 978, 1, 0,
		0, 0, 978, 979, 1, 0, 0, 0, 979, 980, 5, 92, 0, 0, 980, 155, 1, 0, 0, 0,
		981, 983, 5, 89, 0, 0, 982, 984, 3, 326, 163, 0, 983, 982, 1, 0, 0, 0,
		983, 984, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985, 986, 3, 134, 67, 0, 986,
		987, 5, 90, 0, 0, 987, 157, 1, 0, 0, 0, 988, 991, 3, 160, 80, 0, 989, 991,
		3, 188, 94, 0, 990, 988, 1, 0, 0, 0, 990, 989, 1, 0, 0, 0, 991, 159, 1,
		0, 0, 0, 992, 993, 4, 80, 2, 0, 993, 994, 3, 162, 81, 0, 994, 161, 1, 0,
		0, 0, 995, 996, 3, 16, 8, 0, 996, 1007, 3, 324, 162, 0, 997, 999, 3, 76,
		38, 0, 998, 997, 1, 0, 0, 0, 998, 999, 1, 0, 0, 0, 999, 1000, 1, 0, 0,
		0, 1000, 1008, 3, 60, 30, 0, 1001, 1002, 3, 164, 82, 0, 1002, 1003, 3,
		324, 162, 0, 1003, 1004, 5, 96, 0, 0, 1004, 1005, 3, 324, 162, 0, 1005,
		1006, 3, 66, 33, 0, 1006, 1008, 1, 0, 0, 0, 1007, 998, 1, 0, 0, 0, 1007,
		1001, 1, 0, 0, 0, 1008, 1013, 1, 0, 0, 0, 1009, 1010, 3, 76, 38, 0, 1010,
		1011, 3, 60, 30, 0, 1011, 1013, 1, 0, 0, 0, 1012, 995, 1, 0, 0, 0, 1012,
		1009, 1, 0, 0, 0, 1013, 163, 1, 0, 0, 0, 1014, 1015, 5, 87, 0, 0, 1015,
		1020, 3, 166, 83, 0, 1016, 1017, 5, 94, 0, 0, 1017, 1019, 3, 166, 83, 0,
		1018, 1016, 1, 0, 0, 0, 1019, 1022, 1, 0, 0, 0, 1020, 1018, 1, 0, 0, 0,
		1020, 1021, 1, 0, 0, 0, 1021, 1023, 1, 0, 0, 0, 1022, 1020, 1, 0, 0, 0,
		1023, 1024, 3, 322, 161, 0, 1024, 165, 1, 0, 0, 0, 1025, 1027, 3, 76, 38,
		0, 1026, 1025, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1028, 1, 0, 0,
		0, 1028, 1029, 3, 64, 32, 0, 1029, 167, 1, 0, 0, 0, 1030, 1031, 5, 87,
		0, 0, 1031, 1034, 3, 64, 32, 0, 1032, 1033, 5, 94, 0, 0, 1033, 1035, 3,
		64, 32, 0, 1034, 1032, 1, 0, 0, 0, 1035, 1036, 1, 0, 0, 0, 1036, 1034,
		1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037, 1038, 1, 0, 0, 0, 1038, 1039,
		3, 322, 161, 0, 1039, 169, 1, 0, 0, 0, 1040, 1043, 3, 172, 86, 0, 1041,
		1043, 3, 174, 87, 0, 1042, 1040, 1, 0, 0, 0, 1042, 1041, 1, 0, 0, 0, 1043,
		171, 1, 0, 0, 0, 1044, 1045, 5, 31, 0, 0, 1045, 1046, 3, 220, 110, 0, 1046,
		1047, 3, 324, 162, 0, 1047, 1056, 3, 188, 94, 0, 1048, 1051, 3, 324, 162,
		0, 1049, 1051, 3, 326, 163, 0, 1050, 1048, 1, 0, 0, 0, 1050, 1049, 1, 0,
		0, 0, 1051, 1052, 1, 0, 0, 0, 1052, 1053, 5, 25, 0, 0, 1053, 1054, 3, 324,
		162, 0, 1054, 1055, 3, 188, 94, 0, 1055, 1057, 1, 0, 0, 0, 1056, 1050,
		1, 0, 0, 0, 1056, 1057, 1, 0, 0, 0, 1057, 173, 1, 0, 0, 0, 1058, 1059,
		5, 51, 0, 0, 1059, 1060, 3, 220, 110, 0, 1060, 1061, 3, 324, 162, 0, 1061,
		1062, 5, 89, 0, 0, 1062, 1070, 3, 324, 162, 0, 1063, 1065, 3, 202, 101,
		0, 1064, 1063, 1, 0, 0, 0, 1065, 1066, 1, 0, 0, 0, 1066, 1064, 1, 0, 0,
		0, 1066, 1067, 1, 0, 0, 0, 1067, 1068, 1, 0, 0, 0, 1068, 1069, 3, 324,
		162, 0, 1069, 1071, 1, 0, 0, 0, 1070, 1064, 1, 0, 0, 0, 1070, 1071, 1,
		0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 1073, 5, 90, 0, 0, 1073, 175, 1,
		0, 0, 0, 1074, 1075, 5, 30, 0, 0, 1075, 1076, 5, 87, 0, 0, 1076, 1077,
		3, 206, 103, 0, 1077, 1078, 3, 322, 161, 0, 1078, 1079, 3, 324, 162, 0,
		1079, 1080, 3, 188, 94, 0, 1080, 1094, 1, 0, 0, 0, 1081, 1082, 5, 60, 0,
		0, 1082, 1083, 3, 220, 110, 0, 1083, 1084, 3, 324, 162, 0, 1084, 1085,
		3, 188, 94, 0, 1085, 1094, 1, 0, 0, 0, 1086, 1087, 5, 24, 0, 0, 1087, 1088,
		3, 324, 162, 0, 1088, 1089, 3, 188, 94, 0, 1089, 1090, 3, 324, 162, 0,
		1090, 1091, 5, 60, 0, 0, 1091, 1092, 3, 220, 110, 0, 1092, 1094, 1, 0,
		0, 0, 1093, 1074, 1, 0, 0, 0, 1093, 1081, 1, 0, 0, 0, 1093, 1086, 1, 0,
		0, 0, 1094, 177, 1, 0, 0, 0, 1095, 1097, 5, 22, 0, 0, 1096, 1098, 3, 316,
		158, 0, 1097, 1096, 1, 0, 0, 0, 1097, 1098, 1, 0, 0, 0, 1098, 179, 1, 0,
		0, 0, 1099, 1101, 5, 16, 0, 0, 1100, 1102, 3, 316, 158, 0, 1101, 1100,
		1, 0, 0, 0, 1101, 1102, 1, 0, 0, 0, 1102, 181, 1, 0, 0, 0, 1103, 1104,
		5, 17, 0, 0, 1104, 1105, 3, 238, 119, 0, 1105, 183, 1, 0, 0, 0, 1106, 1108,
		5, 57, 0, 0, 1107, 1109, 3, 196, 98, 0, 1108, 1107, 1, 0, 0, 0, 1108, 1109,
		1, 0, 0, 0, 1109, 1110, 1, 0, 0, 0, 1110, 1111, 3, 324, 162, 0, 1111, 1117,
		3, 156, 78, 0, 1112, 1113, 3, 324, 162, 0, 1113, 1114, 3, 190, 95, 0, 1114,
		1116, 1, 0, 0, 0, 1115, 1112, 1, 0, 0, 0, 1116, 1119, 1, 0, 0, 0, 1117,
		1115, 1, 0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118, 1123, 1, 0, 0, 0, 1119,
		1117, 1, 0, 0, 0, 1120, 1121, 3, 324, 162, 0, 1121, 1122, 3, 194, 97, 0,
		1122, 1124, 1, 0, 0, 0, 1123, 1120, 1, 0, 0, 0, 1123, 1124, 1, 0, 0, 0,
		1124, 185, 1, 0, 0, 0, 1125, 1126, 5, 15, 0, 0, 1126, 1132, 3, 238, 119,
		0, 1127, 1128, 3, 324, 162, 0, 1128, 1129, 7, 4, 0, 0, 1129, 1130, 3, 324,
		162, 0, 1130, 1131, 3, 238, 119, 0, 1131, 1133, 1, 0, 0, 0, 1132, 1127,
		1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 187, 1, 0, 0, 0, 1134, 1163,
		3, 156, 78, 0, 1135, 1163, 3, 170, 85, 0, 1136, 1163, 3, 176, 88, 0, 1137,
		1163, 3, 184, 92, 0, 1138, 1139, 5, 52, 0, 0, 1139, 1140, 3, 220, 110,
		0, 1140, 1141, 3, 324, 162, 0, 1141, 1142, 3, 156, 78, 0, 1142, 1163, 1,
		0, 0, 0, 1143, 1145, 5, 46, 0, 0, 1144, 1146, 3, 238, 119, 0, 1145, 1144,
		1, 0, 0, 0, 1145, 1146, 1, 0, 0, 0, 1146, 1163, 1, 0, 0, 0, 1147, 1148,
		5, 54, 0, 0, 1148, 1163, 3, 238, 119, 0, 1149, 1163, 3, 180, 90, 0, 1150,
		1163, 3, 178, 89, 0, 1151, 1152, 4, 94, 3, 0, 1152, 1163, 3, 182, 91, 0,
		1153, 1154, 3, 316, 158, 0, 1154, 1155, 5, 102, 0, 0, 1155, 1156, 3, 324,
		162, 0, 1156, 1157, 3, 188, 94, 0, 1157, 1163, 1, 0, 0, 0, 1158, 1163,
		3, 186, 93, 0, 1159, 1163, 3, 160, 80, 0, 1160, 1163, 3, 228, 114, 0, 1161,
		1163, 5, 93, 0, 0, 1162, 1134, 1, 0, 0, 0, 1162, 1135, 1, 0, 0, 0, 1162,
		1136, 1, 0, 0, 0, 1162, 1137, 1, 0, 0, 0, 1162, 1138, 1, 0, 0, 0, 1162,
		1143, 1, 0, 0, 0, 1162, 1147, 1, 0, 0, 0, 1162, 1149, 1, 0, 0, 0, 1162,
		1150, 1, 0, 0, 0, 1162, 1151, 1, 0, 0, 0, 1162, 1153, 1, 0, 0, 0, 1162,
		1158, 1, 0, 0, 0, 1162, 1159, 1, 0, 0, 0, 1162, 1160, 1, 0, 0, 0, 1162,
		1161, 1, 0, 0, 0, 1163, 189, 1, 0, 0, 0, 1164, 1165, 5, 19, 0, 0, 1165,
		1166, 5, 87, 0, 0, 1166, 1168, 3, 26, 13, 0, 1167, 1169, 3, 192, 96, 0,
		1168, 1167, 1, 0, 0, 0, 1168, 1169, 1, 0, 0, 0, 1169, 1170, 1, 0, 0, 0,
		1170, 1171, 3, 316, 158, 0, 1171, 1172, 3, 322, 161, 0, 1172, 1173, 3,
		324, 162, 0, 1173, 1174, 3, 156, 78, 0, 1174, 191, 1, 0, 0, 0, 1175, 1180,
		3, 108, 54, 0, 1176, 1177, 5, 116, 0, 0, 1177, 1179, 3, 108, 54, 0, 1178,
		1176, 1, 0, 0, 0, 1179, 1182, 1, 0, 0, 0, 1180, 1178, 1, 0, 0, 0, 1180,
		1181, 1, 0, 0, 0, 1181, 193, 1, 0, 0, 0, 1182, 1180, 1, 0, 0, 0, 1183,
		1184, 5, 29, 0, 0, 1184, 1185, 3, 324, 162, 0, 1185, 1186, 3, 156, 78,
		0, 1186, 195, 1, 0, 0, 0, 1187, 1188, 5, 87, 0, 0, 1188, 1189, 3, 324,
		162, 0, 1189, 1191, 3, 198, 99, 0, 1190, 1192, 3, 326, 163, 0, 1191, 1190,
		1, 0, 0, 0, 1191, 1192, 1, 0, 0, 0, 1192, 1193, 1, 0, 0, 0, 1193, 1194,
		3, 322, 161, 0, 1194, 197, 1, 0, 0, 0, 1195, 1201, 3, 200, 100, 0, 1196,
		1197, 3, 326, 163, 0, 1197, 1198, 3, 200, 100, 0, 1198, 1200, 1, 0, 0,
		0, 1199, 1196, 1, 0, 0, 0, 1200, 1203, 1, 0, 0, 0, 1201, 1199, 1, 0, 0,
		0, 1201, 1202, 1, 0, 0, 0, 1202, 199, 1, 0, 0, 0, 1203, 1201, 1, 0, 0,
		0, 1204, 1207, 3, 160, 80, 0, 1205, 1207, 3, 238, 119, 0, 1206, 1204, 1,
		0, 0, 0, 1206, 1205, 1, 0, 0, 0, 1207, 201, 1, 0, 0, 0, 1208, 1214, 3,
		204, 102, 0, 1209, 1210, 3, 324, 162, 0, 1210, 1211, 3, 204, 102, 0, 1211,
		1213, 1, 0, 0, 0, 1212, 1209, 1, 0, 0, 0, 1213, 1216, 1, 0, 0, 0, 1214,
		1212, 1, 0, 0, 0, 1214, 1215, 1, 0, 0, 0, 1215, 1217, 1, 0, 0, 0, 1216,
		1214, 1, 0, 0, 0, 1217, 1218, 3, 324, 162, 0, 1218, 1219, 3, 136, 68, 0,
		1219, 203, 1, 0, 0, 0, 1220, 1221, 5, 18, 0, 0, 1221, 1222, 3, 238, 119,
		0, 1222, 1223, 5, 102, 0, 0, 1223, 1227, 1, 0, 0, 0, 1224, 1225, 5, 23,
		0, 0, 1225, 1227, 5, 102, 0, 0, 1226, 1220, 1, 0, 0, 0, 1226, 1224, 1,
		0, 0, 0, 1227, 205, 1, 0, 0, 0, 1228, 1231, 3, 208, 104, 0, 1229, 1231,
		3, 210, 105, 0, 1230, 1228, 1, 0, 0, 0, 1230, 1229, 1, 0, 0, 0, 1231, 207,
		1, 0, 0, 0, 1232, 1234, 3, 26, 13, 0, 1233, 1235, 3, 76, 38, 0, 1234, 1233,
		1, 0, 0, 0, 1234, 1235, 1, 0, 0, 0, 1235, 1236, 1, 0, 0, 0, 1236, 1237,
		3, 64, 32, 0, 1237, 1238, 7, 5, 0, 0, 1238, 1239, 3, 238, 119, 0, 1239,
		209, 1, 0, 0, 0, 1240, 1242, 3, 212, 106, 0, 1241, 1240, 1, 0, 0, 0, 1241,
		1242, 1, 0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243, 1245, 5, 93, 0, 0, 1244,
		1246, 3, 238, 119, 0, 1245, 1244, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246,
		1247, 1, 0, 0, 0, 1247, 1249, 5, 93, 0, 0, 1248, 1250, 3, 214, 107, 0,
		1249, 1248, 1, 0, 0, 0, 1249, 1250, 1, 0, 0, 0, 1250, 211, 1, 0, 0, 0,
		1251, 1254, 3, 160, 80, 0, 1252, 1254, 3, 222, 111, 0, 1253, 1251, 1, 0,
		0, 0, 1253, 1252, 1, 0, 0, 0, 1254, 213, 1, 0, 0, 0, 1255, 1256, 3, 222,
		111, 0, 1256, 215, 1, 0, 0, 0, 1257, 1258, 5, 87, 0, 0, 1258, 1259, 3,
		76, 38, 0, 1259, 1260, 3, 322, 161, 0, 1260, 217, 1, 0, 0, 0, 1261, 1262,
		3, 220, 110, 0, 1262, 219, 1, 0, 0, 0, 1263, 1264, 5, 87, 0, 0, 1264, 1265,
		3, 226, 113, 0, 1265, 1266, 3, 322, 161, 0, 1266, 221, 1, 0, 0, 0, 1267,
		1274, 3, 224, 112, 0, 1268, 1269, 5, 94, 0, 0, 1269, 1270, 3, 324, 162,
		0, 1270, 1271, 3, 224, 112, 0, 1271, 1273, 1, 0, 0, 0, 1272, 1268, 1, 0,
		0, 0, 1273, 1276, 1, 0, 0, 0, 1274, 1272, 1, 0, 0, 0, 1274, 1275, 1, 0,
		0, 0, 1275, 223, 1, 0, 0, 0, 1276, 1274, 1, 0, 0, 0, 1277, 1279, 5, 113,
		0, 0, 1278, 1277, 1, 0, 0, 0, 1278, 1279, 1, 0, 0, 0, 1279, 1280, 1, 0,
		0, 0, 1280, 1281, 3, 238, 119, 0, 1281, 225, 1, 0, 0, 0, 1282, 1285, 3,
		228, 114, 0, 1283, 1285, 3, 122, 61, 0, 1284, 1282, 1, 0, 0, 0, 1284, 1283,
		1, 0, 0, 0, 1285, 227, 1, 0, 0, 0, 1286, 1287, 3, 242, 121, 0, 1287, 229,
		1, 0, 0, 0, 1288, 1290, 3, 246, 123, 0, 1289, 1291, 7, 6, 0, 0, 1290, 1289,
		1, 0, 0, 0, 1290, 1291, 1, 0, 0, 0, 1291, 231, 1, 0, 0, 0, 1292, 1293,
		5, 51, 0, 0, 1293, 1294, 3, 220, 110, 0, 1294, 1295, 3, 324, 162, 0, 1295,
		1296, 5, 89, 0, 0, 1296, 1300, 3, 324, 162, 0, 1297, 1299, 3, 234, 117,
		0, 1298, 1297, 1, 0, 0, 0, 1299, 1302, 1, 0, 0, 0, 1300, 1298, 1, 0, 0,
		0, 1300, 1301, 1, 0, 0, 0, 1301, 1303, 1, 0, 0, 0, 1302, 1300, 1, 0, 0,
		0, 1303, 1304, 3, 324, 162, 0, 1304, 1305, 5, 90, 0, 0, 1305, 233, 1, 0,
		0, 0, 1306, 1307, 3, 236, 118, 0, 1307, 1308, 3, 324, 162, 0, 1308, 1310,
		1, 0, 0, 0, 1309, 1306, 1, 0, 0, 0, 1310, 1311, 1, 0, 0, 0, 1311, 1309,
		1, 0, 0, 0, 1311, 1312, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1314,
		3, 136, 68, 0, 1314, 235, 1, 0, 0, 0, 1315, 1316, 5, 18, 0, 0, 1316, 1319,
		3, 222, 111, 0, 1317, 1319, 5, 23, 0, 0, 1318, 1315, 1, 0, 0, 0, 1318,
		1317, 1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320, 1321, 7, 7, 0, 0, 1321,
		237, 1, 0, 0, 0, 1322, 1323, 6, 119, -1, 0, 1323, 1324, 3, 216, 108, 0,
		1324, 1325, 3, 240, 120, 0, 1325, 1341, 1, 0, 0, 0, 1326, 1341, 3, 230,
		115, 0, 1327, 1341, 3, 232, 116, 0, 1328, 1329, 7, 8, 0, 0, 1329, 1330,
		3, 324, 162, 0, 1330, 1331, 3, 238, 119, 19, 1331, 1341, 1, 0, 0, 0, 1332,
		1333, 7, 9, 0, 0, 1333, 1341, 3, 238, 119, 17, 1334, 1335, 3, 168, 84,
		0, 1335, 1336, 3, 324, 162, 0, 1336, 1337, 5, 96, 0, 0, 1337, 1338, 3,
		324, 162, 0, 1338, 1339, 3, 228, 114, 0, 1339, 1341, 1, 0, 0, 0, 1340,
		1322, 1, 0, 0, 0, 1340, 1326, 1, 0, 0, 0, 1340, 1327, 1, 0, 0, 0, 1340,
		1328, 1, 0, 0, 0, 1340, 1332, 1, 0, 0, 0, 1340, 1334, 1, 0, 0, 0, 1341,
		1458, 1, 0, 0, 0, 1342, 1343, 10, 18, 0, 0, 1343, 1344, 5, 78, 0, 0, 1344,
		1345, 3, 324, 162, 0, 1345, 1346, 3, 238, 119, 19, 1346, 1457, 1, 0, 0,
		0, 1347, 1348, 10, 16, 0, 0, 1348, 1349, 3, 324, 162, 0, 1349, 1350, 7,
		10, 0, 0, 1350, 1351, 3, 324, 162, 0, 1351, 1352, 3, 238, 119, 17, 1352,
		1457, 1, 0, 0, 0, 1353, 1354, 10, 15, 0, 0, 1354, 1355, 7, 11, 0, 0, 1355,
		1356, 3, 324, 162, 0, 1356, 1357, 3, 238, 119, 16, 1357, 1457, 1, 0, 0,
		0, 1358, 1359, 10, 14, 0, 0, 1359, 1370, 3, 324, 162, 0, 1360, 1361, 5,
		98, 0, 0, 1361, 1368, 5, 98, 0, 0, 1362, 1363, 5, 97, 0, 0, 1363, 1364,
		5, 97, 0, 0, 1364, 1368, 5, 97, 0, 0, 1365, 1366, 5, 97, 0, 0, 1366, 1368,
		5, 97, 0, 0, 1367, 1360, 1, 0, 0, 0, 1367, 1362, 1, 0, 0, 0, 1367, 1365,
		1, 0, 0, 0, 1368, 1371, 1, 0, 0, 0, 1369, 1371, 7, 12, 0, 0, 1370, 1367,
		1, 0, 0, 0, 1370, 1369, 1, 0, 0, 0, 1371, 1372, 1, 0, 0, 0, 1372, 1373,
		3, 324, 162, 0, 1373, 1374, 3, 238, 119, 15, 1374, 1457, 1, 0, 0, 0, 1375,
		1376, 10, 12, 0, 0, 1376, 1377, 3, 324, 162, 0, 1377, 1378, 7, 13, 0, 0,
		1378, 1379, 3, 324, 162, 0, 1379, 1380, 3, 238, 119, 13, 1380, 1457, 1,
		0, 0, 0, 1381, 1382, 10, 11, 0, 0, 1382, 1383, 3, 324, 162, 0, 1383, 1384,
		7, 14, 0, 0, 1384, 1385, 3, 324, 162, 0, 1385, 1386, 3, 238, 119, 12, 1386,
		1457, 1, 0, 0, 0, 1387, 1388, 10, 10, 0, 0, 1388, 1389, 3, 324, 162, 0,
		1389, 1390, 7, 15, 0, 0, 1390, 1391, 3, 324, 162, 0, 1391, 1392, 3, 238,
		119, 11, 1392, 1457, 1, 0, 0, 0, 1393, 1394, 10, 9, 0, 0, 1394, 1395, 3,
		324, 162, 0, 1395, 1396, 5, 115, 0, 0, 1396, 1397, 3, 324, 162, 0, 1397,
		1398, 3, 238, 119, 10, 1398, 1457, 1, 0, 0, 0, 1399, 1400, 10, 8, 0, 0,
		1400, 1401, 3, 324, 162, 0, 1401, 1402, 5, 117, 0, 0, 1402, 1403, 3, 324,
		162, 0, 1403, 1404, 3, 238, 119, 9, 1404, 1457, 1, 0, 0, 0, 1405, 1406,
		10, 7, 0, 0, 1406, 1407, 3, 324, 162, 0, 1407, 1408, 5, 116, 0, 0, 1408,
		1409, 3, 324, 162, 0, 1409, 1410, 3, 238, 119, 8, 1410, 1457, 1, 0, 0,
		0, 1411, 1412, 10, 6, 0, 0, 1412, 1413, 3, 324, 162, 0, 1413, 1414, 5,
		107, 0, 0, 1414, 1415, 3, 324, 162, 0, 1415, 1416, 3, 238, 119, 7, 1416,
		1457, 1, 0, 0, 0, 1417, 1418, 10, 5, 0, 0, 1418, 1419, 3, 324, 162, 0,
		1419, 1420, 5, 108, 0, 0, 1420, 1421, 3, 324, 162, 0, 1421, 1422, 3, 238,
		119, 6, 1422, 1457, 1, 0, 0, 0, 1423, 1424, 10, 4, 0, 0, 1424, 1425, 3,
		324, 162, 0, 1425, 1426, 5, 82, 0, 0, 1426, 1427, 3, 324, 162, 0, 1427,
		1428, 3, 238, 119, 4, 1428, 1457, 1, 0, 0, 0, 1429, 1430, 10, 3, 0, 0,
		1430, 1440, 3, 324, 162, 0, 1431, 1432, 5, 101, 0, 0, 1432, 1433, 3, 324,
		162, 0, 1433, 1434, 3, 238, 119, 0, 1434, 1435, 3, 324, 162, 0, 1435, 1436,
		5, 102, 0, 0, 1436, 1437, 3, 324, 162, 0, 1437, 1441, 1, 0, 0, 0, 1438,
		1439, 5, 73, 0, 0, 1439, 1441, 3, 324, 162, 0, 1440, 1431, 1, 0, 0, 0,
		1440, 1438, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1443, 3, 238, 119,
		3, 1443, 1457, 1, 0, 0, 0, 1444, 1445, 10, 13, 0, 0, 1445, 1446, 3, 324,
		162, 0, 1446, 1447, 7, 16, 0, 0, 1447, 1448, 3, 324, 162, 0, 1448, 1449,
		3, 76, 38, 0, 1449, 1457, 1, 0, 0, 0, 1450, 1451, 10, 1, 0, 0, 1451, 1452,
		3, 324, 162, 0, 1452, 1453, 7, 17, 0, 0, 1453, 1454, 3, 324, 162, 0, 1454,
		1455, 3, 226, 113, 0, 1455, 1457, 1, 0, 0, 0, 1456, 1342, 1, 0, 0, 0, 1456,
		1347, 1, 0, 0, 0, 1456, 1353, 1, 0, 0, 0, 1456, 1358, 1, 0, 0, 0, 1456,
		1375, 1, 0, 0, 0, 1456, 1381, 1, 0, 0, 0, 1456, 1387, 1, 0, 0, 0, 1456,
		1393, 1, 0, 0, 0, 1456, 1399, 1, 0, 0, 0, 1456, 1405, 1, 0, 0, 0, 1456,
		1411, 1, 0, 0, 0, 1456, 1417, 1, 0, 0, 0, 1456, 1423, 1, 0, 0, 0, 1456,
		1429, 1, 0, 0, 0, 1456, 1444, 1, 0, 0, 0, 1456, 1450, 1, 0, 0, 0, 1457,
		1460, 1, 0, 0, 0, 1458, 1456, 1, 0, 0, 0, 1458, 1459, 1, 0, 0, 0, 1459,
		239, 1, 0, 0, 0, 1460, 1458, 1, 0, 0, 0, 1461, 1462, 3, 216, 108, 0, 1462,
		1463, 3, 240, 120, 0, 1463, 1472, 1, 0, 0, 0, 1464, 1472, 3, 230, 115,
		0, 1465, 1466, 7, 8, 0, 0, 1466, 1467, 3, 324, 162, 0, 1467, 1468, 3, 240,
		120, 0, 1468, 1472, 1, 0, 0, 0, 1469, 1470, 7, 9, 0, 0, 1470, 1472, 3,
		240, 120, 0, 1471, 1461, 1, 0, 0, 0, 1471, 1464, 1, 0, 0, 0, 1471, 1465,
		1, 0, 0, 0, 1471, 1469, 1, 0, 0, 0, 1472, 241, 1, 0, 0, 0, 1473, 1477,
		3, 238, 119, 0, 1474, 1475, 4, 121, 20, 0, 1475, 1478, 3, 302, 151, 0,
		1476, 1478, 1, 0, 0, 0, 1477, 1474, 1, 0, 0, 0, 1477, 1476, 1, 0, 0, 0,
		1478, 1482, 1, 0, 0, 0, 1479, 1481, 3, 244, 122, 0, 1480, 1479, 1, 0, 0,
		0, 1481, 1484, 1, 0, 0, 0, 1482, 1480, 1, 0, 0, 0, 1482, 1483, 1, 0, 0,
		0, 1483, 243, 1, 0, 0, 0, 1484, 1482, 1, 0, 0, 0, 1485, 1492, 3, 264, 132,
		0, 1486, 1488, 3, 248, 124, 0, 1487, 1486, 1, 0, 0, 0, 1488, 1489, 1, 0,
		0, 0, 1489, 1487, 1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1493, 1, 0,
		0, 0, 1491, 1493, 3, 302, 151, 0, 1492, 1487, 1, 0, 0, 0, 1492, 1491, 1,
		0, 0, 0, 1493, 245, 1, 0, 0, 0, 1494, 1498, 3, 258, 129, 0, 1495, 1496,
		4, 123, 21, 0, 1496, 1498, 5, 48, 0, 0, 1497, 1494, 1, 0, 0, 0, 1497, 1495,
		1, 0, 0, 0, 1498, 1504, 1, 0, 0, 0, 1499, 1500, 3, 248, 124, 0, 1500, 1501,
		6, 123, -1, 0, 1501, 1503, 1, 0, 0, 0, 1502, 1499, 1, 0, 0, 0, 1503, 1506,
		1, 0, 0, 0, 1504, 1502, 1, 0, 0, 0, 1504, 1505, 1, 0, 0, 0, 1505, 247,
		1, 0, 0, 0, 1506, 1504, 1, 0, 0, 0, 1507, 1535, 3, 324, 162, 0, 1508, 1509,
		5, 95, 0, 0, 1509, 1510, 3, 324, 162, 0, 1510, 1511, 5, 38, 0, 0, 1511,
		1512, 3, 286, 143, 0, 1512, 1513, 6, 124, -1, 0, 1513, 1536, 1, 0, 0, 0,
		1514, 1515, 7, 18, 0, 0, 1515, 1518, 3, 324, 162, 0, 1516, 1519, 5, 133,
		0, 0, 1517, 1519, 3, 296, 148, 0, 1518, 1516, 1, 0, 0, 0, 1518, 1517, 1,
		0, 0, 0, 1518, 1519, 1, 0, 0, 0, 1519, 1528, 1, 0, 0, 0, 1520, 1521, 5,
		74, 0, 0, 1521, 1528, 3, 324, 162, 0, 1522, 1523, 5, 75, 0, 0, 1523, 1525,
		3, 324, 162, 0, 1524, 1526, 3, 296, 148, 0, 1525, 1524, 1, 0, 0, 0, 1525,
		1526, 1, 0, 0, 0, 1526, 1528, 1, 0, 0, 0, 1527, 1514, 1, 0, 0, 0, 1527,
		1520, 1, 0, 0, 0, 1527, 1522, 1, 0, 0, 0, 1528, 1529, 1, 0, 0, 0, 1529,
		1530, 3, 250, 125, 0, 1530, 1531, 6, 124, -1, 0, 1531, 1536, 1, 0, 0, 0,
		1532, 1533, 3, 132, 66, 0, 1533, 1534, 6, 124, -1, 0, 1534, 1536, 1, 0,
		0, 0, 1535, 1508, 1, 0, 0, 0, 1535, 1527, 1, 0, 0, 0, 1535, 1532, 1, 0,
		0, 0, 1536, 1547, 1, 0, 0, 0, 1537, 1538, 3, 300, 150, 0, 1538, 1539, 6,
		124, -1, 0, 1539, 1547, 1, 0, 0, 0, 1540, 1541, 3, 254, 127, 0, 1541, 1542,
		6, 124, -1, 0, 1542, 1547, 1, 0, 0, 0, 1543, 1544, 3, 256, 128, 0, 1544,
		1545, 6, 124, -1, 0, 1545, 1547, 1, 0, 0, 0, 1546, 1507, 1, 0, 0, 0, 1546,
		1537, 1, 0, 0, 0, 1546, 1540, 1, 0, 0, 0, 1546, 1543, 1, 0, 0, 0, 1547,
		249, 1, 0, 0, 0, 1548, 1553, 3, 316, 158, 0, 1549, 1553, 3, 312, 156, 0,
		1550, 1553, 3, 252, 126, 0, 1551, 1553, 3, 320, 160, 0, 1552, 1548, 1,
		0, 0, 0, 1552, 1549, 1, 0, 0, 0, 1552, 1550, 1, 0, 0, 0, 1552, 1551, 1,
		0, 0, 0, 1553, 251, 1, 0, 0, 0, 1554, 1557, 3, 218, 109, 0, 1555, 1557,
		3, 114, 57, 0, 1556, 1554, 1, 0, 0, 0, 1556, 1555, 1, 0, 0, 0, 1557, 253,
		1, 0, 0, 0, 1558, 1560, 7, 19, 0, 0, 1559, 1561, 3, 222, 111, 0, 1560,
		1559, 1, 0, 0, 0, 1560, 1561, 1, 0, 0, 0, 1561, 1562, 1, 0, 0, 0, 1562,
		1563, 5, 92, 0, 0, 1563, 255, 1, 0, 0, 0, 1564, 1567, 7, 19, 0, 0, 1565,
		1568, 3, 272, 136, 0, 1566, 1568, 5, 102, 0, 0, 1567, 1565, 1, 0, 0, 0,
		1567, 1566, 1, 0, 0, 0, 1568, 1569, 1, 0, 0, 0, 1569, 1570, 5, 92, 0, 0,
		1570, 257, 1, 0, 0, 0, 1571, 1573, 3, 316, 158, 0, 1572, 1574, 3, 84, 42,
		0, 1573, 1572, 1, 0, 0, 0, 1573, 1574, 1, 0, 0, 0, 1574, 1589, 1, 0, 0,
		0, 1575, 1589, 3, 112, 56, 0, 1576, 1589, 3, 114, 57, 0, 1577, 1578, 5,
		38, 0, 0, 1578, 1579, 3, 324, 162, 0, 1579, 1580, 3, 286, 143, 0, 1580,
		1589, 1, 0, 0, 0, 1581, 1589, 5, 53, 0, 0, 1582, 1589, 5, 50, 0, 0, 1583,
		1589, 3, 218, 109, 0, 1584, 1589, 3, 132, 66, 0, 1585, 1589, 3, 266, 133,
		0, 1586, 1589, 3, 268, 134, 0, 1587, 1589, 3, 318, 159, 0, 1588, 1571,
		1, 0, 0, 0, 1588, 1575, 1, 0, 0, 0, 1588, 1576, 1, 0, 0, 0, 1588, 1577,
		1, 0, 0, 0, 1588, 1581, 1, 0, 0, 0, 1588, 1582, 1, 0, 0, 0, 1588, 1583,
		1, 0, 0, 0, 1588, 1584, 1, 0, 0, 0, 1588, 1585, 1, 0, 0, 0, 1588, 1586,
		1, 0, 0, 0, 1588, 1587, 1, 0, 0, 0, 1589, 259, 1, 0, 0, 0, 1590, 1597,
		3, 316, 158, 0, 1591, 1597, 3, 112, 56, 0, 1592, 1597, 3, 114, 57, 0, 1593,
		1597, 3, 218, 109, 0, 1594, 1597, 3, 266, 133, 0, 1595, 1597, 3, 268, 134,
		0, 1596, 1590, 1, 0, 0, 0, 1596, 1591, 1, 0, 0, 0, 1596, 1592, 1, 0, 0,
		0, 1596, 1593, 1, 0, 0, 0, 1596, 1594, 1, 0, 0, 0, 1596, 1595, 1, 0, 0,
		0, 1597, 261, 1, 0, 0, 0, 1598, 1602, 3, 316, 158, 0, 1599, 1602, 3, 112,
		56, 0, 1600, 1602, 3, 114, 57, 0, 1601, 1598, 1, 0, 0, 0, 1601, 1599, 1,
		0, 0, 0, 1601, 1600, 1, 0, 0, 0, 1602, 263, 1, 0, 0, 0, 1603, 1607, 3,
		316, 158, 0, 1604, 1607, 3, 112, 56, 0, 1605, 1607, 3, 114, 57, 0, 1606,
		1603, 1, 0, 0, 0, 1606, 1604, 1, 0, 0, 0, 1606, 1605, 1, 0, 0, 0, 1607,
		265, 1, 0, 0, 0, 1608, 1610, 5, 91, 0, 0, 1609, 1611, 3, 222, 111, 0, 1610,
		1609, 1, 0, 0, 0, 1610, 1611, 1, 0, 0, 0, 1611, 1613, 1, 0, 0, 0, 1612,
		1614, 5, 94, 0, 0, 1613, 1612, 1, 0, 0, 0, 1613, 1614, 1, 0, 0, 0, 1614,
		1615, 1, 0, 0, 0, 1615, 1616, 5, 92, 0, 0, 1616, 267, 1, 0, 0, 0, 1617,
		1623, 5, 91, 0, 0, 1618, 1620, 3, 270, 135, 0, 1619, 1621, 5, 94, 0, 0,
		1620, 1619, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1624, 1, 0, 0, 0,
		1622, 1624, 5, 102, 0, 0, 1623, 1618, 1, 0, 0, 0, 1623, 1622, 1, 0, 0,
		0, 1624, 1625, 1, 0, 0, 0, 1625, 1626, 5, 92, 0, 0, 1626, 269, 1, 0, 0,
		0, 1627, 1632, 3, 274, 137, 0, 1628, 1629, 5, 94, 0, 0, 1629, 1631, 3,
		274, 137, 0, 1630, 1628, 1, 0, 0, 0, 1631, 1634, 1, 0, 0, 0, 1632, 1630,
		1, 0, 0, 0, 1632, 1633, 1, 0, 0, 0, 1633, 271, 1, 0, 0, 0, 1634, 1632,
		1, 0, 0, 0, 1635, 1640, 3, 276, 138, 0, 1636, 1637, 5, 94, 0, 0, 1637,
		1639, 3, 276, 138, 0, 1638, 1636, 1, 0, 0, 0, 1639, 1642, 1, 0, 0, 0, 1640,
		1638, 1, 0, 0, 0, 1640, 1641, 1, 0, 0, 0, 1641, 273, 1, 0, 0, 0, 1642,
		1640, 1, 0, 0, 0, 1643, 1644, 3, 280, 140, 0, 1644, 1645, 5, 102, 0, 0,
		1645, 1646, 3, 324, 162, 0, 1646, 1647, 3, 238, 119, 0, 1647, 1654, 1,
		0, 0, 0, 1648, 1649, 5, 113, 0, 0, 1649, 1650, 5, 102, 0, 0, 1650, 1651,
		3, 324, 162, 0, 1651, 1652, 3, 238, 119, 0, 1652, 1654, 1, 0, 0, 0, 1653,
		1643, 1, 0, 0, 0, 1653, 1648, 1, 0, 0, 0, 1654, 275, 1, 0, 0, 0, 1655,
		1656, 3, 282, 141, 0, 1656, 1657, 5, 102, 0, 0, 1657, 1658, 3, 324, 162,
		0, 1658, 1659, 3, 238, 119, 0, 1659, 1666, 1, 0, 0, 0, 1660, 1661, 5, 113,
		0, 0, 1661, 1662, 5, 102, 0, 0, 1662, 1663, 3, 324, 162, 0, 1663, 1664,
		3, 238, 119, 0, 1664, 1666, 1, 0, 0, 0, 1665, 1655, 1, 0, 0, 0, 1665, 1660,
		1, 0, 0, 0, 1666, 277, 1, 0, 0, 0, 1667, 1668, 3, 284, 142, 0, 1668, 1669,
		5, 102, 0, 0, 1669, 1670, 3, 324, 162, 0, 1670, 1671, 3, 238, 119, 0, 1671,
		1678, 1, 0, 0, 0, 1672, 1673, 5, 113, 0, 0, 1673, 1674, 5, 102, 0, 0, 1674,
		1675, 3, 324, 162, 0, 1675, 1676, 3, 238, 119, 0, 1676, 1678, 1, 0, 0,
		0, 1677, 1667, 1, 0, 0, 0, 1677, 1672, 1, 0, 0, 0, 1678, 279, 1, 0, 0,
		0, 1679, 1682, 3, 320, 160, 0, 1680, 1682, 3, 258, 129, 0, 1681, 1679,
		1, 0, 0, 0, 1681, 1680, 1, 0, 0, 0, 1682, 281, 1, 0, 0, 0, 1683, 1686,
		3, 320, 160, 0, 1684, 1686, 3, 260, 130, 0, 1685, 1683, 1, 0, 0, 0, 1685,
		1684, 1, 0, 0, 0, 1686, 283, 1, 0, 0, 0, 1687, 1690, 3, 320, 160, 0, 1688,
		1690, 3, 262, 131, 0, 1689, 1687, 1, 0, 0, 0, 1689, 1688, 1, 0, 0, 0, 1690,
		285, 1, 0, 0, 0, 1691, 1707, 3, 294, 147, 0, 1692, 1693, 3, 324, 162, 0,
		1693, 1695, 3, 300, 150, 0, 1694, 1696, 3, 292, 146, 0, 1695, 1694, 1,
		0, 0, 0, 1695, 1696, 1, 0, 0, 0, 1696, 1708, 1, 0, 0, 0, 1697, 1699, 3,
		288, 144, 0, 1698, 1697, 1, 0, 0, 0, 1699, 1700, 1, 0, 0, 0, 1700, 1698,
		1, 0, 0, 0, 1700, 1701, 1, 0, 0, 0, 1701, 1705, 1, 0, 0, 0, 1702, 1703,
		3, 324, 162, 0, 1703, 1704, 3, 290, 145, 0, 1704, 1706, 1, 0, 0, 0, 1705,
		1702, 1, 0, 0, 0, 1705, 1706, 1, 0, 0, 0, 1706, 1708, 1, 0, 0, 0, 1707,
		1692, 1, 0, 0, 0, 1707, 1698, 1, 0, 0, 0, 1708, 287, 1, 0, 0, 0, 1709,
		1710, 3, 138, 69, 0, 1710, 1712, 5, 91, 0, 0, 1711, 1713, 3, 238, 119,
		0, 1712, 1711, 1, 0, 0, 0, 1712, 1713, 1, 0, 0, 0, 1713, 1714, 1, 0, 0,
		0, 1714, 1715, 5, 92, 0, 0, 1715, 289, 1, 0, 0, 0, 1716, 1717, 5, 89, 0,
		0, 1717, 1721, 3, 324, 162, 0, 1718, 1719, 3, 68, 34, 0, 1719, 1720, 3,
		324, 162, 0, 1720, 1722, 1, 0, 0, 0, 1721, 1718, 1, 0, 0, 0, 1721, 1722,
		1, 0, 0, 0, 1722, 1723, 1, 0, 0, 0, 1723, 1724, 5, 90, 0, 0, 1724, 291,
		1, 0, 0, 0, 1725, 1726, 3, 40, 20, 0, 1726, 293, 1, 0, 0, 0, 1727, 1733,
		3, 138, 69, 0, 1728, 1734, 3, 82, 41, 0, 1729, 1731, 3, 108, 54, 0, 1730,
		1732, 3, 298, 149, 0, 1731, 1730, 1, 0, 0, 0, 1731, 1732, 1, 0, 0, 0, 1732,
		1734, 1, 0, 0, 0, 1733, 1728, 1, 0, 0, 0, 1733, 1729, 1, 0, 0, 0, 1734,
		295, 1, 0, 0, 0, 1735, 1736, 5, 98, 0, 0, 1736, 1737, 3, 324, 162, 0, 1737,
		1738, 3, 36, 18, 0, 1738, 1739, 3, 324, 162, 0, 1739, 1740, 5, 97, 0, 0,
		1740, 297, 1, 0, 0, 0, 1741, 1742, 5, 98, 0, 0, 1742, 1745, 5, 97, 0, 0,
		1743, 1745, 3, 84, 42, 0, 1744, 1741, 1, 0, 0, 0, 1744, 1743, 1, 0, 0,
		0, 1745, 299, 1, 0, 0, 0, 1746, 1748, 5, 87, 0, 0, 1747, 1749, 3, 304,
		152, 0, 1748, 1747, 1, 0, 0, 0, 1748, 1749, 1, 0, 0, 0, 1749, 1751, 1,
		0, 0, 0, 1750, 1752, 5, 94, 0, 0, 1751, 1750, 1, 0, 0, 0, 1751, 1752, 1,
		0, 0, 0, 1752, 1753, 1, 0, 0, 0, 1753, 1754, 3, 322, 161, 0, 1754, 301,
		1, 0, 0, 0, 1755, 1762, 3, 306, 153, 0, 1756, 1757, 5, 94, 0, 0, 1757,
		1758, 3, 324, 162, 0, 1758, 1759, 3, 308, 154, 0, 1759, 1761, 1, 0, 0,
		0, 1760, 1756, 1, 0, 0, 0, 1761, 1764, 1, 0, 0, 0, 1762, 1760, 1, 0, 0,
		0, 1762, 1763, 1, 0, 0, 0, 1763, 303, 1, 0, 0, 0, 1764, 1762, 1, 0, 0,
		0, 1765, 1772, 3, 310, 155, 0, 1766, 1767, 5, 94, 0, 0, 1767, 1768, 3,
		324, 162, 0, 1768, 1769, 3, 310, 155, 0, 1769, 1771, 1, 0, 0, 0, 1770,
		1766, 1, 0, 0, 0, 1771, 1774, 1, 0, 0, 0, 1772, 1770, 1, 0, 0, 0, 1772,
		1773, 1, 0, 0, 0, 1773, 305, 1, 0, 0, 0, 1774, 1772, 1, 0, 0, 0, 1775,
		1778, 3, 224, 112, 0, 1776, 1778, 3, 278, 139, 0, 1777, 1775, 1, 0, 0,
		0, 1777, 1776, 1, 0, 0, 0, 1778, 307, 1, 0, 0, 0, 1779, 1782, 3, 224, 112,
		0, 1780, 1782, 3, 276, 138, 0, 1781, 1779, 1, 0, 0, 0, 1781, 1780, 1, 0,
		0, 0, 1782, 309, 1, 0, 0, 0, 1783, 1787, 3, 224, 112, 0, 1784, 1787, 3,
		122, 61, 0, 1785, 1787, 3, 276, 138, 0, 1786, 1783, 1, 0, 0, 0, 1786, 1784,
		1, 0, 0, 0, 1786, 1785, 1, 0, 0, 0, 1787, 311, 1, 0, 0, 0, 1788, 1789,
		5, 1, 0, 0, 1789, 313, 1, 0, 0, 0, 1790, 1791, 5, 131, 0, 0, 1791, 315,
		1, 0, 0, 0, 1792, 1793, 7, 20, 0, 0, 1793, 317, 1, 0, 0, 0, 1794, 1795,
		7, 21, 0, 0, 1795, 319, 1, 0, 0, 0, 1796, 1797, 7, 22, 0, 0, 1797, 321,
		1, 0, 0, 0, 1798, 1799, 5, 88, 0, 0, 1799, 323, 1, 0, 0, 0, 1800, 1802,
		5, 136, 0, 0, 1801, 1800, 1, 0, 0, 0, 1802, 1805, 1, 0, 0, 0, 1803, 1801,
		1, 0, 0, 0, 1803, 1804, 1, 0, 0, 0, 1804, 325, 1, 0, 0, 0, 1805, 1803,
		1, 0, 0, 0, 1806, 1808, 7, 23, 0, 0, 1807, 1806, 1, 0, 0, 0, 1808, 1809,
		1, 0, 0, 0, 1809, 1807, 1, 0, 0, 0, 1809, 1810, 1, 0, 0, 0, 1810, 327,
		1, 0, 0, 0, 195, 331, 333, 336, 346, 350, 357, 366, 373, 380, 385, 393,
		400, 403, 411, 416, 420, 425, 433, 445, 457, 466, 476, 492, 498, 503, 510,
		517, 524, 536, 539, 542, 550, 553, 556, 568, 574, 577, 581, 585, 592, 594,
		598, 603, 616, 621, 629, 633, 644, 653, 667, 672, 680, 683, 688, 695, 698,
		704, 708, 721, 734, 736, 748, 753, 759, 767, 775, 778, 786, 795, 803, 810,
		822, 830, 838, 845, 851, 870, 874, 881, 885, 888, 895, 898, 906, 910, 918,
		923, 930, 934, 938, 947, 958, 963, 971, 975, 977, 983, 990, 998, 1007,
		1012, 1020, 1026, 1036, 1042, 1050, 1056, 1066, 1070, 1093, 1097, 1101,
		1108, 1117, 1123, 1132, 1145, 1162, 1168, 1180, 1191, 1201, 1206, 1214,
		1226, 1230, 1234, 1241, 1245, 1249, 1253, 1274, 1278, 1284, 1290, 1300,
		1311, 1318, 1340, 1367, 1370, 1440, 1456, 1458, 1471, 1477, 1482, 1489,
		1492, 1497, 1504, 1518, 1525, 1527, 1535, 1546, 1552, 1556, 1560, 1567,
		1573, 1588, 1596, 1601, 1606, 1610, 1613, 1620, 1623, 1632, 1640, 1653,
		1665, 1677, 1681, 1685, 1689, 1695, 1700, 1705, 1707, 1712, 1721, 1731,
		1733, 1744, 1748, 1751, 1762, 1772, 1777, 1781, 1786, 1803, 1809,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// GroovyParserInit initializes any static state used to implement GroovyParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewGroovyParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func GroovyParserInit() {
	staticData := &GroovyParserParserStaticData
	staticData.once.Do(groovyparserParserInit)
}

// NewGroovyParser produces a new parser instance for the optional input antlr.TokenStream.
func NewGroovyParser(input antlr.TokenStream) *GroovyParser {
	GroovyParserInit()
	this := new(GroovyParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &GroovyParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "GroovyParser.g4"

	return this
}

// GroovyParser tokens.
const (
	GroovyParserEOF                   = antlr.TokenEOF
	GroovyParserStringLiteral         = 1
	GroovyParserGStringBegin          = 2
	GroovyParserGStringEnd            = 3
	GroovyParserGStringPart           = 4
	GroovyParserGStringPathPart       = 5
	GroovyParserRollBackOne           = 6
	GroovyParserAS                    = 7
	GroovyParserDEF                   = 8
	GroovyParserIN                    = 9
	GroovyParserTRAIT                 = 10
	GroovyParserTHREADSAFE            = 11
	GroovyParserVAR                   = 12
	GroovyParserBuiltInPrimitiveType  = 13
	GroovyParserABSTRACT              = 14
	GroovyParserASSERT                = 15
	GroovyParserBREAK                 = 16
	GroovyParserYIELD                 = 17
	GroovyParserCASE                  = 18
	GroovyParserCATCH                 = 19
	GroovyParserCLASS                 = 20
	GroovyParserCONST                 = 21
	GroovyParserCONTINUE              = 22
	GroovyParserDEFAULT               = 23
	GroovyParserDO                    = 24
	GroovyParserELSE                  = 25
	GroovyParserENUM                  = 26
	GroovyParserEXTENDS               = 27
	GroovyParserFINAL                 = 28
	GroovyParserFINALLY               = 29
	GroovyParserFOR                   = 30
	GroovyParserIF                    = 31
	GroovyParserGOTO                  = 32
	GroovyParserIMPLEMENTS            = 33
	GroovyParserIMPORT                = 34
	GroovyParserINSTANCEOF            = 35
	GroovyParserINTERFACE             = 36
	GroovyParserNATIVE                = 37
	GroovyParserNEW                   = 38
	GroovyParserNON_SEALED            = 39
	GroovyParserPACKAGE               = 40
	GroovyParserPERMITS               = 41
	GroovyParserPRIVATE               = 42
	GroovyParserPROTECTED             = 43
	GroovyParserPUBLIC                = 44
	GroovyParserRECORD                = 45
	GroovyParserRETURN                = 46
	GroovyParserSEALED                = 47
	GroovyParserSTATIC                = 48
	GroovyParserSTRICTFP              = 49
	GroovyParserSUPER                 = 50
	GroovyParserSWITCH                = 51
	GroovyParserSYNCHRONIZED          = 52
	GroovyParserTHIS                  = 53
	GroovyParserTHROW                 = 54
	GroovyParserTHROWS                = 55
	GroovyParserTRANSIENT             = 56
	GroovyParserTRY                   = 57
	GroovyParserVOID                  = 58
	GroovyParserVOLATILE              = 59
	GroovyParserWHILE                 = 60
	GroovyParserIntegerLiteral        = 61
	GroovyParserFloatingPointLiteral  = 62
	GroovyParserBooleanLiteral        = 63
	GroovyParserNullLiteral           = 64
	GroovyParserRANGE_INCLUSIVE       = 65
	GroovyParserRANGE_EXCLUSIVE_LEFT  = 66
	GroovyParserRANGE_EXCLUSIVE_RIGHT = 67
	GroovyParserRANGE_EXCLUSIVE_FULL  = 68
	GroovyParserSPREAD_DOT            = 69
	GroovyParserSAFE_DOT              = 70
	GroovyParserSAFE_INDEX            = 71
	GroovyParserSAFE_CHAIN_DOT        = 72
	GroovyParserELVIS                 = 73
	GroovyParserMETHOD_POINTER        = 74
	GroovyParserMETHOD_REFERENCE      = 75
	GroovyParserREGEX_FIND            = 76
	GroovyParserREGEX_MATCH           = 77
	GroovyParserPOWER                 = 78
	GroovyParserPOWER_ASSIGN          = 79
	GroovyParserSPACESHIP             = 80
	GroovyParserIDENTICAL             = 81
	GroovyParserIMPLIES               = 82
	GroovyParserNOT_IDENTICAL         = 83
	GroovyParserARROW                 = 84
	GroovyParserNOT_INSTANCEOF        = 85
	GroovyParserNOT_IN                = 86
	GroovyParserLPAREN                = 87
	GroovyParserRPAREN                = 88
	GroovyParserLBRACE                = 89
	GroovyParserRBRACE                = 90
	GroovyParserLBRACK                = 91
	GroovyParserRBRACK                = 92
	GroovyParserSEMI                  = 93
	GroovyParserCOMMA                 = 94
	GroovyParserDOT                   = 95
	GroovyParserASSIGN                = 96
	GroovyParserGT                    = 97
	GroovyParserLT                    = 98
	GroovyParserNOT                   = 99
	GroovyParserBITNOT                = 100
	GroovyParserQUESTION              = 101
	GroovyParserCOLON                 = 102
	GroovyParserEQUAL                 = 103
	GroovyParserLE                    = 104
	GroovyParserGE                    = 105
	GroovyParserNOTEQUAL              = 106
	GroovyParserAND                   = 107
	GroovyParserOR                    = 108
	GroovyParserINC                   = 109
	GroovyParserDEC                   = 110
	GroovyParserADD                   = 111
	GroovyParserSUB                   = 112
	GroovyParserMUL                   = 113
	GroovyParserDIV                   = 114
	GroovyParserBITAND                = 115
	GroovyParserBITOR                 = 116
	GroovyParserXOR                   = 117
	GroovyParserMOD                   = 118
	GroovyParserADD_ASSIGN            = 119
	GroovyParserSUB_ASSIGN            = 120
	GroovyParserMUL_ASSIGN            = 121
	GroovyParserDIV_ASSIGN            = 122
	GroovyParserAND_ASSIGN            = 123
	GroovyParserOR_ASSIGN             = 124
	GroovyParserXOR_ASSIGN            = 125
	GroovyParserMOD_ASSIGN            = 126
	GroovyParserLSHIFT_ASSIGN         = 127
	GroovyParserRSHIFT_ASSIGN         = 128
	GroovyParserURSHIFT_ASSIGN        = 129
	GroovyParserELVIS_ASSIGN          = 130
	GroovyParserCapitalizedIdentifier = 131
	GroovyParserIdentifier            = 132
	GroovyParserAT                    = 133
	GroovyParserELLIPSIS              = 134
	GroovyParserWS                    = 135
	GroovyParserNL                    = 136
	GroovyParserSH_COMMENT            = 137
	GroovyParserUNEXPECTED_CHAR       = 138
)

// GroovyParser rules.
const (
	GroovyParserRULE_compilationUnit                     = 0
	GroovyParserRULE_scriptStatements                    = 1
	GroovyParserRULE_scriptStatement                     = 2
	GroovyParserRULE_packageDeclaration                  = 3
	GroovyParserRULE_importDeclaration                   = 4
	GroovyParserRULE_typeDeclaration                     = 5
	GroovyParserRULE_modifier                            = 6
	GroovyParserRULE_modifiersOpt                        = 7
	GroovyParserRULE_modifiers                           = 8
	GroovyParserRULE_classOrInterfaceModifiersOpt        = 9
	GroovyParserRULE_classOrInterfaceModifiers           = 10
	GroovyParserRULE_classOrInterfaceModifier            = 11
	GroovyParserRULE_variableModifier                    = 12
	GroovyParserRULE_variableModifiersOpt                = 13
	GroovyParserRULE_variableModifiers                   = 14
	GroovyParserRULE_typeParameters                      = 15
	GroovyParserRULE_typeParameter                       = 16
	GroovyParserRULE_typeBound                           = 17
	GroovyParserRULE_typeList                            = 18
	GroovyParserRULE_classDeclaration                    = 19
	GroovyParserRULE_classBody                           = 20
	GroovyParserRULE_enumConstants                       = 21
	GroovyParserRULE_enumConstant                        = 22
	GroovyParserRULE_classBodyDeclaration                = 23
	GroovyParserRULE_memberDeclaration                   = 24
	GroovyParserRULE_methodDeclaration                   = 25
	GroovyParserRULE_compactConstructorDeclaration       = 26
	GroovyParserRULE_methodName                          = 27
	GroovyParserRULE_returnType                          = 28
	GroovyParserRULE_fieldDeclaration                    = 29
	GroovyParserRULE_variableDeclarators                 = 30
	GroovyParserRULE_variableDeclarator                  = 31
	GroovyParserRULE_variableDeclaratorId                = 32
	GroovyParserRULE_variableInitializer                 = 33
	GroovyParserRULE_variableInitializers                = 34
	GroovyParserRULE_emptyDims                           = 35
	GroovyParserRULE_emptyDimsOpt                        = 36
	GroovyParserRULE_standardType                        = 37
	GroovyParserRULE_type                                = 38
	GroovyParserRULE_generalClassOrInterfaceType         = 39
	GroovyParserRULE_standardClassOrInterfaceType        = 40
	GroovyParserRULE_primitiveType                       = 41
	GroovyParserRULE_typeArguments                       = 42
	GroovyParserRULE_typeArgument                        = 43
	GroovyParserRULE_annotatedQualifiedClassName         = 44
	GroovyParserRULE_qualifiedClassNameList              = 45
	GroovyParserRULE_formalParameters                    = 46
	GroovyParserRULE_formalParameterList                 = 47
	GroovyParserRULE_thisFormalParameter                 = 48
	GroovyParserRULE_formalParameter                     = 49
	GroovyParserRULE_methodBody                          = 50
	GroovyParserRULE_qualifiedName                       = 51
	GroovyParserRULE_qualifiedNameElement                = 52
	GroovyParserRULE_qualifiedNameElements               = 53
	GroovyParserRULE_qualifiedClassName                  = 54
	GroovyParserRULE_qualifiedStandardClassName          = 55
	GroovyParserRULE_literal                             = 56
	GroovyParserRULE_gstring                             = 57
	GroovyParserRULE_gstringValue                        = 58
	GroovyParserRULE_gstringPath                         = 59
	GroovyParserRULE_lambdaExpression                    = 60
	GroovyParserRULE_standardLambdaExpression            = 61
	GroovyParserRULE_lambdaParameters                    = 62
	GroovyParserRULE_standardLambdaParameters            = 63
	GroovyParserRULE_lambdaBody                          = 64
	GroovyParserRULE_closure                             = 65
	GroovyParserRULE_closureOrLambdaExpression           = 66
	GroovyParserRULE_blockStatementsOpt                  = 67
	GroovyParserRULE_blockStatements                     = 68
	GroovyParserRULE_annotationsOpt                      = 69
	GroovyParserRULE_annotation                          = 70
	GroovyParserRULE_elementValues                       = 71
	GroovyParserRULE_annotationName                      = 72
	GroovyParserRULE_elementValuePairs                   = 73
	GroovyParserRULE_elementValuePair                    = 74
	GroovyParserRULE_elementValuePairName                = 75
	GroovyParserRULE_elementValue                        = 76
	GroovyParserRULE_elementValueArrayInitializer        = 77
	GroovyParserRULE_block                               = 78
	GroovyParserRULE_blockStatement                      = 79
	GroovyParserRULE_localVariableDeclaration            = 80
	GroovyParserRULE_variableDeclaration                 = 81
	GroovyParserRULE_typeNamePairs                       = 82
	GroovyParserRULE_typeNamePair                        = 83
	GroovyParserRULE_variableNames                       = 84
	GroovyParserRULE_conditionalStatement                = 85
	GroovyParserRULE_ifElseStatement                     = 86
	GroovyParserRULE_switchStatement                     = 87
	GroovyParserRULE_loopStatement                       = 88
	GroovyParserRULE_continueStatement                   = 89
	GroovyParserRULE_breakStatement                      = 90
	GroovyParserRULE_yieldStatement                      = 91
	GroovyParserRULE_tryCatchStatement                   = 92
	GroovyParserRULE_assertStatement                     = 93
	GroovyParserRULE_statement                           = 94
	GroovyParserRULE_catchClause                         = 95
	GroovyParserRULE_catchType                           = 96
	GroovyParserRULE_finallyBlock                        = 97
	GroovyParserRULE_resources                           = 98
	GroovyParserRULE_resourceList                        = 99
	GroovyParserRULE_resource                            = 100
	GroovyParserRULE_switchBlockStatementGroup           = 101
	GroovyParserRULE_switchLabel                         = 102
	GroovyParserRULE_forControl                          = 103
	GroovyParserRULE_enhancedForControl                  = 104
	GroovyParserRULE_classicalForControl                 = 105
	GroovyParserRULE_forInit                             = 106
	GroovyParserRULE_forUpdate                           = 107
	GroovyParserRULE_castParExpression                   = 108
	GroovyParserRULE_parExpression                       = 109
	GroovyParserRULE_expressionInPar                     = 110
	GroovyParserRULE_expressionList                      = 111
	GroovyParserRULE_expressionListElement               = 112
	GroovyParserRULE_enhancedStatementExpression         = 113
	GroovyParserRULE_statementExpression                 = 114
	GroovyParserRULE_postfixExpression                   = 115
	GroovyParserRULE_switchExpression                    = 116
	GroovyParserRULE_switchBlockStatementExpressionGroup = 117
	GroovyParserRULE_switchExpressionLabel               = 118
	GroovyParserRULE_expression                          = 119
	GroovyParserRULE_castOperandExpression               = 120
	GroovyParserRULE_commandExpression                   = 121
	GroovyParserRULE_commandArgument                     = 122
	GroovyParserRULE_pathExpression                      = 123
	GroovyParserRULE_pathElement                         = 124
	GroovyParserRULE_namePart                            = 125
	GroovyParserRULE_dynamicMemberName                   = 126
	GroovyParserRULE_indexPropertyArgs                   = 127
	GroovyParserRULE_namedPropertyArgs                   = 128
	GroovyParserRULE_primary                             = 129
	GroovyParserRULE_namedPropertyArgPrimary             = 130
	GroovyParserRULE_namedArgPrimary                     = 131
	GroovyParserRULE_commandPrimary                      = 132
	GroovyParserRULE_list                                = 133
	GroovyParserRULE_map                                 = 134
	GroovyParserRULE_mapEntryList                        = 135
	GroovyParserRULE_namedPropertyArgList                = 136
	GroovyParserRULE_mapEntry                            = 137
	GroovyParserRULE_namedPropertyArg                    = 138
	GroovyParserRULE_namedArg                            = 139
	GroovyParserRULE_mapEntryLabel                       = 140
	GroovyParserRULE_namedPropertyArgLabel               = 141
	GroovyParserRULE_namedArgLabel                       = 142
	GroovyParserRULE_creator                             = 143
	GroovyParserRULE_dim                                 = 144
	GroovyParserRULE_arrayInitializer                    = 145
	GroovyParserRULE_anonymousInnerClassDeclaration      = 146
	GroovyParserRULE_createdName                         = 147
	GroovyParserRULE_nonWildcardTypeArguments            = 148
	GroovyParserRULE_typeArgumentsOrDiamond              = 149
	GroovyParserRULE_arguments                           = 150
	GroovyParserRULE_argumentList                        = 151
	GroovyParserRULE_enhancedArgumentListInPar           = 152
	GroovyParserRULE_firstArgumentListElement            = 153
	GroovyParserRULE_argumentListElement                 = 154
	GroovyParserRULE_enhancedArgumentListElement         = 155
	GroovyParserRULE_stringLiteral                       = 156
	GroovyParserRULE_className                           = 157
	GroovyParserRULE_identifier                          = 158
	GroovyParserRULE_builtInType                         = 159
	GroovyParserRULE_keywords                            = 160
	GroovyParserRULE_rparen                              = 161
	GroovyParserRULE_nls                                 = 162
	GroovyParserRULE_sep                                 = 163
)

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Nls() INlsContext
	EOF() antlr.TerminalNode
	PackageDeclaration() IPackageDeclarationContext
	ScriptStatements() IScriptStatementsContext
	Sep() ISepContext

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_compilationUnit
	return p
}

func InitEmptyCompilationUnitContext(p *CompilationUnitContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_compilationUnit
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *CompilationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserEOF, 0)
}

func (s *CompilationUnitContext) PackageDeclaration() IPackageDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageDeclarationContext)
}

func (s *CompilationUnitContext) ScriptStatements() IScriptStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptStatementsContext)
}

func (s *CompilationUnitContext) Sep() ISepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCompilationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) CompilationUnit() (localctx ICompilationUnitContext) {
	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, GroovyParserRULE_compilationUnit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(328)
		p.Nls()
	}
	p.SetState(333)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(329)
			p.PackageDeclaration()
		}
		p.SetState(331)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(330)
				p.Sep()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(336)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(335)
			p.ScriptStatements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(338)
		p.Match(GroovyParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScriptStatementsContext is an interface to support dynamic dispatch.
type IScriptStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllScriptStatement() []IScriptStatementContext
	ScriptStatement(i int) IScriptStatementContext
	AllSep() []ISepContext
	Sep(i int) ISepContext

	// IsScriptStatementsContext differentiates from other interfaces.
	IsScriptStatementsContext()
}

type ScriptStatementsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptStatementsContext() *ScriptStatementsContext {
	var p = new(ScriptStatementsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_scriptStatements
	return p
}

func InitEmptyScriptStatementsContext(p *ScriptStatementsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_scriptStatements
}

func (*ScriptStatementsContext) IsScriptStatementsContext() {}

func NewScriptStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptStatementsContext {
	var p = new(ScriptStatementsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_scriptStatements

	return p
}

func (s *ScriptStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptStatementsContext) AllScriptStatement() []IScriptStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScriptStatementContext); ok {
			len++
		}
	}

	tst := make([]IScriptStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScriptStatementContext); ok {
			tst[i] = t.(IScriptStatementContext)
			i++
		}
	}

	return tst
}

func (s *ScriptStatementsContext) ScriptStatement(i int) IScriptStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptStatementContext)
}

func (s *ScriptStatementsContext) AllSep() []ISepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISepContext); ok {
			len++
		}
	}

	tst := make([]ISepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISepContext); ok {
			tst[i] = t.(ISepContext)
			i++
		}
	}

	return tst
}

func (s *ScriptStatementsContext) Sep(i int) ISepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ScriptStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitScriptStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ScriptStatements() (localctx IScriptStatementsContext) {
	localctx = NewScriptStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, GroovyParserRULE_scriptStatements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(340)
		p.ScriptStatement()
	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(341)
				p.Sep()
			}
			{
				p.SetState(342)
				p.ScriptStatement()
			}

		}
		p.SetState(348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserSEMI || _la == GroovyParserNL {
		{
			p.SetState(349)
			p.Sep()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScriptStatementContext is an interface to support dynamic dispatch.
type IScriptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportDeclaration() IImportDeclarationContext
	TypeDeclaration() ITypeDeclarationContext
	MethodDeclaration() IMethodDeclarationContext
	Statement() IStatementContext

	// IsScriptStatementContext differentiates from other interfaces.
	IsScriptStatementContext()
}

type ScriptStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptStatementContext() *ScriptStatementContext {
	var p = new(ScriptStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_scriptStatement
	return p
}

func InitEmptyScriptStatementContext(p *ScriptStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_scriptStatement
}

func (*ScriptStatementContext) IsScriptStatementContext() {}

func NewScriptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptStatementContext {
	var p = new(ScriptStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_scriptStatement

	return p
}

func (s *ScriptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptStatementContext) ImportDeclaration() IImportDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *ScriptStatementContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *ScriptStatementContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *ScriptStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ScriptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitScriptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ScriptStatement() (localctx IScriptStatementContext) {
	localctx = NewScriptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, GroovyParserRULE_scriptStatement)
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(352)
			p.ImportDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(353)
			p.TypeDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(354)

		if !(!isInvalidMethodDeclaration(p.GetTokenStream())) {
			p.SetError(antlr.NewFailedPredicateException(p, " !isInvalidMethodDeclaration(p.GetTokenStream()) ", ""))
			goto errorExit
		}
		{
			p.SetState(355)
			p.MethodDeclaration(3, 9)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(356)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageDeclarationContext is an interface to support dynamic dispatch.
type IPackageDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationsOpt() IAnnotationsOptContext
	PACKAGE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsPackageDeclarationContext differentiates from other interfaces.
	IsPackageDeclarationContext()
}

type PackageDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageDeclarationContext() *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_packageDeclaration
	return p
}

func InitEmptyPackageDeclarationContext(p *PackageDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_packageDeclaration
}

func (*PackageDeclarationContext) IsPackageDeclarationContext() {}

func NewPackageDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_packageDeclaration

	return p
}

func (s *PackageDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageDeclarationContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *PackageDeclarationContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPACKAGE, 0)
}

func (s *PackageDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PackageDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitPackageDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) PackageDeclaration() (localctx IPackageDeclarationContext) {
	localctx = NewPackageDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, GroovyParserRULE_packageDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.AnnotationsOpt()
	}
	{
		p.SetState(360)
		p.Match(GroovyParserPACKAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(361)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	AnnotationsOpt() IAnnotationsOptContext
	IMPORT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	STATIC() antlr.TerminalNode
	DOT() antlr.TerminalNode
	MUL() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	alias  IIdentifierContext
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_importDeclaration
	return p
}

func InitEmptyImportDeclarationContext(p *ImportDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_importDeclaration
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) GetAlias() IIdentifierContext { return s.alias }

func (s *ImportDeclarationContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *ImportDeclarationContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *ImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPORT, 0)
}

func (s *ImportDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ImportDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *ImportDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, 0)
}

func (s *ImportDeclarationContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *ImportDeclarationContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *ImportDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitImportDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, GroovyParserRULE_importDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.AnnotationsOpt()
	}
	{
		p.SetState(364)
		p.Match(GroovyParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserSTATIC {
		{
			p.SetState(365)
			p.Match(GroovyParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(368)
		p.QualifiedName()
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case GroovyParserDOT:
		{
			p.SetState(369)
			p.Match(GroovyParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(370)
			p.Match(GroovyParserMUL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GroovyParserAS:
		{
			p.SetState(371)
			p.Match(GroovyParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(372)

			var _x = p.Identifier()

			localctx.(*ImportDeclarationContext).alias = _x
		}

	case GroovyParserEOF, GroovyParserSEMI, GroovyParserNL:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOrInterfaceModifiersOpt() IClassOrInterfaceModifiersOptContext
	ClassDeclaration() IClassDeclarationContext

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeDeclaration
	return p
}

func InitEmptyTypeDeclarationContext(p *TypeDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeDeclaration
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) ClassOrInterfaceModifiersOpt() IClassOrInterfaceModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifiersOptContext)
}

func (s *TypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTypeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, GroovyParserRULE_typeDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(375)
		p.ClassOrInterfaceModifiersOpt()
	}
	{
		p.SetState(376)
		p.ClassDeclaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m token.
	GetM() antlr.Token

	// SetM sets the m token.
	SetM(antlr.Token)

	// Getter signatures
	ClassOrInterfaceModifier() IClassOrInterfaceModifierContext
	NATIVE() antlr.TerminalNode
	SYNCHRONIZED() antlr.TerminalNode
	TRANSIENT() antlr.TerminalNode
	VOLATILE() antlr.TerminalNode
	DEF() antlr.TerminalNode
	VAR() antlr.TerminalNode

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	m      antlr.Token
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_modifier
	return p
}

func InitEmptyModifierContext(p *ModifierContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_modifier
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) GetM() antlr.Token { return s.m }

func (s *ModifierContext) SetM(v antlr.Token) { s.m = v }

func (s *ModifierContext) ClassOrInterfaceModifier() IClassOrInterfaceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *ModifierContext) NATIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserNATIVE, 0)
}

func (s *ModifierContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSYNCHRONIZED, 0)
}

func (s *ModifierContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRANSIENT, 0)
}

func (s *ModifierContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOLATILE, 0)
}

func (s *ModifierContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *ModifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, GroovyParserRULE_modifier)
	var _la int

	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserABSTRACT, GroovyParserDEFAULT, GroovyParserFINAL, GroovyParserNON_SEALED, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserSEALED, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(378)
			p.ClassOrInterfaceModifier()
		}

	case GroovyParserDEF, GroovyParserVAR, GroovyParserNATIVE, GroovyParserSYNCHRONIZED, GroovyParserTRANSIENT, GroovyParserVOLATILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(379)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ModifierContext).m = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&653022083407679744) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ModifierContext).m = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifiersOptContext is an interface to support dynamic dispatch.
type IModifiersOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Modifiers() IModifiersContext
	Nls() INlsContext

	// IsModifiersOptContext differentiates from other interfaces.
	IsModifiersOptContext()
}

type ModifiersOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersOptContext() *ModifiersOptContext {
	var p = new(ModifiersOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_modifiersOpt
	return p
}

func InitEmptyModifiersOptContext(p *ModifiersOptContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_modifiersOpt
}

func (*ModifiersOptContext) IsModifiersOptContext() {}

func NewModifiersOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersOptContext {
	var p = new(ModifiersOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_modifiersOpt

	return p
}

func (s *ModifiersOptContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersOptContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ModifiersOptContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ModifiersOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersOptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitModifiersOpt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ModifiersOpt() (localctx IModifiersOptContext) {
	localctx = NewModifiersOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, GroovyParserRULE_modifiersOpt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(385)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(382)
			p.Modifiers()
		}
		{
			p.SetState(383)
			p.Nls()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifiersContext is an interface to support dynamic dispatch.
type IModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsModifiersContext differentiates from other interfaces.
	IsModifiersContext()
}

type ModifiersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersContext() *ModifiersContext {
	var p = new(ModifiersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_modifiers
	return p
}

func InitEmptyModifiersContext(p *ModifiersContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_modifiers
}

func (*ModifiersContext) IsModifiersContext() {}

func NewModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersContext {
	var p = new(ModifiersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_modifiers

	return p
}

func (s *ModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifiersContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ModifiersContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ModifiersContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Modifiers() (localctx IModifiersContext) {
	localctx = NewModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, GroovyParserRULE_modifiers)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.Modifier()
	}
	p.SetState(393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(388)
				p.Nls()
			}
			{
				p.SetState(389)
				p.Modifier()
			}

		}
		p.SetState(395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOrInterfaceModifiersOptContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifiersOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOrInterfaceModifiers() IClassOrInterfaceModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsClassOrInterfaceModifiersOptContext differentiates from other interfaces.
	IsClassOrInterfaceModifiersOptContext()
}

type ClassOrInterfaceModifiersOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceModifiersOptContext() *ClassOrInterfaceModifiersOptContext {
	var p = new(ClassOrInterfaceModifiersOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiersOpt
	return p
}

func InitEmptyClassOrInterfaceModifiersOptContext(p *ClassOrInterfaceModifiersOptContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiersOpt
}

func (*ClassOrInterfaceModifiersOptContext) IsClassOrInterfaceModifiersOptContext() {}

func NewClassOrInterfaceModifiersOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifiersOptContext {
	var p = new(ClassOrInterfaceModifiersOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiersOpt

	return p
}

func (s *ClassOrInterfaceModifiersOptContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifiersOptContext) ClassOrInterfaceModifiers() IClassOrInterfaceModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifiersContext)
}

func (s *ClassOrInterfaceModifiersOptContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserNL)
}

func (s *ClassOrInterfaceModifiersOptContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserNL, i)
}

func (s *ClassOrInterfaceModifiersOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifiersOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifiersOptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClassOrInterfaceModifiersOpt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceModifiersOpt() (localctx IClassOrInterfaceModifiersOptContext) {
	localctx = NewClassOrInterfaceModifiersOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, GroovyParserRULE_classOrInterfaceModifiersOpt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(403)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(396)
			p.ClassOrInterfaceModifiers()
		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == GroovyParserNL {
			{
				p.SetState(397)
				p.Match(GroovyParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(402)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOrInterfaceModifiersContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext
	ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsClassOrInterfaceModifiersContext differentiates from other interfaces.
	IsClassOrInterfaceModifiersContext()
}

type ClassOrInterfaceModifiersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceModifiersContext() *ClassOrInterfaceModifiersContext {
	var p = new(ClassOrInterfaceModifiersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiers
	return p
}

func InitEmptyClassOrInterfaceModifiersContext(p *ClassOrInterfaceModifiersContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiers
}

func (*ClassOrInterfaceModifiersContext) IsClassOrInterfaceModifiersContext() {}

func NewClassOrInterfaceModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifiersContext {
	var p = new(ClassOrInterfaceModifiersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiers

	return p
}

func (s *ClassOrInterfaceModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifiersContext) AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassOrInterfaceModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			tst[i] = t.(IClassOrInterfaceModifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceModifiersContext) ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *ClassOrInterfaceModifiersContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceModifiersContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassOrInterfaceModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClassOrInterfaceModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceModifiers() (localctx IClassOrInterfaceModifiersContext) {
	localctx = NewClassOrInterfaceModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, GroovyParserRULE_classOrInterfaceModifiers)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.ClassOrInterfaceModifier()
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(406)
				p.Nls()
			}
			{
				p.SetState(407)
				p.ClassOrInterfaceModifier()
			}

		}
		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOrInterfaceModifierContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m token.
	GetM() antlr.Token

	// SetM sets the m token.
	SetM(antlr.Token)

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	NON_SEALED() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	STRICTFP() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsClassOrInterfaceModifierContext differentiates from other interfaces.
	IsClassOrInterfaceModifierContext()
}

type ClassOrInterfaceModifierContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	m      antlr.Token
}

func NewEmptyClassOrInterfaceModifierContext() *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifier
	return p
}

func InitEmptyClassOrInterfaceModifierContext(p *ClassOrInterfaceModifierContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifier
}

func (*ClassOrInterfaceModifierContext) IsClassOrInterfaceModifierContext() {}

func NewClassOrInterfaceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifier

	return p
}

func (s *ClassOrInterfaceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifierContext) GetM() antlr.Token { return s.m }

func (s *ClassOrInterfaceModifierContext) SetM(v antlr.Token) { s.m = v }

func (s *ClassOrInterfaceModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassOrInterfaceModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserPUBLIC, 0)
}

func (s *ClassOrInterfaceModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(GroovyParserPROTECTED, 0)
}

func (s *ClassOrInterfaceModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPRIVATE, 0)
}

func (s *ClassOrInterfaceModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *ClassOrInterfaceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(GroovyParserABSTRACT, 0)
}

func (s *ClassOrInterfaceModifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSEALED, 0)
}

func (s *ClassOrInterfaceModifierContext) NON_SEALED() antlr.TerminalNode {
	return s.GetToken(GroovyParserNON_SEALED, 0)
}

func (s *ClassOrInterfaceModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINAL, 0)
}

func (s *ClassOrInterfaceModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTRICTFP, 0)
}

func (s *ClassOrInterfaceModifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *ClassOrInterfaceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClassOrInterfaceModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceModifier() (localctx IClassOrInterfaceModifierContext) {
	localctx = NewClassOrInterfaceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, GroovyParserRULE_classOrInterfaceModifier)
	var _la int

	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(414)
			p.Annotation()
		}

	case GroovyParserABSTRACT, GroovyParserDEFAULT, GroovyParserFINAL, GroovyParserNON_SEALED, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserSEALED, GroovyParserSTATIC, GroovyParserSTRICTFP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(415)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ClassOrInterfaceModifierContext).m = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1016498776719360) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ClassOrInterfaceModifierContext).m = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableModifierContext is an interface to support dynamic dispatch.
type IVariableModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m token.
	GetM() antlr.Token

	// SetM sets the m token.
	SetM(antlr.Token)

	// Getter signatures
	Annotation() IAnnotationContext
	FINAL() antlr.TerminalNode
	DEF() antlr.TerminalNode
	VAR() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	STRICTFP() antlr.TerminalNode

	// IsVariableModifierContext differentiates from other interfaces.
	IsVariableModifierContext()
}

type VariableModifierContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	m      antlr.Token
}

func NewEmptyVariableModifierContext() *VariableModifierContext {
	var p = new(VariableModifierContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableModifier
	return p
}

func InitEmptyVariableModifierContext(p *VariableModifierContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableModifier
}

func (*VariableModifierContext) IsVariableModifierContext() {}

func NewVariableModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifierContext {
	var p = new(VariableModifierContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableModifier

	return p
}

func (s *VariableModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifierContext) GetM() antlr.Token { return s.m }

func (s *VariableModifierContext) SetM(v antlr.Token) { s.m = v }

func (s *VariableModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINAL, 0)
}

func (s *VariableModifierContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *VariableModifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *VariableModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserPUBLIC, 0)
}

func (s *VariableModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(GroovyParserPROTECTED, 0)
}

func (s *VariableModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPRIVATE, 0)
}

func (s *VariableModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *VariableModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(GroovyParserABSTRACT, 0)
}

func (s *VariableModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTRICTFP, 0)
}

func (s *VariableModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitVariableModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) VariableModifier() (localctx IVariableModifierContext) {
	localctx = NewVariableModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, GroovyParserRULE_variableModifier)
	var _la int

	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(418)
			p.Annotation()
		}

	case GroovyParserDEF, GroovyParserVAR, GroovyParserABSTRACT, GroovyParserFINAL, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserSTATIC, GroovyParserSTRICTFP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(419)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*VariableModifierContext).m = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&875211524165888) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*VariableModifierContext).m = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableModifiersOptContext is an interface to support dynamic dispatch.
type IVariableModifiersOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableModifiers() IVariableModifiersContext
	Nls() INlsContext

	// IsVariableModifiersOptContext differentiates from other interfaces.
	IsVariableModifiersOptContext()
}

type VariableModifiersOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifiersOptContext() *VariableModifiersOptContext {
	var p = new(VariableModifiersOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableModifiersOpt
	return p
}

func InitEmptyVariableModifiersOptContext(p *VariableModifiersOptContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableModifiersOpt
}

func (*VariableModifiersOptContext) IsVariableModifiersOptContext() {}

func NewVariableModifiersOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifiersOptContext {
	var p = new(VariableModifiersOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableModifiersOpt

	return p
}

func (s *VariableModifiersOptContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifiersOptContext) VariableModifiers() IVariableModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersContext)
}

func (s *VariableModifiersOptContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableModifiersOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifiersOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifiersOptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitVariableModifiersOpt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) VariableModifiersOpt() (localctx IVariableModifiersOptContext) {
	localctx = NewVariableModifiersOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, GroovyParserRULE_variableModifiersOpt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(425)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(422)
			p.VariableModifiers()
		}
		{
			p.SetState(423)
			p.Nls()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableModifiersContext is an interface to support dynamic dispatch.
type IVariableModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsVariableModifiersContext differentiates from other interfaces.
	IsVariableModifiersContext()
}

type VariableModifiersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifiersContext() *VariableModifiersContext {
	var p = new(VariableModifiersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableModifiers
	return p
}

func InitEmptyVariableModifiersContext(p *VariableModifiersContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableModifiers
}

func (*VariableModifiersContext) IsVariableModifiersContext() {}

func NewVariableModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifiersContext {
	var p = new(VariableModifiersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableModifiers

	return p
}

func (s *VariableModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifiersContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *VariableModifiersContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *VariableModifiersContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *VariableModifiersContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitVariableModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) VariableModifiers() (localctx IVariableModifiersContext) {
	localctx = NewVariableModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, GroovyParserRULE_variableModifiers)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(427)
		p.VariableModifier()
	}
	p.SetState(433)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(428)
				p.Nls()
			}
			{
				p.SetState(429)
				p.VariableModifier()
			}

		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext
	AllTypeParameter() []ITypeParameterContext
	TypeParameter(i int) ITypeParameterContext
	GT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeParameters
	return p
}

func InitEmptyTypeParametersContext(p *TypeParametersContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeParameters
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *TypeParametersContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *TypeParametersContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeParametersContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParametersContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTypeParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, GroovyParserRULE_typeParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(436)
		p.Match(GroovyParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(437)
		p.Nls()
	}
	{
		p.SetState(438)
		p.TypeParameter()
	}
	p.SetState(445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(439)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(440)
			p.Nls()
		}
		{
			p.SetState(441)
			p.TypeParameter()
		}

		p.SetState(447)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(448)
		p.Nls()
	}
	{
		p.SetState(449)
		p.Match(GroovyParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationsOpt() IAnnotationsOptContext
	ClassName() IClassNameContext
	EXTENDS() antlr.TerminalNode
	Nls() INlsContext
	TypeBound() ITypeBoundContext

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *TypeParameterContext) ClassName() IClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *TypeParameterContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *TypeParameterContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeParameterContext) TypeBound() ITypeBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeBoundContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, GroovyParserRULE_typeParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.AnnotationsOpt()
	}
	{
		p.SetState(452)
		p.ClassName()
	}
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserEXTENDS {
		{
			p.SetState(453)
			p.Match(GroovyParserEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(454)
			p.Nls()
		}
		{
			p.SetState(455)
			p.TypeBound()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeBoundContext is an interface to support dynamic dispatch.
type ITypeBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllBITAND() []antlr.TerminalNode
	BITAND(i int) antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsTypeBoundContext differentiates from other interfaces.
	IsTypeBoundContext()
}

type TypeBoundContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeBoundContext() *TypeBoundContext {
	var p = new(TypeBoundContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeBound
	return p
}

func InitEmptyTypeBoundContext(p *TypeBoundContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeBound
}

func (*TypeBoundContext) IsTypeBoundContext() {}

func NewTypeBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeBoundContext {
	var p = new(TypeBoundContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeBound

	return p
}

func (s *TypeBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeBoundContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeBoundContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeBoundContext) AllBITAND() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserBITAND)
}

func (s *TypeBoundContext) BITAND(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserBITAND, i)
}

func (s *TypeBoundContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *TypeBoundContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTypeBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TypeBound() (localctx ITypeBoundContext) {
	localctx = NewTypeBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, GroovyParserRULE_typeBound)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(459)
		p.Type_()
	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserBITAND {
		{
			p.SetState(460)
			p.Match(GroovyParserBITAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(461)
			p.Nls()
		}
		{
			p.SetState(462)
			p.Type_()
		}

		p.SetState(468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeListContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, GroovyParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Type_()
	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(470)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(471)
			p.Nls()
		}
		{
			p.SetState(472)
			p.Type_()
		}

		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetScs returns the scs rule contexts.
	GetScs() ITypeListContext

	// GetIs returns the is rule contexts.
	GetIs() ITypeListContext

	// GetPs returns the ps rule contexts.
	GetPs() ITypeListContext

	// SetScs sets the scs rule contexts.
	SetScs(ITypeListContext)

	// SetIs sets the is rule contexts.
	SetIs(ITypeListContext)

	// SetPs sets the ps rule contexts.
	SetPs(ITypeListContext)

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// Getter signatures
	Identifier() IIdentifierContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	ClassBody() IClassBodyContext
	CLASS() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	AT() antlr.TerminalNode
	TRAIT() antlr.TerminalNode
	RECORD() antlr.TerminalNode
	TypeParameters() ITypeParametersContext
	FormalParameters() IFormalParametersContext
	EXTENDS() antlr.TerminalNode
	IMPLEMENTS() antlr.TerminalNode
	PERMITS() antlr.TerminalNode
	AllTypeList() []ITypeListContext
	TypeList(i int) ITypeListContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
	scs    ITypeListContext
	is     ITypeListContext
	ps     ITypeListContext
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) GetScs() ITypeListContext { return s.scs }

func (s *ClassDeclarationContext) GetIs() ITypeListContext { return s.is }

func (s *ClassDeclarationContext) GetPs() ITypeListContext { return s.ps }

func (s *ClassDeclarationContext) SetScs(v ITypeListContext) { s.scs = v }

func (s *ClassDeclarationContext) SetIs(v ITypeListContext) { s.is = v }

func (s *ClassDeclarationContext) SetPs(v ITypeListContext) { s.ps = v }

func (s *ClassDeclarationContext) GetT() int { return s.t }

func (s *ClassDeclarationContext) SetT(v int) { s.t = v }

func (s *ClassDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(GroovyParserCLASS, 0)
}

func (s *ClassDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserINTERFACE, 0)
}

func (s *ClassDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(GroovyParserENUM, 0)
}

func (s *ClassDeclarationContext) AT() antlr.TerminalNode {
	return s.GetToken(GroovyParserAT, 0)
}

func (s *ClassDeclarationContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *ClassDeclarationContext) RECORD() antlr.TerminalNode {
	return s.GetToken(GroovyParserRECORD, 0)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *ClassDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *ClassDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPLEMENTS, 0)
}

func (s *ClassDeclarationContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(GroovyParserPERMITS, 0)
}

func (s *ClassDeclarationContext) AllTypeList() []ITypeListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeListContext); ok {
			len++
		}
	}

	tst := make([]ITypeListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeListContext); ok {
			tst[i] = t.(ITypeListContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) TypeList(i int) ITypeListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, GroovyParserRULE_classDeclaration)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserCLASS:
		{
			p.SetState(479)
			p.Match(GroovyParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ClassDeclarationContext).SetT(0)

	case GroovyParserINTERFACE:
		{
			p.SetState(481)
			p.Match(GroovyParserINTERFACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ClassDeclarationContext).SetT(1)

	case GroovyParserENUM:
		{
			p.SetState(483)
			p.Match(GroovyParserENUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ClassDeclarationContext).SetT(2)

	case GroovyParserAT:
		{
			p.SetState(485)
			p.Match(GroovyParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(486)
			p.Match(GroovyParserINTERFACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ClassDeclarationContext).SetT(3)

	case GroovyParserTRAIT:
		{
			p.SetState(488)
			p.Match(GroovyParserTRAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ClassDeclarationContext).SetT(4)

	case GroovyParserRECORD:
		{
			p.SetState(490)
			p.Match(GroovyParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ClassDeclarationContext).SetT(5)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(494)
		p.Identifier()
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(495)
			p.Nls()
		}
		{
			p.SetState(496)
			p.TypeParameters()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(500)
			p.Nls()
		}
		{
			p.SetState(501)
			p.FormalParameters()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(505)
			p.Nls()
		}
		{
			p.SetState(506)
			p.Match(GroovyParserEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(507)
			p.Nls()
		}
		{
			p.SetState(508)

			var _x = p.TypeList()

			localctx.(*ClassDeclarationContext).scs = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(512)
			p.Nls()
		}
		{
			p.SetState(513)
			p.Match(GroovyParserIMPLEMENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(514)
			p.Nls()
		}
		{
			p.SetState(515)

			var _x = p.TypeList()

			localctx.(*ClassDeclarationContext).is = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(519)
			p.Nls()
		}
		{
			p.SetState(520)
			p.Match(GroovyParserPERMITS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(521)
			p.Nls()
		}
		{
			p.SetState(522)

			var _x = p.TypeList()

			localctx.(*ClassDeclarationContext).ps = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(526)
		p.Nls()
	}
	{
		p.SetState(527)
		p.ClassBody(localctx.(*ClassDeclarationContext).t)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext
	RBRACE() antlr.TerminalNode
	EnumConstants() IEnumConstantsContext
	AllClassBodyDeclaration() []IClassBodyDeclarationContext
	ClassBodyDeclaration(i int) IClassBodyDeclarationContext
	AllSep() []ISepContext
	Sep(i int) ISepContext
	COMMA() antlr.TerminalNode

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classBody
	return p
}

func InitEmptyClassBodyContext(p *ClassBodyContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classBody
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classBody

	p.t = t

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) GetT() int { return s.t }

func (s *ClassBodyContext) SetT(v int) { s.t = v }

func (s *ClassBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *ClassBodyContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *ClassBodyContext) EnumConstants() IEnumConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantsContext)
}

func (s *ClassBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassBodyContext) AllSep() []ISepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISepContext); ok {
			len++
		}
	}

	tst := make([]ISepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISepContext); ok {
			tst[i] = t.(ISepContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) Sep(i int) ISepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ClassBodyContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClassBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ClassBody(t int) (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 40, GroovyParserRULE_classBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.Match(GroovyParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(530)
		p.Nls()
	}
	p.SetState(542)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.SetState(531)

		if !(2 == localctx.(*ClassBodyContext).t) {
			p.SetError(antlr.NewFailedPredicateException(p, " 2 == $t ", ""))
			goto errorExit
		}
		{
			p.SetState(532)
			p.EnumConstants()
		}
		p.SetState(536)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(533)
				p.Nls()
			}
			{
				p.SetState(534)
				p.Match(GroovyParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(539)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(538)
				p.Sep()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&942306410519230338) != 0) || ((int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&30786325578241) != 0) {
		{
			p.SetState(544)
			p.ClassBodyDeclaration(localctx.(*ClassBodyContext).t)
		}
		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(545)
					p.Sep()
				}
				{
					p.SetState(546)
					p.ClassBodyDeclaration(localctx.(*ClassBodyContext).t)
				}

			}
			p.SetState(552)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserSEMI || _la == GroovyParserNL {
		{
			p.SetState(555)
			p.Sep()
		}

	}
	{
		p.SetState(558)
		p.Match(GroovyParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstantsContext is an interface to support dynamic dispatch.
type IEnumConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumConstant() []IEnumConstantContext
	EnumConstant(i int) IEnumConstantContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumConstantsContext differentiates from other interfaces.
	IsEnumConstantsContext()
}

type EnumConstantsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantsContext() *EnumConstantsContext {
	var p = new(EnumConstantsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enumConstants
	return p
}

func InitEmptyEnumConstantsContext(p *EnumConstantsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enumConstants
}

func (*EnumConstantsContext) IsEnumConstantsContext() {}

func NewEnumConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantsContext {
	var p = new(EnumConstantsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enumConstants

	return p
}

func (s *EnumConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantsContext) AllEnumConstant() []IEnumConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumConstantContext); ok {
			len++
		}
	}

	tst := make([]IEnumConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumConstantContext); ok {
			tst[i] = t.(IEnumConstantContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantsContext) EnumConstant(i int) IEnumConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantContext)
}

func (s *EnumConstantsContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantsContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *EnumConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *EnumConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *EnumConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitEnumConstants(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) EnumConstants() (localctx IEnumConstantsContext) {
	localctx = NewEnumConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, GroovyParserRULE_enumConstants)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		p.EnumConstant()
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(561)
				p.Nls()
			}
			{
				p.SetState(562)
				p.Match(GroovyParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(563)
				p.Nls()
			}
			{
				p.SetState(564)
				p.EnumConstant()
			}

		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstantContext is an interface to support dynamic dispatch.
type IEnumConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationsOpt() IAnnotationsOptContext
	Identifier() IIdentifierContext
	Arguments() IArgumentsContext
	AnonymousInnerClassDeclaration() IAnonymousInnerClassDeclarationContext

	// IsEnumConstantContext differentiates from other interfaces.
	IsEnumConstantContext()
}

type EnumConstantContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantContext() *EnumConstantContext {
	var p = new(EnumConstantContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enumConstant
	return p
}

func InitEmptyEnumConstantContext(p *EnumConstantContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enumConstant
}

func (*EnumConstantContext) IsEnumConstantContext() {}

func NewEnumConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantContext {
	var p = new(EnumConstantContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enumConstant

	return p
}

func (s *EnumConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *EnumConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumConstantContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *EnumConstantContext) AnonymousInnerClassDeclaration() IAnonymousInnerClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousInnerClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousInnerClassDeclarationContext)
}

func (s *EnumConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitEnumConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) EnumConstant() (localctx IEnumConstantContext) {
	localctx = NewEnumConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, GroovyParserRULE_enumConstant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(571)
		p.AnnotationsOpt()
	}
	{
		p.SetState(572)
		p.Identifier()
	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserLPAREN {
		{
			p.SetState(573)
			p.Arguments()
		}

	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(576)
			p.AnonymousInnerClassDeclaration(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// Getter signatures
	Block() IBlockContext
	STATIC() antlr.TerminalNode
	Nls() INlsContext
	MemberDeclaration() IMemberDeclarationContext

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classBodyDeclaration
	return p
}

func InitEmptyClassBodyDeclarationContext(p *ClassBodyDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classBodyDeclaration
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classBodyDeclaration

	p.t = t

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) GetT() int { return s.t }

func (s *ClassBodyDeclarationContext) SetT(v int) { s.t = v }

func (s *ClassBodyDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassBodyDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *ClassBodyDeclarationContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassBodyDeclarationContext) MemberDeclaration() IMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberDeclarationContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClassBodyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ClassBodyDeclaration(t int) (localctx IClassBodyDeclarationContext) {
	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 46, GroovyParserRULE_classBodyDeclaration)
	var _la int

	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(581)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserSTATIC {
			{
				p.SetState(579)
				p.Match(GroovyParserSTATIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(580)
				p.Nls()
			}

		}
		{
			p.SetState(583)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(584)
			p.MemberDeclaration(localctx.(*ClassBodyDeclarationContext).t)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberDeclarationContext is an interface to support dynamic dispatch.
type IMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// Getter signatures
	MethodDeclaration() IMethodDeclarationContext
	FieldDeclaration() IFieldDeclarationContext
	ModifiersOpt() IModifiersOptContext
	ClassDeclaration() IClassDeclarationContext
	CompactConstructorDeclaration() ICompactConstructorDeclarationContext

	// IsMemberDeclarationContext differentiates from other interfaces.
	IsMemberDeclarationContext()
}

type MemberDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyMemberDeclarationContext() *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_memberDeclaration
	return p
}

func InitEmptyMemberDeclarationContext(p *MemberDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_memberDeclaration
}

func (*MemberDeclarationContext) IsMemberDeclarationContext() {}

func NewMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_memberDeclaration

	p.t = t

	return p
}

func (s *MemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDeclarationContext) GetT() int { return s.t }

func (s *MemberDeclarationContext) SetT(v int) { s.t = v }

func (s *MemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *MemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *MemberDeclarationContext) ModifiersOpt() IModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersOptContext)
}

func (s *MemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *MemberDeclarationContext) CompactConstructorDeclaration() ICompactConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactConstructorDeclarationContext)
}

func (s *MemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMemberDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) MemberDeclaration(t int) (localctx IMemberDeclarationContext) {
	localctx = NewMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 48, GroovyParserRULE_memberDeclaration)
	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(587)
			p.MethodDeclaration(0, localctx.(*MemberDeclarationContext).t)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(588)
			p.FieldDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(589)
			p.ModifiersOpt()
		}
		p.SetState(592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(590)
				p.ClassDeclaration()
			}

		case 2:
			{
				p.SetState(591)
				p.CompactConstructorDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// GetCt returns the ct attribute.
	GetCt() int

	// SetT sets the t attribute.
	SetT(int)

	// SetCt sets the ct attribute.
	SetCt(int)

	// Getter signatures
	ModifiersOpt() IModifiersOptContext
	MethodName() IMethodNameContext
	FormalParameters() IFormalParametersContext
	TypeParameters() ITypeParametersContext
	ReturnType() IReturnTypeContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	DEFAULT() antlr.TerminalNode
	ElementValue() IElementValueContext
	MethodBody() IMethodBodyContext
	THROWS() antlr.TerminalNode
	QualifiedClassNameList() IQualifiedClassNameListContext

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
	ct     int
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_methodDeclaration
	return p
}

func InitEmptyMethodDeclarationContext(p *MethodDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_methodDeclaration
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int, ct int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_methodDeclaration

	p.t = t
	p.ct = ct

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) GetT() int { return s.t }

func (s *MethodDeclarationContext) GetCt() int { return s.ct }

func (s *MethodDeclarationContext) SetT(v int) { s.t = v }

func (s *MethodDeclarationContext) SetCt(v int) { s.ct = v }

func (s *MethodDeclarationContext) ModifiersOpt() IModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersOptContext)
}

func (s *MethodDeclarationContext) MethodName() IMethodNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *MethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *MethodDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *MethodDeclarationContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *MethodDeclarationContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *MethodDeclarationContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MethodDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *MethodDeclarationContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *MethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *MethodDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROWS, 0)
}

func (s *MethodDeclarationContext) QualifiedClassNameList() IQualifiedClassNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameListContext)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMethodDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) MethodDeclaration(t int, ct int) (localctx IMethodDeclarationContext) {
	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t, ct)
	p.EnterRule(localctx, 50, GroovyParserRULE_methodDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.ModifiersOpt()
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserLT {
		{
			p.SetState(597)
			p.TypeParameters()
		}

	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(600)
			p.ReturnType(localctx.(*MethodDeclarationContext).ct)
		}
		{
			p.SetState(601)
			p.Nls()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(605)
		p.MethodName()
	}
	{
		p.SetState(606)
		p.FormalParameters()
	}
	p.SetState(621)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(607)
			p.Match(GroovyParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(608)
			p.Nls()
		}
		{
			p.SetState(609)
			p.ElementValue()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 2 {
		p.SetState(616)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(611)
				p.Nls()
			}
			{
				p.SetState(612)
				p.Match(GroovyParserTHROWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(613)
				p.Nls()
			}
			{
				p.SetState(614)
				p.QualifiedClassNameList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

		{
			p.SetState(618)
			p.Nls()
		}
		{
			p.SetState(619)
			p.MethodBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompactConstructorDeclarationContext is an interface to support dynamic dispatch.
type ICompactConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodName() IMethodNameContext
	Nls() INlsContext
	MethodBody() IMethodBodyContext

	// IsCompactConstructorDeclarationContext differentiates from other interfaces.
	IsCompactConstructorDeclarationContext()
}

type CompactConstructorDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompactConstructorDeclarationContext() *CompactConstructorDeclarationContext {
	var p = new(CompactConstructorDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_compactConstructorDeclaration
	return p
}

func InitEmptyCompactConstructorDeclarationContext(p *CompactConstructorDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_compactConstructorDeclaration
}

func (*CompactConstructorDeclarationContext) IsCompactConstructorDeclarationContext() {}

func NewCompactConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactConstructorDeclarationContext {
	var p = new(CompactConstructorDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_compactConstructorDeclaration

	return p
}

func (s *CompactConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactConstructorDeclarationContext) MethodName() IMethodNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *CompactConstructorDeclarationContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *CompactConstructorDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *CompactConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompactConstructorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCompactConstructorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) CompactConstructorDeclaration() (localctx ICompactConstructorDeclarationContext) {
	localctx = NewCompactConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, GroovyParserRULE_compactConstructorDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.MethodName()
	}
	{
		p.SetState(624)
		p.Nls()
	}
	{
		p.SetState(625)
		p.MethodBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodNameContext is an interface to support dynamic dispatch.
type IMethodNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	StringLiteral() IStringLiteralContext

	// IsMethodNameContext differentiates from other interfaces.
	IsMethodNameContext()
}

type MethodNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodNameContext() *MethodNameContext {
	var p = new(MethodNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_methodName
	return p
}

func InitEmptyMethodNameContext(p *MethodNameContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_methodName
}

func (*MethodNameContext) IsMethodNameContext() {}

func NewMethodNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodNameContext {
	var p = new(MethodNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_methodName

	return p
}

func (s *MethodNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodNameContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *MethodNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMethodName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) MethodName() (localctx IMethodNameContext) {
	localctx = NewMethodNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, GroovyParserRULE_methodName)
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAS, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserYIELD, GroovyParserPERMITS, GroovyParserRECORD, GroovyParserSEALED, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(627)
			p.Identifier()
		}

	case GroovyParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(628)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnTypeContext is an interface to support dynamic dispatch.
type IReturnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCt returns the ct attribute.
	GetCt() int

	// SetCt sets the ct attribute.
	SetCt(int)

	// Getter signatures
	StandardType() IStandardTypeContext
	VOID() antlr.TerminalNode

	// IsReturnTypeContext differentiates from other interfaces.
	IsReturnTypeContext()
}

type ReturnTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	ct     int
}

func NewEmptyReturnTypeContext() *ReturnTypeContext {
	var p = new(ReturnTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_returnType
	return p
}

func InitEmptyReturnTypeContext(p *ReturnTypeContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_returnType
}

func (*ReturnTypeContext) IsReturnTypeContext() {}

func NewReturnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, ct int) *ReturnTypeContext {
	var p = new(ReturnTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_returnType

	p.ct = ct

	return p
}

func (s *ReturnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeContext) GetCt() int { return s.ct }

func (s *ReturnTypeContext) SetCt(v int) { s.ct = v }

func (s *ReturnTypeContext) StandardType() IStandardTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardTypeContext)
}

func (s *ReturnTypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *ReturnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitReturnType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ReturnType(ct int) (localctx IReturnTypeContext) {
	localctx = NewReturnTypeContext(p, p.GetParserRuleContext(), p.GetState(), ct)
	p.EnterRule(localctx, 56, GroovyParserRULE_returnType)
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserYIELD, GroovyParserPERMITS, GroovyParserRECORD, GroovyParserSEALED, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier, GroovyParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(631)
			p.StandardType()
		}

	case GroovyParserVOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.Match(GroovyParserVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaration() IVariableDeclarationContext

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_fieldDeclaration
	return p
}

func InitEmptyFieldDeclarationContext(p *FieldDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_fieldDeclaration
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitFieldDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, GroovyParserRULE_fieldDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.VariableDeclaration(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorsContext is an interface to support dynamic dispatch.
type IVariableDeclaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDeclarator() []IVariableDeclaratorContext
	VariableDeclarator(i int) IVariableDeclaratorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsVariableDeclaratorsContext differentiates from other interfaces.
	IsVariableDeclaratorsContext()
}

type VariableDeclaratorsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorsContext() *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableDeclarators
	return p
}

func InitEmptyVariableDeclaratorsContext(p *VariableDeclaratorsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableDeclarators
}

func (*VariableDeclaratorsContext) IsVariableDeclaratorsContext() {}

func NewVariableDeclaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclarators

	return p
}

func (s *VariableDeclaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorsContext) AllVariableDeclarator() []IVariableDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclaratorContext); ok {
			tst[i] = t.(IVariableDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) VariableDeclarator(i int) IVariableDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorContext)
}

func (s *VariableDeclaratorsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *VariableDeclaratorsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *VariableDeclaratorsContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableDeclaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitVariableDeclarators(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) VariableDeclarators() (localctx IVariableDeclaratorsContext) {
	localctx = NewVariableDeclaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, GroovyParserRULE_variableDeclarators)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.VariableDeclarator()
	}
	p.SetState(644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(638)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(639)
			p.Nls()
		}
		{
			p.SetState(640)
			p.VariableDeclarator()
		}

		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorContext is an interface to support dynamic dispatch.
type IVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaratorId() IVariableDeclaratorIdContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	ASSIGN() antlr.TerminalNode
	VariableInitializer() IVariableInitializerContext

	// IsVariableDeclaratorContext differentiates from other interfaces.
	IsVariableDeclaratorContext()
}

type VariableDeclaratorContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorContext() *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableDeclarator
	return p
}

func InitEmptyVariableDeclaratorContext(p *VariableDeclaratorContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableDeclarator
}

func (*VariableDeclaratorContext) IsVariableDeclaratorContext() {}

func NewVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclarator

	return p
}

func (s *VariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableDeclaratorContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *VariableDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitVariableDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) VariableDeclarator() (localctx IVariableDeclaratorContext) {
	localctx = NewVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, GroovyParserRULE_variableDeclarator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.VariableDeclaratorId()
	}
	p.SetState(653)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(648)
			p.Nls()
		}
		{
			p.SetState(649)
			p.Match(GroovyParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(650)
			p.Nls()
		}
		{
			p.SetState(651)
			p.VariableInitializer()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorIdContext is an interface to support dynamic dispatch.
type IVariableDeclaratorIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsVariableDeclaratorIdContext differentiates from other interfaces.
	IsVariableDeclaratorIdContext()
}

type VariableDeclaratorIdContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorIdContext() *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableDeclaratorId
	return p
}

func InitEmptyVariableDeclaratorIdContext(p *VariableDeclaratorIdContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableDeclaratorId
}

func (*VariableDeclaratorIdContext) IsVariableDeclaratorIdContext() {}

func NewVariableDeclaratorIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclaratorId

	return p
}

func (s *VariableDeclaratorIdContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorIdContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclaratorIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitVariableDeclaratorId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) VariableDeclaratorId() (localctx IVariableDeclaratorIdContext) {
	localctx = NewVariableDeclaratorIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, GroovyParserRULE_variableDeclaratorId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnhancedStatementExpression() IEnhancedStatementExpressionContext

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableInitializer
	return p
}

func InitEmptyVariableInitializerContext(p *VariableInitializerContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableInitializer
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) EnhancedStatementExpression() IEnhancedStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedStatementExpressionContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitVariableInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) VariableInitializer() (localctx IVariableInitializerContext) {
	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, GroovyParserRULE_variableInitializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.EnhancedStatementExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableInitializersContext is an interface to support dynamic dispatch.
type IVariableInitializersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableInitializer() []IVariableInitializerContext
	VariableInitializer(i int) IVariableInitializerContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariableInitializersContext differentiates from other interfaces.
	IsVariableInitializersContext()
}

type VariableInitializersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializersContext() *VariableInitializersContext {
	var p = new(VariableInitializersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableInitializers
	return p
}

func InitEmptyVariableInitializersContext(p *VariableInitializersContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableInitializers
}

func (*VariableInitializersContext) IsVariableInitializersContext() {}

func NewVariableInitializersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializersContext {
	var p = new(VariableInitializersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableInitializers

	return p
}

func (s *VariableInitializersContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializersContext) AllVariableInitializer() []IVariableInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			len++
		}
	}

	tst := make([]IVariableInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableInitializerContext); ok {
			tst[i] = t.(IVariableInitializerContext)
			i++
		}
	}

	return tst
}

func (s *VariableInitializersContext) VariableInitializer(i int) IVariableInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableInitializersContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *VariableInitializersContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableInitializersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *VariableInitializersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *VariableInitializersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitVariableInitializers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) VariableInitializers() (localctx IVariableInitializersContext) {
	localctx = NewVariableInitializersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, GroovyParserRULE_variableInitializers)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.VariableInitializer()
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(660)
				p.Nls()
			}
			{
				p.SetState(661)
				p.Match(GroovyParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(662)
				p.Nls()
			}
			{
				p.SetState(663)
				p.VariableInitializer()
			}

		}
		p.SetState(669)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(670)
		p.Nls()
	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserCOMMA {
		{
			p.SetState(671)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyDimsContext is an interface to support dynamic dispatch.
type IEmptyDimsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnnotationsOpt() []IAnnotationsOptContext
	AnnotationsOpt(i int) IAnnotationsOptContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode

	// IsEmptyDimsContext differentiates from other interfaces.
	IsEmptyDimsContext()
}

type EmptyDimsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyDimsContext() *EmptyDimsContext {
	var p = new(EmptyDimsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_emptyDims
	return p
}

func InitEmptyEmptyDimsContext(p *EmptyDimsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_emptyDims
}

func (*EmptyDimsContext) IsEmptyDimsContext() {}

func NewEmptyDimsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyDimsContext {
	var p = new(EmptyDimsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_emptyDims

	return p
}

func (s *EmptyDimsContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyDimsContext) AllAnnotationsOpt() []IAnnotationsOptContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationsOptContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationsOptContext); ok {
			tst[i] = t.(IAnnotationsOptContext)
			i++
		}
	}

	return tst
}

func (s *EmptyDimsContext) AnnotationsOpt(i int) IAnnotationsOptContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *EmptyDimsContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserLBRACK)
}

func (s *EmptyDimsContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, i)
}

func (s *EmptyDimsContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserRBRACK)
}

func (s *EmptyDimsContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, i)
}

func (s *EmptyDimsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyDimsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyDimsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitEmptyDims(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) EmptyDims() (localctx IEmptyDimsContext) {
	localctx = NewEmptyDimsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, GroovyParserRULE_emptyDims)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(674)
				p.AnnotationsOpt()
			}
			{
				p.SetState(675)
				p.Match(GroovyParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(676)
				p.Match(GroovyParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyDimsOptContext is an interface to support dynamic dispatch.
type IEmptyDimsOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EmptyDims() IEmptyDimsContext

	// IsEmptyDimsOptContext differentiates from other interfaces.
	IsEmptyDimsOptContext()
}

type EmptyDimsOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyDimsOptContext() *EmptyDimsOptContext {
	var p = new(EmptyDimsOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_emptyDimsOpt
	return p
}

func InitEmptyEmptyDimsOptContext(p *EmptyDimsOptContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_emptyDimsOpt
}

func (*EmptyDimsOptContext) IsEmptyDimsOptContext() {}

func NewEmptyDimsOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyDimsOptContext {
	var p = new(EmptyDimsOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_emptyDimsOpt

	return p
}

func (s *EmptyDimsOptContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyDimsOptContext) EmptyDims() IEmptyDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyDimsContext)
}

func (s *EmptyDimsOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyDimsOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyDimsOptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitEmptyDimsOpt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) EmptyDimsOpt() (localctx IEmptyDimsOptContext) {
	localctx = NewEmptyDimsOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, GroovyParserRULE_emptyDimsOpt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(683)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(682)
			p.EmptyDims()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandardTypeContext is an interface to support dynamic dispatch.
type IStandardTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationsOpt() IAnnotationsOptContext
	EmptyDimsOpt() IEmptyDimsOptContext
	PrimitiveType() IPrimitiveTypeContext
	StandardClassOrInterfaceType() IStandardClassOrInterfaceTypeContext

	// IsStandardTypeContext differentiates from other interfaces.
	IsStandardTypeContext()
}

type StandardTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardTypeContext() *StandardTypeContext {
	var p = new(StandardTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_standardType
	return p
}

func InitEmptyStandardTypeContext(p *StandardTypeContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_standardType
}

func (*StandardTypeContext) IsStandardTypeContext() {}

func NewStandardTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardTypeContext {
	var p = new(StandardTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardType

	return p
}

func (s *StandardTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardTypeContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *StandardTypeContext) EmptyDimsOpt() IEmptyDimsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyDimsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyDimsOptContext)
}

func (s *StandardTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *StandardTypeContext) StandardClassOrInterfaceType() IStandardClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardClassOrInterfaceTypeContext)
}

func (s *StandardTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitStandardType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) StandardType() (localctx IStandardTypeContext) {
	localctx = NewStandardTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, GroovyParserRULE_standardType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.AnnotationsOpt()
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserBuiltInPrimitiveType:
		{
			p.SetState(686)
			p.PrimitiveType()
		}

	case GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserYIELD, GroovyParserPERMITS, GroovyParserRECORD, GroovyParserSEALED, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		{
			p.SetState(687)
			p.StandardClassOrInterfaceType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(690)
		p.EmptyDimsOpt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationsOpt() IAnnotationsOptContext
	EmptyDimsOpt() IEmptyDimsOptContext
	GeneralClassOrInterfaceType() IGeneralClassOrInterfaceTypeContext
	PrimitiveType() IPrimitiveTypeContext
	VOID() antlr.TerminalNode

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *TypeContext) EmptyDimsOpt() IEmptyDimsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyDimsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyDimsOptContext)
}

func (s *TypeContext) GeneralClassOrInterfaceType() IGeneralClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralClassOrInterfaceTypeContext)
}

func (s *TypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, GroovyParserRULE_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(692)
		p.AnnotationsOpt()
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserBuiltInPrimitiveType, GroovyParserVOID:
		p.SetState(695)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case GroovyParserBuiltInPrimitiveType:
			{
				p.SetState(693)
				p.PrimitiveType()
			}

		case GroovyParserVOID:
			{
				p.SetState(694)
				p.Match(GroovyParserVOID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserYIELD, GroovyParserPERMITS, GroovyParserRECORD, GroovyParserSEALED, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		{
			p.SetState(697)
			p.GeneralClassOrInterfaceType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(700)
		p.EmptyDimsOpt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IGeneralClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedClassName() IQualifiedClassNameContext
	TypeArguments() ITypeArgumentsContext

	// IsGeneralClassOrInterfaceTypeContext differentiates from other interfaces.
	IsGeneralClassOrInterfaceTypeContext()
}

type GeneralClassOrInterfaceTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralClassOrInterfaceTypeContext() *GeneralClassOrInterfaceTypeContext {
	var p = new(GeneralClassOrInterfaceTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_generalClassOrInterfaceType
	return p
}

func InitEmptyGeneralClassOrInterfaceTypeContext(p *GeneralClassOrInterfaceTypeContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_generalClassOrInterfaceType
}

func (*GeneralClassOrInterfaceTypeContext) IsGeneralClassOrInterfaceTypeContext() {}

func NewGeneralClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralClassOrInterfaceTypeContext {
	var p = new(GeneralClassOrInterfaceTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_generalClassOrInterfaceType

	return p
}

func (s *GeneralClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralClassOrInterfaceTypeContext) QualifiedClassName() IQualifiedClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *GeneralClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *GeneralClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralClassOrInterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitGeneralClassOrInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) GeneralClassOrInterfaceType() (localctx IGeneralClassOrInterfaceTypeContext) {
	localctx = NewGeneralClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, GroovyParserRULE_generalClassOrInterfaceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.QualifiedClassName()
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(703)
			p.TypeArguments()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandardClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IStandardClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedStandardClassName() IQualifiedStandardClassNameContext
	TypeArguments() ITypeArgumentsContext

	// IsStandardClassOrInterfaceTypeContext differentiates from other interfaces.
	IsStandardClassOrInterfaceTypeContext()
}

type StandardClassOrInterfaceTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardClassOrInterfaceTypeContext() *StandardClassOrInterfaceTypeContext {
	var p = new(StandardClassOrInterfaceTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_standardClassOrInterfaceType
	return p
}

func InitEmptyStandardClassOrInterfaceTypeContext(p *StandardClassOrInterfaceTypeContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_standardClassOrInterfaceType
}

func (*StandardClassOrInterfaceTypeContext) IsStandardClassOrInterfaceTypeContext() {}

func NewStandardClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardClassOrInterfaceTypeContext {
	var p = new(StandardClassOrInterfaceTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardClassOrInterfaceType

	return p
}

func (s *StandardClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardClassOrInterfaceTypeContext) QualifiedStandardClassName() IQualifiedStandardClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedStandardClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedStandardClassNameContext)
}

func (s *StandardClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *StandardClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardClassOrInterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitStandardClassOrInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) StandardClassOrInterfaceType() (localctx IStandardClassOrInterfaceTypeContext) {
	localctx = NewStandardClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, GroovyParserRULE_standardClassOrInterfaceType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.QualifiedStandardClassName()
	}
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserLT {
		{
			p.SetState(707)
			p.TypeArguments()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BuiltInPrimitiveType() antlr.TerminalNode

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_primitiveType
	return p
}

func InitEmptyPrimitiveTypeContext(p *PrimitiveTypeContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_primitiveType
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) BuiltInPrimitiveType() antlr.TerminalNode {
	return s.GetToken(GroovyParserBuiltInPrimitiveType, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitPrimitiveType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, GroovyParserRULE_primitiveType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Match(GroovyParserBuiltInPrimitiveType)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext
	AllTypeArgument() []ITypeArgumentContext
	TypeArgument(i int) ITypeArgumentContext
	GT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeArguments
	return p
}

func InitEmptyTypeArgumentsContext(p *TypeArgumentsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeArguments
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *TypeArgumentsContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentsContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeArgumentsContext) AllTypeArgument() []ITypeArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentContext); ok {
			tst[i] = t.(ITypeArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentsContext) TypeArgument(i int) ITypeArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentContext)
}

func (s *TypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *TypeArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTypeArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, GroovyParserRULE_typeArguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Match(GroovyParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(713)
		p.Nls()
	}
	{
		p.SetState(714)
		p.TypeArgument()
	}
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(715)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(716)
			p.Nls()
		}
		{
			p.SetState(717)
			p.TypeArgument()
		}

		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(724)
		p.Nls()
	}
	{
		p.SetState(725)
		p.Match(GroovyParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentContext is an interface to support dynamic dispatch.
type ITypeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	AnnotationsOpt() IAnnotationsOptContext
	QUESTION() antlr.TerminalNode
	Nls() INlsContext
	EXTENDS() antlr.TerminalNode
	SUPER() antlr.TerminalNode

	// IsTypeArgumentContext differentiates from other interfaces.
	IsTypeArgumentContext()
}

type TypeArgumentContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentContext() *TypeArgumentContext {
	var p = new(TypeArgumentContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeArgument
	return p
}

func InitEmptyTypeArgumentContext(p *TypeArgumentContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeArgument
}

func (*TypeArgumentContext) IsTypeArgumentContext() {}

func NewTypeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentContext {
	var p = new(TypeArgumentContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeArgument

	return p
}

func (s *TypeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeArgumentContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *TypeArgumentContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(GroovyParserQUESTION, 0)
}

func (s *TypeArgumentContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeArgumentContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *TypeArgumentContext) SUPER() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUPER, 0)
}

func (s *TypeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTypeArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TypeArgument() (localctx ITypeArgumentContext) {
	localctx = NewTypeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, GroovyParserRULE_typeArgument)
	var _la int

	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(727)
			p.Type_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(728)
			p.AnnotationsOpt()
		}
		{
			p.SetState(729)
			p.Match(GroovyParserQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(734)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserEXTENDS || _la == GroovyParserSUPER {
			{
				p.SetState(730)
				_la = p.GetTokenStream().LA(1)

				if !(_la == GroovyParserEXTENDS || _la == GroovyParserSUPER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(731)
				p.Nls()
			}
			{
				p.SetState(732)
				p.Type_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotatedQualifiedClassNameContext is an interface to support dynamic dispatch.
type IAnnotatedQualifiedClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationsOpt() IAnnotationsOptContext
	QualifiedClassName() IQualifiedClassNameContext

	// IsAnnotatedQualifiedClassNameContext differentiates from other interfaces.
	IsAnnotatedQualifiedClassNameContext()
}

type AnnotatedQualifiedClassNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotatedQualifiedClassNameContext() *AnnotatedQualifiedClassNameContext {
	var p = new(AnnotatedQualifiedClassNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_annotatedQualifiedClassName
	return p
}

func InitEmptyAnnotatedQualifiedClassNameContext(p *AnnotatedQualifiedClassNameContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_annotatedQualifiedClassName
}

func (*AnnotatedQualifiedClassNameContext) IsAnnotatedQualifiedClassNameContext() {}

func NewAnnotatedQualifiedClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotatedQualifiedClassNameContext {
	var p = new(AnnotatedQualifiedClassNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotatedQualifiedClassName

	return p
}

func (s *AnnotatedQualifiedClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotatedQualifiedClassNameContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *AnnotatedQualifiedClassNameContext) QualifiedClassName() IQualifiedClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *AnnotatedQualifiedClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotatedQualifiedClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotatedQualifiedClassNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitAnnotatedQualifiedClassName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) AnnotatedQualifiedClassName() (localctx IAnnotatedQualifiedClassNameContext) {
	localctx = NewAnnotatedQualifiedClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, GroovyParserRULE_annotatedQualifiedClassName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.AnnotationsOpt()
	}
	{
		p.SetState(739)
		p.QualifiedClassName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedClassNameListContext is an interface to support dynamic dispatch.
type IQualifiedClassNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnnotatedQualifiedClassName() []IAnnotatedQualifiedClassNameContext
	AnnotatedQualifiedClassName(i int) IAnnotatedQualifiedClassNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsQualifiedClassNameListContext differentiates from other interfaces.
	IsQualifiedClassNameListContext()
}

type QualifiedClassNameListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedClassNameListContext() *QualifiedClassNameListContext {
	var p = new(QualifiedClassNameListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedClassNameList
	return p
}

func InitEmptyQualifiedClassNameListContext(p *QualifiedClassNameListContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedClassNameList
}

func (*QualifiedClassNameListContext) IsQualifiedClassNameListContext() {}

func NewQualifiedClassNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedClassNameListContext {
	var p = new(QualifiedClassNameListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedClassNameList

	return p
}

func (s *QualifiedClassNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedClassNameListContext) AllAnnotatedQualifiedClassName() []IAnnotatedQualifiedClassNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotatedQualifiedClassNameContext); ok {
			len++
		}
	}

	tst := make([]IAnnotatedQualifiedClassNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotatedQualifiedClassNameContext); ok {
			tst[i] = t.(IAnnotatedQualifiedClassNameContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedClassNameListContext) AnnotatedQualifiedClassName(i int) IAnnotatedQualifiedClassNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotatedQualifiedClassNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotatedQualifiedClassNameContext)
}

func (s *QualifiedClassNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *QualifiedClassNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *QualifiedClassNameListContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedClassNameListContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *QualifiedClassNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedClassNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedClassNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitQualifiedClassNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) QualifiedClassNameList() (localctx IQualifiedClassNameListContext) {
	localctx = NewQualifiedClassNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, GroovyParserRULE_qualifiedClassNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.AnnotatedQualifiedClassName()
	}
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(742)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(743)
			p.Nls()
		}
		{
			p.SetState(744)
			p.AnnotatedQualifiedClassName()
		}

		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParametersContext is an interface to support dynamic dispatch.
type IFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Rparen() IRparenContext
	FormalParameterList() IFormalParameterListContext

	// IsFormalParametersContext differentiates from other interfaces.
	IsFormalParametersContext()
}

type FormalParametersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersContext() *FormalParametersContext {
	var p = new(FormalParametersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_formalParameters
	return p
}

func InitEmptyFormalParametersContext(p *FormalParametersContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_formalParameters
}

func (*FormalParametersContext) IsFormalParametersContext() {}

func NewFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersContext {
	var p = new(FormalParametersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_formalParameters

	return p
}

func (s *FormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *FormalParametersContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *FormalParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitFormalParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) FormalParameters() (localctx IFormalParametersContext) {
	localctx = NewFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, GroovyParserRULE_formalParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(751)
		p.Match(GroovyParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&289283708559718272) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&15) != 0) {
		{
			p.SetState(752)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(755)
		p.Rparen()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFormalParameter() []IFormalParameterContext
	FormalParameter(i int) IFormalParameterContext
	ThisFormalParameter() IThisFormalParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterContext); ok {
			tst[i] = t.(IFormalParameterContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) ThisFormalParameter() IThisFormalParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThisFormalParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThisFormalParameterContext)
}

func (s *FormalParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *FormalParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *FormalParameterListContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, GroovyParserRULE_formalParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(757)
			p.FormalParameter()
		}

	case 2:
		{
			p.SetState(758)
			p.ThisFormalParameter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(761)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(762)
			p.Nls()
		}
		{
			p.SetState(763)
			p.FormalParameter()
		}

		p.SetState(769)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThisFormalParameterContext is an interface to support dynamic dispatch.
type IThisFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	THIS() antlr.TerminalNode

	// IsThisFormalParameterContext differentiates from other interfaces.
	IsThisFormalParameterContext()
}

type ThisFormalParameterContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyThisFormalParameterContext() *ThisFormalParameterContext {
	var p = new(ThisFormalParameterContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_thisFormalParameter
	return p
}

func InitEmptyThisFormalParameterContext(p *ThisFormalParameterContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_thisFormalParameter
}

func (*ThisFormalParameterContext) IsThisFormalParameterContext() {}

func NewThisFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThisFormalParameterContext {
	var p = new(ThisFormalParameterContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_thisFormalParameter

	return p
}

func (s *ThisFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ThisFormalParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ThisFormalParameterContext) THIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHIS, 0)
}

func (s *ThisFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThisFormalParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitThisFormalParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ThisFormalParameter() (localctx IThisFormalParameterContext) {
	localctx = NewThisFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, GroovyParserRULE_thisFormalParameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(770)
		p.Type_()
	}
	{
		p.SetState(771)
		p.Match(GroovyParserTHIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableModifiersOpt() IVariableModifiersOptContext
	VariableDeclaratorId() IVariableDeclaratorIdContext
	Type_() ITypeContext
	ELLIPSIS() antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_formalParameter
	return p
}

func InitEmptyFormalParameterContext(p *FormalParameterContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_formalParameter
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) VariableModifiersOpt() IVariableModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersOptContext)
}

func (s *FormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *FormalParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FormalParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserELLIPSIS, 0)
}

func (s *FormalParameterContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *FormalParameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *FormalParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitFormalParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) FormalParameter() (localctx IFormalParameterContext) {
	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, GroovyParserRULE_formalParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.VariableModifiersOpt()
	}
	p.SetState(775)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(774)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserELLIPSIS {
		{
			p.SetState(777)
			p.Match(GroovyParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(780)
		p.VariableDeclaratorId()
	}
	p.SetState(786)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(781)
			p.Nls()
		}
		{
			p.SetState(782)
			p.Match(GroovyParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(783)
			p.Nls()
		}
		{
			p.SetState(784)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_methodBody
	return p
}

func InitEmptyMethodBodyContext(p *MethodBodyContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_methodBody
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMethodBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) MethodBody() (localctx IMethodBodyContext) {
	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, GroovyParserRULE_methodBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(788)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedNameElement() []IQualifiedNameElementContext
	QualifiedNameElement(i int) IQualifiedNameElementContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllQualifiedNameElement() []IQualifiedNameElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameElementContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameElementContext); ok {
			tst[i] = t.(IQualifiedNameElementContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) QualifiedNameElement(i int) IQualifiedNameElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, GroovyParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.QualifiedNameElement()
	}
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(791)
				p.Match(GroovyParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(792)
				p.QualifiedNameElement()
			}

		}
		p.SetState(797)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameElementContext is an interface to support dynamic dispatch.
type IQualifiedNameElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DEF() antlr.TerminalNode
	IN() antlr.TerminalNode
	AS() antlr.TerminalNode
	TRAIT() antlr.TerminalNode

	// IsQualifiedNameElementContext differentiates from other interfaces.
	IsQualifiedNameElementContext()
}

type QualifiedNameElementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameElementContext() *QualifiedNameElementContext {
	var p = new(QualifiedNameElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedNameElement
	return p
}

func InitEmptyQualifiedNameElementContext(p *QualifiedNameElementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedNameElement
}

func (*QualifiedNameElementContext) IsQualifiedNameElementContext() {}

func NewQualifiedNameElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameElementContext {
	var p = new(QualifiedNameElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedNameElement

	return p
}

func (s *QualifiedNameElementContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameElementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameElementContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *QualifiedNameElementContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *QualifiedNameElementContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *QualifiedNameElementContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *QualifiedNameElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitQualifiedNameElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) QualifiedNameElement() (localctx IQualifiedNameElementContext) {
	localctx = NewQualifiedNameElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, GroovyParserRULE_qualifiedNameElement)
	p.SetState(803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(798)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(799)
			p.Match(GroovyParserDEF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(800)
			p.Match(GroovyParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(801)
			p.Match(GroovyParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(802)
			p.Match(GroovyParserTRAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameElementsContext is an interface to support dynamic dispatch.
type IQualifiedNameElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedNameElement() []IQualifiedNameElementContext
	QualifiedNameElement(i int) IQualifiedNameElementContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedNameElementsContext differentiates from other interfaces.
	IsQualifiedNameElementsContext()
}

type QualifiedNameElementsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameElementsContext() *QualifiedNameElementsContext {
	var p = new(QualifiedNameElementsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedNameElements
	return p
}

func InitEmptyQualifiedNameElementsContext(p *QualifiedNameElementsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedNameElements
}

func (*QualifiedNameElementsContext) IsQualifiedNameElementsContext() {}

func NewQualifiedNameElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameElementsContext {
	var p = new(QualifiedNameElementsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedNameElements

	return p
}

func (s *QualifiedNameElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameElementsContext) AllQualifiedNameElement() []IQualifiedNameElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameElementContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameElementContext); ok {
			tst[i] = t.(IQualifiedNameElementContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameElementsContext) QualifiedNameElement(i int) IQualifiedNameElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementContext)
}

func (s *QualifiedNameElementsContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserDOT)
}

func (s *QualifiedNameElementsContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, i)
}

func (s *QualifiedNameElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitQualifiedNameElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) QualifiedNameElements() (localctx IQualifiedNameElementsContext) {
	localctx = NewQualifiedNameElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, GroovyParserRULE_qualifiedNameElements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(805)
				p.QualifiedNameElement()
			}
			{
				p.SetState(806)
				p.Match(GroovyParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedClassNameContext is an interface to support dynamic dispatch.
type IQualifiedClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedNameElements() IQualifiedNameElementsContext
	Identifier() IIdentifierContext

	// IsQualifiedClassNameContext differentiates from other interfaces.
	IsQualifiedClassNameContext()
}

type QualifiedClassNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedClassNameContext() *QualifiedClassNameContext {
	var p = new(QualifiedClassNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedClassName
	return p
}

func InitEmptyQualifiedClassNameContext(p *QualifiedClassNameContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedClassName
}

func (*QualifiedClassNameContext) IsQualifiedClassNameContext() {}

func NewQualifiedClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedClassNameContext {
	var p = new(QualifiedClassNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedClassName

	return p
}

func (s *QualifiedClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedClassNameContext) QualifiedNameElements() IQualifiedNameElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementsContext)
}

func (s *QualifiedClassNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedClassNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitQualifiedClassName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) QualifiedClassName() (localctx IQualifiedClassNameContext) {
	localctx = NewQualifiedClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, GroovyParserRULE_qualifiedClassName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(813)
		p.QualifiedNameElements()
	}
	{
		p.SetState(814)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedStandardClassNameContext is an interface to support dynamic dispatch.
type IQualifiedStandardClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedNameElements() IQualifiedNameElementsContext
	AllClassName() []IClassNameContext
	ClassName(i int) IClassNameContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedStandardClassNameContext differentiates from other interfaces.
	IsQualifiedStandardClassNameContext()
}

type QualifiedStandardClassNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedStandardClassNameContext() *QualifiedStandardClassNameContext {
	var p = new(QualifiedStandardClassNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedStandardClassName
	return p
}

func InitEmptyQualifiedStandardClassNameContext(p *QualifiedStandardClassNameContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_qualifiedStandardClassName
}

func (*QualifiedStandardClassNameContext) IsQualifiedStandardClassNameContext() {}

func NewQualifiedStandardClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedStandardClassNameContext {
	var p = new(QualifiedStandardClassNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedStandardClassName

	return p
}

func (s *QualifiedStandardClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedStandardClassNameContext) QualifiedNameElements() IQualifiedNameElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementsContext)
}

func (s *QualifiedStandardClassNameContext) AllClassName() []IClassNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassNameContext); ok {
			len++
		}
	}

	tst := make([]IClassNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassNameContext); ok {
			tst[i] = t.(IClassNameContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedStandardClassNameContext) ClassName(i int) IClassNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *QualifiedStandardClassNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserDOT)
}

func (s *QualifiedStandardClassNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, i)
}

func (s *QualifiedStandardClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedStandardClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedStandardClassNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitQualifiedStandardClassName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) QualifiedStandardClassName() (localctx IQualifiedStandardClassNameContext) {
	localctx = NewQualifiedStandardClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, GroovyParserRULE_qualifiedStandardClassName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.QualifiedNameElements()
	}
	{
		p.SetState(817)
		p.ClassName()
	}
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserDOT {
		{
			p.SetState(818)
			p.Match(GroovyParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(819)
			p.ClassName()
		}

		p.SetState(824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyAll(ctx *LiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StringLiteralAltContext struct {
	LiteralContext
}

func NewStringLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralAltContext {
	var p = new(StringLiteralAltContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *StringLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralAltContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *StringLiteralAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitStringLiteralAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerLiteralAltContext struct {
	LiteralContext
}

func NewIntegerLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralAltContext {
	var p = new(IntegerLiteralAltContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *IntegerLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralAltContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserIntegerLiteral, 0)
}

func (s *IntegerLiteralAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitIntegerLiteralAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type FloatingPointLiteralAltContext struct {
	LiteralContext
}

func NewFloatingPointLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatingPointLiteralAltContext {
	var p = new(FloatingPointLiteralAltContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *FloatingPointLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatingPointLiteralAltContext) FloatingPointLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserFloatingPointLiteral, 0)
}

func (s *FloatingPointLiteralAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitFloatingPointLiteralAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullLiteralAltContext struct {
	LiteralContext
}

func NewNullLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralAltContext {
	var p = new(NullLiteralAltContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *NullLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralAltContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserNullLiteral, 0)
}

func (s *NullLiteralAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNullLiteralAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanLiteralAltContext struct {
	LiteralContext
}

func NewBooleanLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralAltContext {
	var p = new(BooleanLiteralAltContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *BooleanLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralAltContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserBooleanLiteral, 0)
}

func (s *BooleanLiteralAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitBooleanLiteralAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, GroovyParserRULE_literal)
	p.SetState(830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserIntegerLiteral:
		localctx = NewIntegerLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(825)
			p.Match(GroovyParserIntegerLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GroovyParserFloatingPointLiteral:
		localctx = NewFloatingPointLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(826)
			p.Match(GroovyParserFloatingPointLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GroovyParserStringLiteral:
		localctx = NewStringLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(827)
			p.StringLiteral()
		}

	case GroovyParserBooleanLiteral:
		localctx = NewBooleanLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(828)
			p.Match(GroovyParserBooleanLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GroovyParserNullLiteral:
		localctx = NewNullLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(829)
			p.Match(GroovyParserNullLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGstringContext is an interface to support dynamic dispatch.
type IGstringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GStringBegin() antlr.TerminalNode
	AllGstringValue() []IGstringValueContext
	GstringValue(i int) IGstringValueContext
	GStringEnd() antlr.TerminalNode
	AllGStringPart() []antlr.TerminalNode
	GStringPart(i int) antlr.TerminalNode

	// IsGstringContext differentiates from other interfaces.
	IsGstringContext()
}

type GstringContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyGstringContext() *GstringContext {
	var p = new(GstringContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_gstring
	return p
}

func InitEmptyGstringContext(p *GstringContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_gstring
}

func (*GstringContext) IsGstringContext() {}

func NewGstringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GstringContext {
	var p = new(GstringContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_gstring

	return p
}

func (s *GstringContext) GetParser() antlr.Parser { return s.parser }

func (s *GstringContext) GStringBegin() antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringBegin, 0)
}

func (s *GstringContext) AllGstringValue() []IGstringValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGstringValueContext); ok {
			len++
		}
	}

	tst := make([]IGstringValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGstringValueContext); ok {
			tst[i] = t.(IGstringValueContext)
			i++
		}
	}

	return tst
}

func (s *GstringContext) GstringValue(i int) IGstringValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringValueContext)
}

func (s *GstringContext) GStringEnd() antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringEnd, 0)
}

func (s *GstringContext) AllGStringPart() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserGStringPart)
}

func (s *GstringContext) GStringPart(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringPart, i)
}

func (s *GstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GstringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitGstring(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Gstring() (localctx IGstringContext) {
	localctx = NewGstringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, GroovyParserRULE_gstring)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.Match(GroovyParserGStringBegin)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(833)
		p.GstringValue()
	}
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserGStringPart {
		{
			p.SetState(834)
			p.Match(GroovyParserGStringPart)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(835)
			p.GstringValue()
		}

		p.SetState(840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(841)
		p.Match(GroovyParserGStringEnd)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGstringValueContext is an interface to support dynamic dispatch.
type IGstringValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GstringPath() IGstringPathContext
	Closure() IClosureContext

	// IsGstringValueContext differentiates from other interfaces.
	IsGstringValueContext()
}

type GstringValueContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyGstringValueContext() *GstringValueContext {
	var p = new(GstringValueContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_gstringValue
	return p
}

func InitEmptyGstringValueContext(p *GstringValueContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_gstringValue
}

func (*GstringValueContext) IsGstringValueContext() {}

func NewGstringValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GstringValueContext {
	var p = new(GstringValueContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_gstringValue

	return p
}

func (s *GstringValueContext) GetParser() antlr.Parser { return s.parser }

func (s *GstringValueContext) GstringPath() IGstringPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringPathContext)
}

func (s *GstringValueContext) Closure() IClosureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureContext)
}

func (s *GstringValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GstringValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitGstringValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) GstringValue() (localctx IGstringValueContext) {
	localctx = NewGstringValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, GroovyParserRULE_gstringValue)
	p.SetState(845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAS, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserYIELD, GroovyParserPERMITS, GroovyParserRECORD, GroovyParserSEALED, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(843)
			p.GstringPath()
		}

	case GroovyParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(844)
			p.Closure()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGstringPathContext is an interface to support dynamic dispatch.
type IGstringPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllGStringPathPart() []antlr.TerminalNode
	GStringPathPart(i int) antlr.TerminalNode

	// IsGstringPathContext differentiates from other interfaces.
	IsGstringPathContext()
}

type GstringPathContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyGstringPathContext() *GstringPathContext {
	var p = new(GstringPathContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_gstringPath
	return p
}

func InitEmptyGstringPathContext(p *GstringPathContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_gstringPath
}

func (*GstringPathContext) IsGstringPathContext() {}

func NewGstringPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GstringPathContext {
	var p = new(GstringPathContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_gstringPath

	return p
}

func (s *GstringPathContext) GetParser() antlr.Parser { return s.parser }

func (s *GstringPathContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GstringPathContext) AllGStringPathPart() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserGStringPathPart)
}

func (s *GstringPathContext) GStringPathPart(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringPathPart, i)
}

func (s *GstringPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GstringPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitGstringPath(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) GstringPath() (localctx IGstringPathContext) {
	localctx = NewGstringPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, GroovyParserRULE_gstringPath)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(847)
		p.Identifier()
	}
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserGStringPathPart {
		{
			p.SetState(848)
			p.Match(GroovyParserGStringPathPart)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaParameters() ILambdaParametersContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	ARROW() antlr.TerminalNode
	LambdaBody() ILambdaBodyContext

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) LambdaParameters() ILambdaParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *LambdaExpressionContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *LambdaExpressionContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserARROW, 0)
}

func (s *LambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLambdaExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, GroovyParserRULE_lambdaExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(854)
		p.LambdaParameters()
	}
	{
		p.SetState(855)
		p.Nls()
	}
	{
		p.SetState(856)
		p.Match(GroovyParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(857)
		p.Nls()
	}
	{
		p.SetState(858)
		p.LambdaBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandardLambdaExpressionContext is an interface to support dynamic dispatch.
type IStandardLambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StandardLambdaParameters() IStandardLambdaParametersContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	ARROW() antlr.TerminalNode
	LambdaBody() ILambdaBodyContext

	// IsStandardLambdaExpressionContext differentiates from other interfaces.
	IsStandardLambdaExpressionContext()
}

type StandardLambdaExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardLambdaExpressionContext() *StandardLambdaExpressionContext {
	var p = new(StandardLambdaExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_standardLambdaExpression
	return p
}

func InitEmptyStandardLambdaExpressionContext(p *StandardLambdaExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_standardLambdaExpression
}

func (*StandardLambdaExpressionContext) IsStandardLambdaExpressionContext() {}

func NewStandardLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardLambdaExpressionContext {
	var p = new(StandardLambdaExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardLambdaExpression

	return p
}

func (s *StandardLambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardLambdaExpressionContext) StandardLambdaParameters() IStandardLambdaParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardLambdaParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardLambdaParametersContext)
}

func (s *StandardLambdaExpressionContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *StandardLambdaExpressionContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *StandardLambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserARROW, 0)
}

func (s *StandardLambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *StandardLambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardLambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardLambdaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitStandardLambdaExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) StandardLambdaExpression() (localctx IStandardLambdaExpressionContext) {
	localctx = NewStandardLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, GroovyParserRULE_standardLambdaExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.StandardLambdaParameters()
	}
	{
		p.SetState(861)
		p.Nls()
	}
	{
		p.SetState(862)
		p.Match(GroovyParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(863)
		p.Nls()
	}
	{
		p.SetState(864)
		p.LambdaBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FormalParameters() IFormalParametersContext

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_lambdaParameters
	return p
}

func InitEmptyLambdaParametersContext(p *LambdaParametersContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_lambdaParameters
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLambdaParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) LambdaParameters() (localctx ILambdaParametersContext) {
	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, GroovyParserRULE_lambdaParameters)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.FormalParameters()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandardLambdaParametersContext is an interface to support dynamic dispatch.
type IStandardLambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FormalParameters() IFormalParametersContext
	VariableDeclaratorId() IVariableDeclaratorIdContext

	// IsStandardLambdaParametersContext differentiates from other interfaces.
	IsStandardLambdaParametersContext()
}

type StandardLambdaParametersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardLambdaParametersContext() *StandardLambdaParametersContext {
	var p = new(StandardLambdaParametersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_standardLambdaParameters
	return p
}

func InitEmptyStandardLambdaParametersContext(p *StandardLambdaParametersContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_standardLambdaParameters
}

func (*StandardLambdaParametersContext) IsStandardLambdaParametersContext() {}

func NewStandardLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardLambdaParametersContext {
	var p = new(StandardLambdaParametersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardLambdaParameters

	return p
}

func (s *StandardLambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardLambdaParametersContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *StandardLambdaParametersContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *StandardLambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardLambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardLambdaParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitStandardLambdaParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) StandardLambdaParameters() (localctx IStandardLambdaParametersContext) {
	localctx = NewStandardLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, GroovyParserRULE_standardLambdaParameters)
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(868)
			p.FormalParameters()
		}

	case GroovyParserAS, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserYIELD, GroovyParserPERMITS, GroovyParserRECORD, GroovyParserSEALED, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(869)
			p.VariableDeclaratorId()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaBodyContext is an interface to support dynamic dispatch.
type ILambdaBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	StatementExpression() IStatementExpressionContext

	// IsLambdaBodyContext differentiates from other interfaces.
	IsLambdaBodyContext()
}

type LambdaBodyContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaBodyContext() *LambdaBodyContext {
	var p = new(LambdaBodyContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_lambdaBody
	return p
}

func InitEmptyLambdaBodyContext(p *LambdaBodyContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_lambdaBody
}

func (*LambdaBodyContext) IsLambdaBodyContext() {}

func NewLambdaBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaBodyContext {
	var p = new(LambdaBodyContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_lambdaBody

	return p
}

func (s *LambdaBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LambdaBodyContext) StatementExpression() IStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *LambdaBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLambdaBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) LambdaBody() (localctx ILambdaBodyContext) {
	localctx = NewLambdaBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, GroovyParserRULE_lambdaBody)
	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(872)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(873)
			p.StatementExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClosureContext is an interface to support dynamic dispatch.
type IClosureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	BlockStatementsOpt() IBlockStatementsOptContext
	RBRACE() antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext
	ARROW() antlr.TerminalNode
	Sep() ISepContext
	FormalParameterList() IFormalParameterListContext

	// IsClosureContext differentiates from other interfaces.
	IsClosureContext()
}

type ClosureContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosureContext() *ClosureContext {
	var p = new(ClosureContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_closure
	return p
}

func InitEmptyClosureContext(p *ClosureContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_closure
}

func (*ClosureContext) IsClosureContext() {}

func NewClosureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosureContext {
	var p = new(ClosureContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_closure

	return p
}

func (s *ClosureContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosureContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *ClosureContext) BlockStatementsOpt() IBlockStatementsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsOptContext)
}

func (s *ClosureContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *ClosureContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ClosureContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClosureContext) ARROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserARROW, 0)
}

func (s *ClosureContext) Sep() ISepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ClosureContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClosureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClosure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Closure() (localctx IClosureContext) {
	localctx = NewClosureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, GroovyParserRULE_closure)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(876)
		p.Match(GroovyParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(885)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(877)
			p.Nls()
		}
		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&289283708559718272) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&15) != 0) {
			{
				p.SetState(878)
				p.FormalParameterList()
			}
			{
				p.SetState(879)
				p.Nls()
			}

		}
		{
			p.SetState(883)
			p.Match(GroovyParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(888)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(887)
			p.Sep()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(890)
		p.BlockStatementsOpt()
	}
	{
		p.SetState(891)
		p.Match(GroovyParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClosureOrLambdaExpressionContext is an interface to support dynamic dispatch.
type IClosureOrLambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Closure() IClosureContext
	LambdaExpression() ILambdaExpressionContext

	// IsClosureOrLambdaExpressionContext differentiates from other interfaces.
	IsClosureOrLambdaExpressionContext()
}

type ClosureOrLambdaExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosureOrLambdaExpressionContext() *ClosureOrLambdaExpressionContext {
	var p = new(ClosureOrLambdaExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_closureOrLambdaExpression
	return p
}

func InitEmptyClosureOrLambdaExpressionContext(p *ClosureOrLambdaExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_closureOrLambdaExpression
}

func (*ClosureOrLambdaExpressionContext) IsClosureOrLambdaExpressionContext() {}

func NewClosureOrLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosureOrLambdaExpressionContext {
	var p = new(ClosureOrLambdaExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_closureOrLambdaExpression

	return p
}

func (s *ClosureOrLambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosureOrLambdaExpressionContext) Closure() IClosureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureContext)
}

func (s *ClosureOrLambdaExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ClosureOrLambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureOrLambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosureOrLambdaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClosureOrLambdaExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ClosureOrLambdaExpression() (localctx IClosureOrLambdaExpressionContext) {
	localctx = NewClosureOrLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, GroovyParserRULE_closureOrLambdaExpression)
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(893)
			p.Closure()
		}

	case GroovyParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(894)
			p.LambdaExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockStatementsOptContext is an interface to support dynamic dispatch.
type IBlockStatementsOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockStatements() IBlockStatementsContext

	// IsBlockStatementsOptContext differentiates from other interfaces.
	IsBlockStatementsOptContext()
}

type BlockStatementsOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementsOptContext() *BlockStatementsOptContext {
	var p = new(BlockStatementsOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_blockStatementsOpt
	return p
}

func InitEmptyBlockStatementsOptContext(p *BlockStatementsOptContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_blockStatementsOpt
}

func (*BlockStatementsOptContext) IsBlockStatementsOptContext() {}

func NewBlockStatementsOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementsOptContext {
	var p = new(BlockStatementsOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_blockStatementsOpt

	return p
}

func (s *BlockStatementsOptContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementsOptContext) BlockStatements() IBlockStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *BlockStatementsOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementsOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementsOptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitBlockStatementsOpt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) BlockStatementsOpt() (localctx IBlockStatementsOptContext) {
	localctx = NewBlockStatementsOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, GroovyParserRULE_blockStatementsOpt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(898)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(897)
			p.BlockStatements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockStatementsContext is an interface to support dynamic dispatch.
type IBlockStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBlockStatement() []IBlockStatementContext
	BlockStatement(i int) IBlockStatementContext
	AllSep() []ISepContext
	Sep(i int) ISepContext

	// IsBlockStatementsContext differentiates from other interfaces.
	IsBlockStatementsContext()
}

type BlockStatementsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementsContext() *BlockStatementsContext {
	var p = new(BlockStatementsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_blockStatements
	return p
}

func InitEmptyBlockStatementsContext(p *BlockStatementsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_blockStatements
}

func (*BlockStatementsContext) IsBlockStatementsContext() {}

func NewBlockStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementsContext {
	var p = new(BlockStatementsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_blockStatements

	return p
}

func (s *BlockStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementsContext) AllBlockStatement() []IBlockStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockStatementContext); ok {
			len++
		}
	}

	tst := make([]IBlockStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockStatementContext); ok {
			tst[i] = t.(IBlockStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementsContext) BlockStatement(i int) IBlockStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *BlockStatementsContext) AllSep() []ISepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISepContext); ok {
			len++
		}
	}

	tst := make([]ISepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISepContext); ok {
			tst[i] = t.(ISepContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementsContext) Sep(i int) ISepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *BlockStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitBlockStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) BlockStatements() (localctx IBlockStatementsContext) {
	localctx = NewBlockStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, GroovyParserRULE_blockStatements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(900)
		p.BlockStatement()
	}
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(901)
				p.Sep()
			}
			{
				p.SetState(902)
				p.BlockStatement()
			}

		}
		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(909)
			p.Sep()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationsOptContext is an interface to support dynamic dispatch.
type IAnnotationsOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsAnnotationsOptContext differentiates from other interfaces.
	IsAnnotationsOptContext()
}

type AnnotationsOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationsOptContext() *AnnotationsOptContext {
	var p = new(AnnotationsOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_annotationsOpt
	return p
}

func InitEmptyAnnotationsOptContext(p *AnnotationsOptContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_annotationsOpt
}

func (*AnnotationsOptContext) IsAnnotationsOptContext() {}

func NewAnnotationsOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationsOptContext {
	var p = new(AnnotationsOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotationsOpt

	return p
}

func (s *AnnotationsOptContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationsOptContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationsOptContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationsOptContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationsOptContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AnnotationsOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationsOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationsOptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitAnnotationsOpt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) AnnotationsOpt() (localctx IAnnotationsOptContext) {
	localctx = NewAnnotationsOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, GroovyParserRULE_annotationsOpt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserAT {
		{
			p.SetState(912)
			p.Annotation()
		}
		p.SetState(918)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(913)
					p.Nls()
				}
				{
					p.SetState(914)
					p.Annotation()
				}

			}
			p.SetState(920)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(921)
			p.Nls()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	AnnotationName() IAnnotationNameContext
	Nls() INlsContext
	LPAREN() antlr.TerminalNode
	Rparen() IRparenContext
	ElementValues() IElementValuesContext

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_annotation
	return p
}

func InitEmptyAnnotationContext(p *AnnotationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_annotation
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(GroovyParserAT, 0)
}

func (s *AnnotationContext) AnnotationName() IAnnotationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationNameContext)
}

func (s *AnnotationContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *AnnotationContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *AnnotationContext) ElementValues() IElementValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuesContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, GroovyParserRULE_annotation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(925)
		p.Match(GroovyParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(926)
		p.AnnotationName()
	}
	p.SetState(934)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(927)
			p.Nls()
		}
		{
			p.SetState(928)
			p.Match(GroovyParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(930)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(929)
				p.ElementValues()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(932)
			p.Rparen()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValuesContext is an interface to support dynamic dispatch.
type IElementValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementValuePairs() IElementValuePairsContext
	ElementValue() IElementValueContext

	// IsElementValuesContext differentiates from other interfaces.
	IsElementValuesContext()
}

type ElementValuesContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuesContext() *ElementValuesContext {
	var p = new(ElementValuesContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValues
	return p
}

func InitEmptyElementValuesContext(p *ElementValuesContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValues
}

func (*ElementValuesContext) IsElementValuesContext() {}

func NewElementValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuesContext {
	var p = new(ElementValuesContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValues

	return p
}

func (s *ElementValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuesContext) ElementValuePairs() IElementValuePairsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairsContext)
}

func (s *ElementValuesContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitElementValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ElementValues() (localctx IElementValuesContext) {
	localctx = NewElementValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, GroovyParserRULE_elementValues)
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(936)
			p.ElementValuePairs()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(937)
			p.ElementValue()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationNameContext is an interface to support dynamic dispatch.
type IAnnotationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedClassName() IQualifiedClassNameContext

	// IsAnnotationNameContext differentiates from other interfaces.
	IsAnnotationNameContext()
}

type AnnotationNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationNameContext() *AnnotationNameContext {
	var p = new(AnnotationNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_annotationName
	return p
}

func InitEmptyAnnotationNameContext(p *AnnotationNameContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_annotationName
}

func (*AnnotationNameContext) IsAnnotationNameContext() {}

func NewAnnotationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationNameContext {
	var p = new(AnnotationNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotationName

	return p
}

func (s *AnnotationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationNameContext) QualifiedClassName() IQualifiedClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *AnnotationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitAnnotationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) AnnotationName() (localctx IAnnotationNameContext) {
	localctx = NewAnnotationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, GroovyParserRULE_annotationName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(940)
		p.QualifiedClassName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValuePairsContext is an interface to support dynamic dispatch.
type IElementValuePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElementValuePair() []IElementValuePairContext
	ElementValuePair(i int) IElementValuePairContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementValuePairsContext differentiates from other interfaces.
	IsElementValuePairsContext()
}

type ElementValuePairsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairsContext() *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValuePairs
	return p
}

func InitEmptyElementValuePairsContext(p *ElementValuePairsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValuePairs
}

func (*ElementValuePairsContext) IsElementValuePairsContext() {}

func NewElementValuePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValuePairs

	return p
}

func (s *ElementValuePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairsContext) AllElementValuePair() []IElementValuePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValuePairContext); ok {
			len++
		}
	}

	tst := make([]IElementValuePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValuePairContext); ok {
			tst[i] = t.(IElementValuePairContext)
			i++
		}
	}

	return tst
}

func (s *ElementValuePairsContext) ElementValuePair(i int) IElementValuePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *ElementValuePairsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ElementValuePairsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ElementValuePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitElementValuePairs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ElementValuePairs() (localctx IElementValuePairsContext) {
	localctx = NewElementValuePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, GroovyParserRULE_elementValuePairs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(942)
		p.ElementValuePair()
	}
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(943)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(944)
			p.ElementValuePair()
		}

		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValuePairContext is an interface to support dynamic dispatch.
type IElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementValuePairName() IElementValuePairNameContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	ASSIGN() antlr.TerminalNode
	ElementValue() IElementValueContext

	// IsElementValuePairContext differentiates from other interfaces.
	IsElementValuePairContext()
}

type ElementValuePairContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairContext() *ElementValuePairContext {
	var p = new(ElementValuePairContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValuePair
	return p
}

func InitEmptyElementValuePairContext(p *ElementValuePairContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValuePair
}

func (*ElementValuePairContext) IsElementValuePairContext() {}

func NewElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairContext {
	var p = new(ElementValuePairContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValuePair

	return p
}

func (s *ElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairContext) ElementValuePairName() IElementValuePairNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairNameContext)
}

func (s *ElementValuePairContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ElementValuePairContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ElementValuePairContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *ElementValuePairContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitElementValuePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ElementValuePair() (localctx IElementValuePairContext) {
	localctx = NewElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, GroovyParserRULE_elementValuePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.ElementValuePairName()
	}
	{
		p.SetState(951)
		p.Nls()
	}
	{
		p.SetState(952)
		p.Match(GroovyParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(953)
		p.Nls()
	}
	{
		p.SetState(954)
		p.ElementValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValuePairNameContext is an interface to support dynamic dispatch.
type IElementValuePairNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Keywords() IKeywordsContext

	// IsElementValuePairNameContext differentiates from other interfaces.
	IsElementValuePairNameContext()
}

type ElementValuePairNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairNameContext() *ElementValuePairNameContext {
	var p = new(ElementValuePairNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValuePairName
	return p
}

func InitEmptyElementValuePairNameContext(p *ElementValuePairNameContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValuePairName
}

func (*ElementValuePairNameContext) IsElementValuePairNameContext() {}

func NewElementValuePairNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairNameContext {
	var p = new(ElementValuePairNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValuePairName

	return p
}

func (s *ElementValuePairNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ElementValuePairNameContext) Keywords() IKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *ElementValuePairNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitElementValuePairName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ElementValuePairName() (localctx IElementValuePairNameContext) {
	localctx = NewElementValuePairNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, GroovyParserRULE_elementValuePairName)
	p.SetState(958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(956)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(957)
			p.Keywords()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValueContext is an interface to support dynamic dispatch.
type IElementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementValueArrayInitializer() IElementValueArrayInitializerContext
	Annotation() IAnnotationContext
	Expression() IExpressionContext

	// IsElementValueContext differentiates from other interfaces.
	IsElementValueContext()
}

type ElementValueContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueContext() *ElementValueContext {
	var p = new(ElementValueContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValue
	return p
}

func InitEmptyElementValueContext(p *ElementValueContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValue
}

func (*ElementValueContext) IsElementValueContext() {}

func NewElementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueContext {
	var p = new(ElementValueContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValue

	return p
}

func (s *ElementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueContext) ElementValueArrayInitializer() IElementValueArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueArrayInitializerContext)
}

func (s *ElementValueContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ElementValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitElementValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ElementValue() (localctx IElementValueContext) {
	localctx = NewElementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, GroovyParserRULE_elementValue)
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(960)
			p.ElementValueArrayInitializer()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(961)
			p.Annotation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(962)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValueArrayInitializerContext is an interface to support dynamic dispatch.
type IElementValueArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	AllElementValue() []IElementValueContext
	ElementValue(i int) IElementValueContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementValueArrayInitializerContext differentiates from other interfaces.
	IsElementValueArrayInitializerContext()
}

type ElementValueArrayInitializerContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueArrayInitializerContext() *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValueArrayInitializer
	return p
}

func InitEmptyElementValueArrayInitializerContext(p *ElementValueArrayInitializerContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_elementValueArrayInitializer
}

func (*ElementValueArrayInitializerContext) IsElementValueArrayInitializerContext() {}

func NewElementValueArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValueArrayInitializer

	return p
}

func (s *ElementValueArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueArrayInitializerContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *ElementValueArrayInitializerContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *ElementValueArrayInitializerContext) AllElementValue() []IElementValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValueContext); ok {
			len++
		}
	}

	tst := make([]IElementValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValueContext); ok {
			tst[i] = t.(IElementValueContext)
			i++
		}
	}

	return tst
}

func (s *ElementValueArrayInitializerContext) ElementValue(i int) IElementValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValueArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ElementValueArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ElementValueArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueArrayInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitElementValueArrayInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ElementValueArrayInitializer() (localctx IElementValueArrayInitializerContext) {
	localctx = NewElementValueArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, GroovyParserRULE_elementValueArrayInitializer)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(965)
		p.Match(GroovyParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(977)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(966)
			p.ElementValue()
		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(967)
					p.Match(GroovyParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(968)
					p.ElementValue()
				}

			}
			p.SetState(973)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserCOMMA {
			{
				p.SetState(974)
				p.Match(GroovyParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(979)
		p.Match(GroovyParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	BlockStatementsOpt() IBlockStatementsOptContext
	RBRACE() antlr.TerminalNode
	Sep() ISepContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *BlockContext) BlockStatementsOpt() IBlockStatementsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsOptContext)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *BlockContext) Sep() ISepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, GroovyParserRULE_block)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(981)
		p.Match(GroovyParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(983)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(982)
			p.Sep()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(985)
		p.BlockStatementsOpt()
	}
	{
		p.SetState(986)
		p.Match(GroovyParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	Statement() IStatementContext

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_blockStatement
	return p
}

func InitEmptyBlockStatementContext(p *BlockStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_blockStatement
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *BlockStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitBlockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, GroovyParserRULE_blockStatement)
	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(988)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(989)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaration() IVariableDeclarationContext

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_localVariableDeclaration
	return p
}

func InitEmptyLocalVariableDeclarationContext(p *LocalVariableDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_localVariableDeclaration
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLocalVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, GroovyParserRULE_localVariableDeclaration)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(992)

	if !(!isInvalidLocalVariableDeclaration(p.GetTokenStream())) {
		p.SetError(antlr.NewFailedPredicateException(p, " !isInvalidLocalVariableDeclaration(p.GetTokenStream()) ", ""))
		goto errorExit
	}
	{
		p.SetState(993)
		p.VariableDeclaration(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// Getter signatures
	Modifiers() IModifiersContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	VariableDeclarators() IVariableDeclaratorsContext
	TypeNamePairs() ITypeNamePairsContext
	ASSIGN() antlr.TerminalNode
	VariableInitializer() IVariableInitializerContext
	Type_() ITypeContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclaration

	p.t = t

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) GetT() int { return s.t }

func (s *VariableDeclarationContext) SetT(v int) { s.t = v }

func (s *VariableDeclarationContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *VariableDeclarationContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *VariableDeclarationContext) TypeNamePairs() ITypeNamePairsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNamePairsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNamePairsContext)
}

func (s *VariableDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *VariableDeclarationContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) VariableDeclaration(t int) (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 162, GroovyParserRULE_variableDeclaration)
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(995)
			p.Modifiers()
		}
		{
			p.SetState(996)
			p.Nls()
		}
		p.SetState(1007)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserYIELD, GroovyParserPERMITS, GroovyParserRECORD, GroovyParserSEALED, GroovyParserVOID, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier, GroovyParserAT:
			p.SetState(998)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(997)
					p.Type_()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1000)
				p.VariableDeclarators()
			}

		case GroovyParserLPAREN:
			{
				p.SetState(1001)
				p.TypeNamePairs()
			}
			{
				p.SetState(1002)
				p.Nls()
			}
			{
				p.SetState(1003)
				p.Match(GroovyParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1004)
				p.Nls()
			}
			{
				p.SetState(1005)
				p.VariableInitializer()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1009)
			p.Type_()
		}
		{
			p.SetState(1010)
			p.VariableDeclarators()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNamePairsContext is an interface to support dynamic dispatch.
type ITypeNamePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllTypeNamePair() []ITypeNamePairContext
	TypeNamePair(i int) ITypeNamePairContext
	Rparen() IRparenContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeNamePairsContext differentiates from other interfaces.
	IsTypeNamePairsContext()
}

type TypeNamePairsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNamePairsContext() *TypeNamePairsContext {
	var p = new(TypeNamePairsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeNamePairs
	return p
}

func InitEmptyTypeNamePairsContext(p *TypeNamePairsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeNamePairs
}

func (*TypeNamePairsContext) IsTypeNamePairsContext() {}

func NewTypeNamePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNamePairsContext {
	var p = new(TypeNamePairsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeNamePairs

	return p
}

func (s *TypeNamePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNamePairsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *TypeNamePairsContext) AllTypeNamePair() []ITypeNamePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeNamePairContext); ok {
			len++
		}
	}

	tst := make([]ITypeNamePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeNamePairContext); ok {
			tst[i] = t.(ITypeNamePairContext)
			i++
		}
	}

	return tst
}

func (s *TypeNamePairsContext) TypeNamePair(i int) ITypeNamePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNamePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNamePairContext)
}

func (s *TypeNamePairsContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *TypeNamePairsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeNamePairsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeNamePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNamePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNamePairsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTypeNamePairs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TypeNamePairs() (localctx ITypeNamePairsContext) {
	localctx = NewTypeNamePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, GroovyParserRULE_typeNamePairs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1014)
		p.Match(GroovyParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1015)
		p.TypeNamePair()
	}
	p.SetState(1020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(1016)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1017)
			p.TypeNamePair()
		}

		p.SetState(1022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1023)
		p.Rparen()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNamePairContext is an interface to support dynamic dispatch.
type ITypeNamePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaratorId() IVariableDeclaratorIdContext
	Type_() ITypeContext

	// IsTypeNamePairContext differentiates from other interfaces.
	IsTypeNamePairContext()
}

type TypeNamePairContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNamePairContext() *TypeNamePairContext {
	var p = new(TypeNamePairContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeNamePair
	return p
}

func InitEmptyTypeNamePairContext(p *TypeNamePairContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeNamePair
}

func (*TypeNamePairContext) IsTypeNamePairContext() {}

func NewTypeNamePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNamePairContext {
	var p = new(TypeNamePairContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeNamePair

	return p
}

func (s *TypeNamePairContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNamePairContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *TypeNamePairContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeNamePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNamePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNamePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTypeNamePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TypeNamePair() (localctx ITypeNamePairContext) {
	localctx = NewTypeNamePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, GroovyParserRULE_typeNamePair)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1025)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1028)
		p.VariableDeclaratorId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableNamesContext is an interface to support dynamic dispatch.
type IVariableNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllVariableDeclaratorId() []IVariableDeclaratorIdContext
	VariableDeclaratorId(i int) IVariableDeclaratorIdContext
	Rparen() IRparenContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariableNamesContext differentiates from other interfaces.
	IsVariableNamesContext()
}

type VariableNamesContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNamesContext() *VariableNamesContext {
	var p = new(VariableNamesContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableNames
	return p
}

func InitEmptyVariableNamesContext(p *VariableNamesContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_variableNames
}

func (*VariableNamesContext) IsVariableNamesContext() {}

func NewVariableNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNamesContext {
	var p = new(VariableNamesContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableNames

	return p
}

func (s *VariableNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNamesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *VariableNamesContext) AllVariableDeclaratorId() []IVariableDeclaratorIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclaratorIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclaratorIdContext); ok {
			tst[i] = t.(IVariableDeclaratorIdContext)
			i++
		}
	}

	return tst
}

func (s *VariableNamesContext) VariableDeclaratorId(i int) IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableNamesContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *VariableNamesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *VariableNamesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *VariableNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitVariableNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) VariableNames() (localctx IVariableNamesContext) {
	localctx = NewVariableNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, GroovyParserRULE_variableNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1030)
		p.Match(GroovyParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1031)
		p.VariableDeclaratorId()
	}
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == GroovyParserCOMMA {
		{
			p.SetState(1032)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1033)
			p.VariableDeclaratorId()
		}

		p.SetState(1036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1038)
		p.Rparen()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalStatementContext is an interface to support dynamic dispatch.
type IConditionalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfElseStatement() IIfElseStatementContext
	SwitchStatement() ISwitchStatementContext

	// IsConditionalStatementContext differentiates from other interfaces.
	IsConditionalStatementContext()
}

type ConditionalStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalStatementContext() *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_conditionalStatement
	return p
}

func InitEmptyConditionalStatementContext(p *ConditionalStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_conditionalStatement
}

func (*ConditionalStatementContext) IsConditionalStatementContext() {}

func NewConditionalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_conditionalStatement

	return p
}

func (s *ConditionalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalStatementContext) IfElseStatement() IIfElseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfElseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfElseStatementContext)
}

func (s *ConditionalStatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *ConditionalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitConditionalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ConditionalStatement() (localctx IConditionalStatementContext) {
	localctx = NewConditionalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, GroovyParserRULE_conditionalStatement)
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1040)
			p.IfElseStatement()
		}

	case GroovyParserSWITCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1041)
			p.SwitchStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfElseStatementContext is an interface to support dynamic dispatch.
type IIfElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTb returns the tb rule contexts.
	GetTb() IStatementContext

	// GetFb returns the fb rule contexts.
	GetFb() IStatementContext

	// SetTb sets the tb rule contexts.
	SetTb(IStatementContext)

	// SetFb sets the fb rule contexts.
	SetFb(IStatementContext)

	// Getter signatures
	IF() antlr.TerminalNode
	ExpressionInPar() IExpressionInParContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode
	Sep() ISepContext

	// IsIfElseStatementContext differentiates from other interfaces.
	IsIfElseStatementContext()
}

type IfElseStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	tb     IStatementContext
	fb     IStatementContext
}

func NewEmptyIfElseStatementContext() *IfElseStatementContext {
	var p = new(IfElseStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_ifElseStatement
	return p
}

func InitEmptyIfElseStatementContext(p *IfElseStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_ifElseStatement
}

func (*IfElseStatementContext) IsIfElseStatementContext() {}

func NewIfElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfElseStatementContext {
	var p = new(IfElseStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_ifElseStatement

	return p
}

func (s *IfElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfElseStatementContext) GetTb() IStatementContext { return s.tb }

func (s *IfElseStatementContext) GetFb() IStatementContext { return s.fb }

func (s *IfElseStatementContext) SetTb(v IStatementContext) { s.tb = v }

func (s *IfElseStatementContext) SetFb(v IStatementContext) { s.fb = v }

func (s *IfElseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(GroovyParserIF, 0)
}

func (s *IfElseStatementContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *IfElseStatementContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *IfElseStatementContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *IfElseStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfElseStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfElseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(GroovyParserELSE, 0)
}

func (s *IfElseStatementContext) Sep() ISepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *IfElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfElseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitIfElseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) IfElseStatement() (localctx IIfElseStatementContext) {
	localctx = NewIfElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, GroovyParserRULE_ifElseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1044)
		p.Match(GroovyParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1045)
		p.ExpressionInPar()
	}
	{
		p.SetState(1046)
		p.Nls()
	}
	{
		p.SetState(1047)

		var _x = p.Statement()

		localctx.(*IfElseStatementContext).tb = _x
	}
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
		p.SetState(1050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1048)
				p.Nls()
			}

		case 2:
			{
				p.SetState(1049)
				p.Sep()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1052)
			p.Match(GroovyParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1053)
			p.Nls()
		}
		{
			p.SetState(1054)

			var _x = p.Statement()

			localctx.(*IfElseStatementContext).fb = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	ExpressionInPar() IExpressionInParContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllSwitchBlockStatementGroup() []ISwitchBlockStatementGroupContext
	SwitchBlockStatementGroup(i int) ISwitchBlockStatementGroupContext

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchStatement
	return p
}

func InitEmptySwitchStatementContext(p *SwitchStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchStatement
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserSWITCH, 0)
}

func (s *SwitchStatementContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *SwitchStatementContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SwitchStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *SwitchStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *SwitchStatementContext) AllSwitchBlockStatementGroup() []ISwitchBlockStatementGroupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			len++
		}
	}

	tst := make([]ISwitchBlockStatementGroupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			tst[i] = t.(ISwitchBlockStatementGroupContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) SwitchBlockStatementGroup(i int) ISwitchBlockStatementGroupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockStatementGroupContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitSwitchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, GroovyParserRULE_switchStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1058)
		p.Match(GroovyParserSWITCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1059)
		p.ExpressionInPar()
	}
	{
		p.SetState(1060)
		p.Nls()
	}
	{
		p.SetState(1061)
		p.Match(GroovyParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1062)
		p.Nls()
	}
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserCASE || _la == GroovyParserDEFAULT {
		p.SetState(1064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == GroovyParserCASE || _la == GroovyParserDEFAULT {
			{
				p.SetState(1063)
				p.SwitchBlockStatementGroup()
			}

			p.SetState(1066)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1068)
			p.Nls()
		}

	}
	{
		p.SetState(1072)
		p.Match(GroovyParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_loopStatement
	return p
}

func InitEmptyLoopStatementContext(p *LoopStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_loopStatement
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) CopyAll(ctx *LoopStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DoWhileStmtAltContext struct {
	LoopStatementContext
}

func NewDoWhileStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoWhileStmtAltContext {
	var p = new(DoWhileStmtAltContext)

	InitEmptyLoopStatementContext(&p.LoopStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoopStatementContext))

	return p
}

func (s *DoWhileStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStmtAltContext) DO() antlr.TerminalNode {
	return s.GetToken(GroovyParserDO, 0)
}

func (s *DoWhileStmtAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *DoWhileStmtAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *DoWhileStmtAltContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStmtAltContext) WHILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserWHILE, 0)
}

func (s *DoWhileStmtAltContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *DoWhileStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitDoWhileStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForStmtAltContext struct {
	LoopStatementContext
}

func NewForStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForStmtAltContext {
	var p = new(ForStmtAltContext)

	InitEmptyLoopStatementContext(&p.LoopStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoopStatementContext))

	return p
}

func (s *ForStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtAltContext) FOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserFOR, 0)
}

func (s *ForStmtAltContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ForStmtAltContext) ForControl() IForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForControlContext)
}

func (s *ForStmtAltContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ForStmtAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ForStmtAltContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitForStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhileStmtAltContext struct {
	LoopStatementContext
}

func NewWhileStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStmtAltContext {
	var p = new(WhileStmtAltContext)

	InitEmptyLoopStatementContext(&p.LoopStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoopStatementContext))

	return p
}

func (s *WhileStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStmtAltContext) WHILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserWHILE, 0)
}

func (s *WhileStmtAltContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *WhileStmtAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *WhileStmtAltContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitWhileStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, GroovyParserRULE_loopStatement)
	p.SetState(1093)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserFOR:
		localctx = NewForStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1074)
			p.Match(GroovyParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1075)
			p.Match(GroovyParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1076)
			p.ForControl()
		}
		{
			p.SetState(1077)
			p.Rparen()
		}
		{
			p.SetState(1078)
			p.Nls()
		}
		{
			p.SetState(1079)
			p.Statement()
		}

	case GroovyParserWHILE:
		localctx = NewWhileStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1081)
			p.Match(GroovyParserWHILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1082)
			p.ExpressionInPar()
		}
		{
			p.SetState(1083)
			p.Nls()
		}
		{
			p.SetState(1084)
			p.Statement()
		}

	case GroovyParserDO:
		localctx = NewDoWhileStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1086)
			p.Match(GroovyParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1087)
			p.Nls()
		}
		{
			p.SetState(1088)
			p.Statement()
		}
		{
			p.SetState(1089)
			p.Nls()
		}
		{
			p.SetState(1090)
			p.Match(GroovyParserWHILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1091)
			p.ExpressionInPar()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCONTINUE, 0)
}

func (s *ContinueStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, GroovyParserRULE_continueStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1095)
		p.Match(GroovyParserCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&178120883836544) != 0) || _la == GroovyParserCapitalizedIdentifier || _la == GroovyParserIdentifier {
		{
			p.SetState(1096)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(GroovyParserBREAK, 0)
}

func (s *BreakStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, GroovyParserRULE_breakStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.Match(GroovyParserBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&178120883836544) != 0) || _la == GroovyParserCapitalizedIdentifier || _la == GroovyParserIdentifier {
		{
			p.SetState(1100)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldStatementContext is an interface to support dynamic dispatch.
type IYieldStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	Expression() IExpressionContext

	// IsYieldStatementContext differentiates from other interfaces.
	IsYieldStatementContext()
}

type YieldStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStatementContext() *YieldStatementContext {
	var p = new(YieldStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_yieldStatement
	return p
}

func InitEmptyYieldStatementContext(p *YieldStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_yieldStatement
}

func (*YieldStatementContext) IsYieldStatementContext() {}

func NewYieldStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStatementContext {
	var p = new(YieldStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_yieldStatement

	return p
}

func (s *YieldStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStatementContext) YIELD() antlr.TerminalNode {
	return s.GetToken(GroovyParserYIELD, 0)
}

func (s *YieldStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *YieldStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitYieldStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) YieldStatement() (localctx IYieldStatementContext) {
	localctx = NewYieldStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, GroovyParserRULE_yieldStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1103)
		p.Match(GroovyParserYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1104)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryCatchStatementContext is an interface to support dynamic dispatch.
type ITryCatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext
	Block() IBlockContext
	Resources() IResourcesContext
	AllCatchClause() []ICatchClauseContext
	CatchClause(i int) ICatchClauseContext
	FinallyBlock() IFinallyBlockContext

	// IsTryCatchStatementContext differentiates from other interfaces.
	IsTryCatchStatementContext()
}

type TryCatchStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryCatchStatementContext() *TryCatchStatementContext {
	var p = new(TryCatchStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_tryCatchStatement
	return p
}

func InitEmptyTryCatchStatementContext(p *TryCatchStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_tryCatchStatement
}

func (*TryCatchStatementContext) IsTryCatchStatementContext() {}

func NewTryCatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryCatchStatementContext {
	var p = new(TryCatchStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_tryCatchStatement

	return p
}

func (s *TryCatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryCatchStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRY, 0)
}

func (s *TryCatchStatementContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *TryCatchStatementContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TryCatchStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryCatchStatementContext) Resources() IResourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourcesContext)
}

func (s *TryCatchStatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryCatchStatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryCatchStatementContext) FinallyBlock() IFinallyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryCatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryCatchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTryCatchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TryCatchStatement() (localctx ITryCatchStatementContext) {
	localctx = NewTryCatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, GroovyParserRULE_tryCatchStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1106)
		p.Match(GroovyParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserLPAREN {
		{
			p.SetState(1107)
			p.Resources()
		}

	}
	{
		p.SetState(1110)
		p.Nls()
	}
	{
		p.SetState(1111)
		p.Block()
	}
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1112)
				p.Nls()
			}
			{
				p.SetState(1113)
				p.CatchClause()
			}

		}
		p.SetState(1119)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1123)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1120)
			p.Nls()
		}
		{
			p.SetState(1121)
			p.FinallyBlock()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssertStatementContext is an interface to support dynamic dispatch.
type IAssertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCe returns the ce rule contexts.
	GetCe() IExpressionContext

	// GetMe returns the me rule contexts.
	GetMe() IExpressionContext

	// SetCe sets the ce rule contexts.
	SetCe(IExpressionContext)

	// SetMe sets the me rule contexts.
	SetMe(IExpressionContext)

	// Getter signatures
	ASSERT() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	COLON() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsAssertStatementContext differentiates from other interfaces.
	IsAssertStatementContext()
}

type AssertStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	ce     IExpressionContext
	me     IExpressionContext
}

func NewEmptyAssertStatementContext() *AssertStatementContext {
	var p = new(AssertStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_assertStatement
	return p
}

func InitEmptyAssertStatementContext(p *AssertStatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_assertStatement
}

func (*AssertStatementContext) IsAssertStatementContext() {}

func NewAssertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertStatementContext {
	var p = new(AssertStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_assertStatement

	return p
}

func (s *AssertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertStatementContext) GetCe() IExpressionContext { return s.ce }

func (s *AssertStatementContext) GetMe() IExpressionContext { return s.me }

func (s *AssertStatementContext) SetCe(v IExpressionContext) { s.ce = v }

func (s *AssertStatementContext) SetMe(v IExpressionContext) { s.me = v }

func (s *AssertStatementContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSERT, 0)
}

func (s *AssertStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssertStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssertStatementContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *AssertStatementContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AssertStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *AssertStatementContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *AssertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitAssertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) AssertStatement() (localctx IAssertStatementContext) {
	localctx = NewAssertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, GroovyParserRULE_assertStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1125)
		p.Match(GroovyParserASSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1126)

		var _x = p.expression(0)

		localctx.(*AssertStatementContext).ce = _x
	}
	p.SetState(1132)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1127)
			p.Nls()
		}
		{
			p.SetState(1128)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserCOMMA || _la == GroovyParserCOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1129)
			p.Nls()
		}
		{
			p.SetState(1130)

			var _x = p.expression(0)

			localctx.(*AssertStatementContext).me = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyAll(ctx *StatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ConditionalStmtAltContext struct {
	StatementContext
}

func NewConditionalStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConditionalStmtAltContext {
	var p = new(ConditionalStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ConditionalStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStmtAltContext) ConditionalStatement() IConditionalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalStatementContext)
}

func (s *ConditionalStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitConditionalStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type EmptyStmtAltContext struct {
	StatementContext
}

func NewEmptyStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EmptyStmtAltContext {
	var p = new(EmptyStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *EmptyStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStmtAltContext) SEMI() antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, 0)
}

func (s *EmptyStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitEmptyStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type BlockStmtAltContext struct {
	StatementContext
}

func NewBlockStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BlockStmtAltContext {
	var p = new(BlockStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *BlockStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStmtAltContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *BlockStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitBlockStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type TryCatchStmtAltContext struct {
	StatementContext
}

func NewTryCatchStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TryCatchStmtAltContext {
	var p = new(TryCatchStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *TryCatchStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchStmtAltContext) TryCatchStatement() ITryCatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryCatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryCatchStatementContext)
}

func (s *TryCatchStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTryCatchStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type BreakStmtAltContext struct {
	StatementContext
}

func NewBreakStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BreakStmtAltContext {
	var p = new(BreakStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *BreakStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStmtAltContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *BreakStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitBreakStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type YieldStmtAltContext struct {
	StatementContext
}

func NewYieldStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *YieldStmtAltContext {
	var p = new(YieldStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *YieldStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStmtAltContext) YieldStatement() IYieldStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *YieldStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitYieldStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ContinueStmtAltContext struct {
	StatementContext
}

func NewContinueStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ContinueStmtAltContext {
	var p = new(ContinueStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ContinueStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStmtAltContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *ContinueStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitContinueStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssertStmtAltContext struct {
	StatementContext
}

func NewAssertStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertStmtAltContext {
	var p = new(AssertStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AssertStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStmtAltContext) AssertStatement() IAssertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssertStatementContext)
}

func (s *AssertStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitAssertStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type LoopStmtAltContext struct {
	StatementContext
}

func NewLoopStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LoopStmtAltContext {
	var p = new(LoopStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *LoopStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStmtAltContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *LoopStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLoopStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type SynchronizedStmtAltContext struct {
	StatementContext
}

func NewSynchronizedStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SynchronizedStmtAltContext {
	var p = new(SynchronizedStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SynchronizedStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SynchronizedStmtAltContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSYNCHRONIZED, 0)
}

func (s *SynchronizedStmtAltContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *SynchronizedStmtAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SynchronizedStmtAltContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SynchronizedStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitSynchronizedStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExpressionStmtAltContext struct {
	StatementContext
}

func NewExpressionStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionStmtAltContext {
	var p = new(ExpressionStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ExpressionStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStmtAltContext) StatementExpression() IStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *ExpressionStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitExpressionStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type LocalVariableDeclarationStmtAltContext struct {
	StatementContext
}

func NewLocalVariableDeclarationStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalVariableDeclarationStmtAltContext {
	var p = new(LocalVariableDeclarationStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *LocalVariableDeclarationStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationStmtAltContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *LocalVariableDeclarationStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLocalVariableDeclarationStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReturnStmtAltContext struct {
	StatementContext
}

func NewReturnStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReturnStmtAltContext {
	var p = new(ReturnStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ReturnStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtAltContext) RETURN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRETURN, 0)
}

func (s *ReturnStmtAltContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitReturnStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ThrowStmtAltContext struct {
	StatementContext
}

func NewThrowStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThrowStmtAltContext {
	var p = new(ThrowStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ThrowStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStmtAltContext) THROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROW, 0)
}

func (s *ThrowStmtAltContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitThrowStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabeledStmtAltContext struct {
	StatementContext
}

func NewLabeledStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabeledStmtAltContext {
	var p = new(LabeledStmtAltContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *LabeledStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStmtAltContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabeledStmtAltContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *LabeledStmtAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LabeledStmtAltContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStmtAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLabeledStmtAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, GroovyParserRULE_statement)
	p.SetState(1162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBlockStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1134)
			p.Block()
		}

	case 2:
		localctx = NewConditionalStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1135)
			p.ConditionalStatement()
		}

	case 3:
		localctx = NewLoopStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1136)
			p.LoopStatement()
		}

	case 4:
		localctx = NewTryCatchStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1137)
			p.TryCatchStatement()
		}

	case 5:
		localctx = NewSynchronizedStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1138)
			p.Match(GroovyParserSYNCHRONIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1139)
			p.ExpressionInPar()
		}
		{
			p.SetState(1140)
			p.Nls()
		}
		{
			p.SetState(1141)
			p.Block()
		}

	case 6:
		localctx = NewReturnStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1143)
			p.Match(GroovyParserRETURN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1145)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1144)
				p.expression(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		localctx = NewThrowStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1147)
			p.Match(GroovyParserTHROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1148)
			p.expression(0)
		}

	case 8:
		localctx = NewBreakStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1149)
			p.BreakStatement()
		}

	case 9:
		localctx = NewContinueStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1150)
			p.ContinueStatement()
		}

	case 10:
		localctx = NewYieldStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		p.SetState(1151)

		if !(p.inSwitchExpressionLevel > 0) {
			p.SetError(antlr.NewFailedPredicateException(p, " p.inSwitchExpressionLevel > 0 ", ""))
			goto errorExit
		}
		{
			p.SetState(1152)
			p.YieldStatement()
		}

	case 11:
		localctx = NewLabeledStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1153)
			p.Identifier()
		}
		{
			p.SetState(1154)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1155)
			p.Nls()
		}
		{
			p.SetState(1156)
			p.Statement()
		}

	case 12:
		localctx = NewAssertStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1158)
			p.AssertStatement()
		}

	case 13:
		localctx = NewLocalVariableDeclarationStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1159)
			p.LocalVariableDeclaration()
		}

	case 14:
		localctx = NewExpressionStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1160)
			p.StatementExpression()
		}

	case 15:
		localctx = NewEmptyStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1161)
			p.Match(GroovyParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATCH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	VariableModifiersOpt() IVariableModifiersOptContext
	Identifier() IIdentifierContext
	Rparen() IRparenContext
	Nls() INlsContext
	Block() IBlockContext
	CatchType() ICatchTypeContext

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_catchClause
	return p
}

func InitEmptyCatchClauseContext(p *CatchClauseContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_catchClause
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserCATCH, 0)
}

func (s *CatchClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *CatchClauseContext) VariableModifiersOpt() IVariableModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersOptContext)
}

func (s *CatchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatchClauseContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *CatchClauseContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) CatchType() ICatchTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchTypeContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCatchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, GroovyParserRULE_catchClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1164)
		p.Match(GroovyParserCATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1165)
		p.Match(GroovyParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1166)
		p.VariableModifiersOpt()
	}
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1167)
			p.CatchType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1170)
		p.Identifier()
	}
	{
		p.SetState(1171)
		p.Rparen()
	}
	{
		p.SetState(1172)
		p.Nls()
	}
	{
		p.SetState(1173)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchTypeContext is an interface to support dynamic dispatch.
type ICatchTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedClassName() []IQualifiedClassNameContext
	QualifiedClassName(i int) IQualifiedClassNameContext
	AllBITOR() []antlr.TerminalNode
	BITOR(i int) antlr.TerminalNode

	// IsCatchTypeContext differentiates from other interfaces.
	IsCatchTypeContext()
}

type CatchTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchTypeContext() *CatchTypeContext {
	var p = new(CatchTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_catchType
	return p
}

func InitEmptyCatchTypeContext(p *CatchTypeContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_catchType
}

func (*CatchTypeContext) IsCatchTypeContext() {}

func NewCatchTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchTypeContext {
	var p = new(CatchTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_catchType

	return p
}

func (s *CatchTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchTypeContext) AllQualifiedClassName() []IQualifiedClassNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedClassNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedClassNameContext); ok {
			tst[i] = t.(IQualifiedClassNameContext)
			i++
		}
	}

	return tst
}

func (s *CatchTypeContext) QualifiedClassName(i int) IQualifiedClassNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *CatchTypeContext) AllBITOR() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserBITOR)
}

func (s *CatchTypeContext) BITOR(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserBITOR, i)
}

func (s *CatchTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCatchType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) CatchType() (localctx ICatchTypeContext) {
	localctx = NewCatchTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, GroovyParserRULE_catchType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1175)
		p.QualifiedClassName()
	}
	p.SetState(1180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserBITOR {
		{
			p.SetState(1176)
			p.Match(GroovyParserBITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1177)
			p.QualifiedClassName()
		}

		p.SetState(1182)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALLY() antlr.TerminalNode
	Nls() INlsContext
	Block() IBlockContext

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_finallyBlock
	return p
}

func InitEmptyFinallyBlockContext(p *FinallyBlockContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_finallyBlock
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINALLY, 0)
}

func (s *FinallyBlockContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitFinallyBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) FinallyBlock() (localctx IFinallyBlockContext) {
	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, GroovyParserRULE_finallyBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1183)
		p.Match(GroovyParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1184)
		p.Nls()
	}
	{
		p.SetState(1185)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourcesContext is an interface to support dynamic dispatch.
type IResourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Nls() INlsContext
	ResourceList() IResourceListContext
	Rparen() IRparenContext
	Sep() ISepContext

	// IsResourcesContext differentiates from other interfaces.
	IsResourcesContext()
}

type ResourcesContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourcesContext() *ResourcesContext {
	var p = new(ResourcesContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_resources
	return p
}

func InitEmptyResourcesContext(p *ResourcesContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_resources
}

func (*ResourcesContext) IsResourcesContext() {}

func NewResourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourcesContext {
	var p = new(ResourcesContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_resources

	return p
}

func (s *ResourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourcesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ResourcesContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ResourcesContext) ResourceList() IResourceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceListContext)
}

func (s *ResourcesContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ResourcesContext) Sep() ISepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ResourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourcesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitResources(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Resources() (localctx IResourcesContext) {
	localctx = NewResourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, GroovyParserRULE_resources)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1187)
		p.Match(GroovyParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1188)
		p.Nls()
	}
	{
		p.SetState(1189)
		p.ResourceList()
	}
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserSEMI || _la == GroovyParserNL {
		{
			p.SetState(1190)
			p.Sep()
		}

	}
	{
		p.SetState(1193)
		p.Rparen()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceListContext is an interface to support dynamic dispatch.
type IResourceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllResource() []IResourceContext
	Resource(i int) IResourceContext
	AllSep() []ISepContext
	Sep(i int) ISepContext

	// IsResourceListContext differentiates from other interfaces.
	IsResourceListContext()
}

type ResourceListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceListContext() *ResourceListContext {
	var p = new(ResourceListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_resourceList
	return p
}

func InitEmptyResourceListContext(p *ResourceListContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_resourceList
}

func (*ResourceListContext) IsResourceListContext() {}

func NewResourceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceListContext {
	var p = new(ResourceListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_resourceList

	return p
}

func (s *ResourceListContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceListContext) AllResource() []IResourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceContext); ok {
			len++
		}
	}

	tst := make([]IResourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceContext); ok {
			tst[i] = t.(IResourceContext)
			i++
		}
	}

	return tst
}

func (s *ResourceListContext) Resource(i int) IResourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *ResourceListContext) AllSep() []ISepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISepContext); ok {
			len++
		}
	}

	tst := make([]ISepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISepContext); ok {
			tst[i] = t.(ISepContext)
			i++
		}
	}

	return tst
}

func (s *ResourceListContext) Sep(i int) ISepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ResourceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitResourceList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ResourceList() (localctx IResourceListContext) {
	localctx = NewResourceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, GroovyParserRULE_resourceList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1195)
		p.Resource()
	}
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1196)
				p.Sep()
			}
			{
				p.SetState(1197)
				p.Resource()
			}

		}
		p.SetState(1203)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	Expression() IExpressionContext

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_resource
	return p
}

func InitEmptyResourceContext(p *ResourceContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_resource
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ResourceContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitResource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Resource() (localctx IResourceContext) {
	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, GroovyParserRULE_resource)
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1204)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1205)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchBlockStatementGroupContext is an interface to support dynamic dispatch.
type ISwitchBlockStatementGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSwitchLabel() []ISwitchLabelContext
	SwitchLabel(i int) ISwitchLabelContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	BlockStatements() IBlockStatementsContext

	// IsSwitchBlockStatementGroupContext differentiates from other interfaces.
	IsSwitchBlockStatementGroupContext()
}

type SwitchBlockStatementGroupContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockStatementGroupContext() *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchBlockStatementGroup
	return p
}

func InitEmptySwitchBlockStatementGroupContext(p *SwitchBlockStatementGroupContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchBlockStatementGroup
}

func (*SwitchBlockStatementGroupContext) IsSwitchBlockStatementGroupContext() {}

func NewSwitchBlockStatementGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchBlockStatementGroup

	return p
}

func (s *SwitchBlockStatementGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockStatementGroupContext) AllSwitchLabel() []ISwitchLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			len++
		}
	}

	tst := make([]ISwitchLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchLabelContext); ok {
			tst[i] = t.(ISwitchLabelContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) SwitchLabel(i int) ISwitchLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchBlockStatementGroupContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SwitchBlockStatementGroupContext) BlockStatements() IBlockStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *SwitchBlockStatementGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockStatementGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockStatementGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitSwitchBlockStatementGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) SwitchBlockStatementGroup() (localctx ISwitchBlockStatementGroupContext) {
	localctx = NewSwitchBlockStatementGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, GroovyParserRULE_switchBlockStatementGroup)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1208)
		p.SwitchLabel()
	}
	p.SetState(1214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1209)
				p.Nls()
			}
			{
				p.SetState(1210)
				p.SwitchLabel()
			}

		}
		p.SetState(1216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1217)
		p.Nls()
	}
	{
		p.SetState(1218)
		p.BlockStatements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchLabelContext is an interface to support dynamic dispatch.
type ISwitchLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Expression() IExpressionContext
	COLON() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsSwitchLabelContext differentiates from other interfaces.
	IsSwitchLabelContext()
}

type SwitchLabelContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchLabelContext() *SwitchLabelContext {
	var p = new(SwitchLabelContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchLabel
	return p
}

func InitEmptySwitchLabelContext(p *SwitchLabelContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchLabel
}

func (*SwitchLabelContext) IsSwitchLabelContext() {}

func NewSwitchLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabelContext {
	var p = new(SwitchLabelContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchLabel

	return p
}

func (s *SwitchLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabelContext) CASE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCASE, 0)
}

func (s *SwitchLabelContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *SwitchLabelContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *SwitchLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitSwitchLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) SwitchLabel() (localctx ISwitchLabelContext) {
	localctx = NewSwitchLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, GroovyParserRULE_switchLabel)
	p.SetState(1226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1220)
			p.Match(GroovyParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1221)
			p.expression(0)
		}
		{
			p.SetState(1222)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GroovyParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1224)
			p.Match(GroovyParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1225)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForControlContext is an interface to support dynamic dispatch.
type IForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnhancedForControl() IEnhancedForControlContext
	ClassicalForControl() IClassicalForControlContext

	// IsForControlContext differentiates from other interfaces.
	IsForControlContext()
}

type ForControlContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyForControlContext() *ForControlContext {
	var p = new(ForControlContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_forControl
	return p
}

func InitEmptyForControlContext(p *ForControlContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_forControl
}

func (*ForControlContext) IsForControlContext() {}

func NewForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForControlContext {
	var p = new(ForControlContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_forControl

	return p
}

func (s *ForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ForControlContext) EnhancedForControl() IEnhancedForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedForControlContext)
}

func (s *ForControlContext) ClassicalForControl() IClassicalForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassicalForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassicalForControlContext)
}

func (s *ForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitForControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ForControl() (localctx IForControlContext) {
	localctx = NewForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, GroovyParserRULE_forControl)
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1228)
			p.EnhancedForControl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1229)
			p.ClassicalForControl()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnhancedForControlContext is an interface to support dynamic dispatch.
type IEnhancedForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableModifiersOpt() IVariableModifiersOptContext
	VariableDeclaratorId() IVariableDeclaratorIdContext
	Expression() IExpressionContext
	COLON() antlr.TerminalNode
	IN() antlr.TerminalNode
	Type_() ITypeContext

	// IsEnhancedForControlContext differentiates from other interfaces.
	IsEnhancedForControlContext()
}

type EnhancedForControlContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForControlContext() *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enhancedForControl
	return p
}

func InitEmptyEnhancedForControlContext(p *EnhancedForControlContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enhancedForControl
}

func (*EnhancedForControlContext) IsEnhancedForControlContext() {}

func NewEnhancedForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedForControl

	return p
}

func (s *EnhancedForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForControlContext) VariableModifiersOpt() IVariableModifiersOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifiersOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersOptContext)
}

func (s *EnhancedForControlContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *EnhancedForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForControlContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *EnhancedForControlContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *EnhancedForControlContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *EnhancedForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitEnhancedForControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) EnhancedForControl() (localctx IEnhancedForControlContext) {
	localctx = NewEnhancedForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, GroovyParserRULE_enhancedForControl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1232)
		p.VariableModifiersOpt()
	}
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1233)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1236)
		p.VariableDeclaratorId()
	}
	{
		p.SetState(1237)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GroovyParserIN || _la == GroovyParserCOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1238)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassicalForControlContext is an interface to support dynamic dispatch.
type IClassicalForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ForInit() IForInitContext
	Expression() IExpressionContext
	ForUpdate() IForUpdateContext

	// IsClassicalForControlContext differentiates from other interfaces.
	IsClassicalForControlContext()
}

type ClassicalForControlContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassicalForControlContext() *ClassicalForControlContext {
	var p = new(ClassicalForControlContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classicalForControl
	return p
}

func InitEmptyClassicalForControlContext(p *ClassicalForControlContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_classicalForControl
}

func (*ClassicalForControlContext) IsClassicalForControlContext() {}

func NewClassicalForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassicalForControlContext {
	var p = new(ClassicalForControlContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classicalForControl

	return p
}

func (s *ClassicalForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassicalForControlContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserSEMI)
}

func (s *ClassicalForControlContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, i)
}

func (s *ClassicalForControlContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ClassicalForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassicalForControlContext) ForUpdate() IForUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *ClassicalForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassicalForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassicalForControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClassicalForControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ClassicalForControl() (localctx IClassicalForControlContext) {
	localctx = NewClassicalForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, GroovyParserRULE_classicalForControl)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1240)
			p.ForInit()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1243)
		p.Match(GroovyParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1245)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1244)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1247)
		p.Match(GroovyParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1248)
			p.ForUpdate()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	ExpressionList() IExpressionListContext

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_forInit
	return p
}

func InitEmptyForInitContext(p *ForInitContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_forInit
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitForInit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, GroovyParserRULE_forInit)
	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1251)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1252)
			p.ExpressionList(false)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_forUpdate
	return p
}

func InitEmptyForUpdateContext(p *ForUpdateContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_forUpdate
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForUpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitForUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ForUpdate() (localctx IForUpdateContext) {
	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, GroovyParserRULE_forUpdate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1255)
		p.ExpressionList(false)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastParExpressionContext is an interface to support dynamic dispatch.
type ICastParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Type_() ITypeContext
	Rparen() IRparenContext

	// IsCastParExpressionContext differentiates from other interfaces.
	IsCastParExpressionContext()
}

type CastParExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastParExpressionContext() *CastParExpressionContext {
	var p = new(CastParExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_castParExpression
	return p
}

func InitEmptyCastParExpressionContext(p *CastParExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_castParExpression
}

func (*CastParExpressionContext) IsCastParExpressionContext() {}

func NewCastParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastParExpressionContext {
	var p = new(CastParExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_castParExpression

	return p
}

func (s *CastParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastParExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *CastParExpressionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CastParExpressionContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *CastParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastParExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCastParExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) CastParExpression() (localctx ICastParExpressionContext) {
	localctx = NewCastParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, GroovyParserRULE_castParExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1257)
		p.Match(GroovyParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1258)
		p.Type_()
	}
	{
		p.SetState(1259)
		p.Rparen()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParExpressionContext is an interface to support dynamic dispatch.
type IParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionInPar() IExpressionInParContext

	// IsParExpressionContext differentiates from other interfaces.
	IsParExpressionContext()
}

type ParExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyParExpressionContext() *ParExpressionContext {
	var p = new(ParExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_parExpression
	return p
}

func InitEmptyParExpressionContext(p *ParExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_parExpression
}

func (*ParExpressionContext) IsParExpressionContext() {}

func NewParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParExpressionContext {
	var p = new(ParExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_parExpression

	return p
}

func (s *ParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParExpressionContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *ParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitParExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ParExpression() (localctx IParExpressionContext) {
	localctx = NewParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, GroovyParserRULE_parExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1261)
		p.ExpressionInPar()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionInParContext is an interface to support dynamic dispatch.
type IExpressionInParContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	EnhancedStatementExpression() IEnhancedStatementExpressionContext
	Rparen() IRparenContext

	// IsExpressionInParContext differentiates from other interfaces.
	IsExpressionInParContext()
}

type ExpressionInParContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionInParContext() *ExpressionInParContext {
	var p = new(ExpressionInParContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_expressionInPar
	return p
}

func InitEmptyExpressionInParContext(p *ExpressionInParContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_expressionInPar
}

func (*ExpressionInParContext) IsExpressionInParContext() {}

func NewExpressionInParContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionInParContext {
	var p = new(ExpressionInParContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expressionInPar

	return p
}

func (s *ExpressionInParContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionInParContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ExpressionInParContext) EnhancedStatementExpression() IEnhancedStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedStatementExpressionContext)
}

func (s *ExpressionInParContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ExpressionInParContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionInParContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionInParContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitExpressionInPar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ExpressionInPar() (localctx IExpressionInParContext) {
	localctx = NewExpressionInParContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, GroovyParserRULE_expressionInPar)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1263)
		p.Match(GroovyParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1264)
		p.EnhancedStatementExpression()
	}
	{
		p.SetState(1265)
		p.Rparen()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCanSpread returns the canSpread attribute.
	GetCanSpread() bool

	// SetCanSpread sets the canSpread attribute.
	SetCanSpread(bool)

	// Getter signatures
	AllExpressionListElement() []IExpressionListElementContext
	ExpressionListElement(i int) IExpressionListElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*GroovyParserRuleContext
	parser    antlr.Parser
	canSpread bool
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, canSpread bool) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expressionList

	p.canSpread = canSpread

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) GetCanSpread() bool { return s.canSpread }

func (s *ExpressionListContext) SetCanSpread(v bool) { s.canSpread = v }

func (s *ExpressionListContext) AllExpressionListElement() []IExpressionListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionListElementContext); ok {
			len++
		}
	}

	tst := make([]IExpressionListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionListElementContext); ok {
			tst[i] = t.(IExpressionListElementContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) ExpressionListElement(i int) IExpressionListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListElementContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ExpressionListContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ExpressionList(canSpread bool) (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState(), canSpread)
	p.EnterRule(localctx, 222, GroovyParserRULE_expressionList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1267)
		p.ExpressionListElement(localctx.(*ExpressionListContext).canSpread)
	}
	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1268)
				p.Match(GroovyParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1269)
				p.Nls()
			}
			{
				p.SetState(1270)
				p.ExpressionListElement(localctx.(*ExpressionListContext).canSpread)
			}

		}
		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListElementContext is an interface to support dynamic dispatch.
type IExpressionListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCanSpread returns the canSpread attribute.
	GetCanSpread() bool

	// SetCanSpread sets the canSpread attribute.
	SetCanSpread(bool)

	// Getter signatures
	Expression() IExpressionContext
	MUL() antlr.TerminalNode

	// IsExpressionListElementContext differentiates from other interfaces.
	IsExpressionListElementContext()
}

type ExpressionListElementContext struct {
	*GroovyParserRuleContext
	parser    antlr.Parser
	canSpread bool
}

func NewEmptyExpressionListElementContext() *ExpressionListElementContext {
	var p = new(ExpressionListElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_expressionListElement
	return p
}

func InitEmptyExpressionListElementContext(p *ExpressionListElementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_expressionListElement
}

func (*ExpressionListElementContext) IsExpressionListElementContext() {}

func NewExpressionListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, canSpread bool) *ExpressionListElementContext {
	var p = new(ExpressionListElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expressionListElement

	p.canSpread = canSpread

	return p
}

func (s *ExpressionListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListElementContext) GetCanSpread() bool { return s.canSpread }

func (s *ExpressionListElementContext) SetCanSpread(v bool) { s.canSpread = v }

func (s *ExpressionListElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListElementContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *ExpressionListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitExpressionListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ExpressionListElement(canSpread bool) (localctx IExpressionListElementContext) {
	localctx = NewExpressionListElementContext(p, p.GetParserRuleContext(), p.GetState(), canSpread)
	p.EnterRule(localctx, 224, GroovyParserRULE_expressionListElement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1277)
			p.Match(GroovyParserMUL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1280)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnhancedStatementExpressionContext is an interface to support dynamic dispatch.
type IEnhancedStatementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StatementExpression() IStatementExpressionContext
	StandardLambdaExpression() IStandardLambdaExpressionContext

	// IsEnhancedStatementExpressionContext differentiates from other interfaces.
	IsEnhancedStatementExpressionContext()
}

type EnhancedStatementExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedStatementExpressionContext() *EnhancedStatementExpressionContext {
	var p = new(EnhancedStatementExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enhancedStatementExpression
	return p
}

func InitEmptyEnhancedStatementExpressionContext(p *EnhancedStatementExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enhancedStatementExpression
}

func (*EnhancedStatementExpressionContext) IsEnhancedStatementExpressionContext() {}

func NewEnhancedStatementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedStatementExpressionContext {
	var p = new(EnhancedStatementExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedStatementExpression

	return p
}

func (s *EnhancedStatementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedStatementExpressionContext) StatementExpression() IStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *EnhancedStatementExpressionContext) StandardLambdaExpression() IStandardLambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardLambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardLambdaExpressionContext)
}

func (s *EnhancedStatementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedStatementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedStatementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitEnhancedStatementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) EnhancedStatementExpression() (localctx IEnhancedStatementExpressionContext) {
	localctx = NewEnhancedStatementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, GroovyParserRULE_enhancedStatementExpression)
	p.SetState(1284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1282)
			p.StatementExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1283)
			p.StandardLambdaExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementExpressionContext is an interface to support dynamic dispatch.
type IStatementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementExpressionContext differentiates from other interfaces.
	IsStatementExpressionContext()
}

type StatementExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementExpressionContext() *StatementExpressionContext {
	var p = new(StatementExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_statementExpression
	return p
}

func InitEmptyStatementExpressionContext(p *StatementExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_statementExpression
}

func (*StatementExpressionContext) IsStatementExpressionContext() {}

func NewStatementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementExpressionContext {
	var p = new(StatementExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_statementExpression

	return p
}

func (s *StatementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementExpressionContext) CopyAll(ctx *StatementExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CommandExprAltContext struct {
	StatementExpressionContext
}

func NewCommandExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommandExprAltContext {
	var p = new(CommandExprAltContext)

	InitEmptyStatementExpressionContext(&p.StatementExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementExpressionContext))

	return p
}

func (s *CommandExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandExprAltContext) CommandExpression() ICommandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandExpressionContext)
}

func (s *CommandExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCommandExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) StatementExpression() (localctx IStatementExpressionContext) {
	localctx = NewStatementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, GroovyParserRULE_statementExpression)
	localctx = NewCommandExprAltContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1286)
		p.CommandExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Getter signatures
	PathExpression() IPathExpressionContext
	INC() antlr.TerminalNode
	DEC() antlr.TerminalNode

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_postfixExpression
	return p
}

func InitEmptyPostfixExpressionContext(p *PostfixExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_postfixExpression
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) GetOp() antlr.Token { return s.op }

func (s *PostfixExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *PostfixExpressionContext) PathExpression() IPathExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathExpressionContext)
}

func (s *PostfixExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(GroovyParserINC, 0)
}

func (s *PostfixExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEC, 0)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitPostfixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) PostfixExpression() (localctx IPostfixExpressionContext) {
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, GroovyParserRULE_postfixExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1288)
		p.PathExpression()
	}
	p.SetState(1290)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1289)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PostfixExpressionContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserINC || _la == GroovyParserDEC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PostfixExpressionContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchExpressionContext is an interface to support dynamic dispatch.
type ISwitchExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	ExpressionInPar() IExpressionInParContext
	AllNls() []INlsContext
	Nls(i int) INlsContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllSwitchBlockStatementExpressionGroup() []ISwitchBlockStatementExpressionGroupContext
	SwitchBlockStatementExpressionGroup(i int) ISwitchBlockStatementExpressionGroupContext

	// IsSwitchExpressionContext differentiates from other interfaces.
	IsSwitchExpressionContext()
}

type SwitchExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchExpressionContext() *SwitchExpressionContext {
	var p = new(SwitchExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchExpression
	return p
}

func InitEmptySwitchExpressionContext(p *SwitchExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchExpression
}

func (*SwitchExpressionContext) IsSwitchExpressionContext() {}

func NewSwitchExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchExpressionContext {
	var p = new(SwitchExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchExpression

	return p
}

func (s *SwitchExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchExpressionContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserSWITCH, 0)
}

func (s *SwitchExpressionContext) ExpressionInPar() IExpressionInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *SwitchExpressionContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *SwitchExpressionContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SwitchExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *SwitchExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *SwitchExpressionContext) AllSwitchBlockStatementExpressionGroup() []ISwitchBlockStatementExpressionGroupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchBlockStatementExpressionGroupContext); ok {
			len++
		}
	}

	tst := make([]ISwitchBlockStatementExpressionGroupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchBlockStatementExpressionGroupContext); ok {
			tst[i] = t.(ISwitchBlockStatementExpressionGroupContext)
			i++
		}
	}

	return tst
}

func (s *SwitchExpressionContext) SwitchBlockStatementExpressionGroup(i int) ISwitchBlockStatementExpressionGroupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchBlockStatementExpressionGroupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockStatementExpressionGroupContext)
}

func (s *SwitchExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitSwitchExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) SwitchExpression() (localctx ISwitchExpressionContext) {
	localctx = NewSwitchExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, GroovyParserRULE_switchExpression)

	p.inSwitchExpressionLevel++

	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1292)
		p.Match(GroovyParserSWITCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1293)
		p.ExpressionInPar()
	}
	{
		p.SetState(1294)
		p.Nls()
	}
	{
		p.SetState(1295)
		p.Match(GroovyParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1296)
		p.Nls()
	}
	p.SetState(1300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCASE || _la == GroovyParserDEFAULT {
		{
			p.SetState(1297)
			p.SwitchBlockStatementExpressionGroup()
		}

		p.SetState(1302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1303)
		p.Nls()
	}
	{
		p.SetState(1304)
		p.Match(GroovyParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))

	p.inSwitchExpressionLevel--

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchBlockStatementExpressionGroupContext is an interface to support dynamic dispatch.
type ISwitchBlockStatementExpressionGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockStatements() IBlockStatementsContext
	AllSwitchExpressionLabel() []ISwitchExpressionLabelContext
	SwitchExpressionLabel(i int) ISwitchExpressionLabelContext
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsSwitchBlockStatementExpressionGroupContext differentiates from other interfaces.
	IsSwitchBlockStatementExpressionGroupContext()
}

type SwitchBlockStatementExpressionGroupContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockStatementExpressionGroupContext() *SwitchBlockStatementExpressionGroupContext {
	var p = new(SwitchBlockStatementExpressionGroupContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchBlockStatementExpressionGroup
	return p
}

func InitEmptySwitchBlockStatementExpressionGroupContext(p *SwitchBlockStatementExpressionGroupContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchBlockStatementExpressionGroup
}

func (*SwitchBlockStatementExpressionGroupContext) IsSwitchBlockStatementExpressionGroupContext() {}

func NewSwitchBlockStatementExpressionGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockStatementExpressionGroupContext {
	var p = new(SwitchBlockStatementExpressionGroupContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchBlockStatementExpressionGroup

	return p
}

func (s *SwitchBlockStatementExpressionGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockStatementExpressionGroupContext) BlockStatements() IBlockStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *SwitchBlockStatementExpressionGroupContext) AllSwitchExpressionLabel() []ISwitchExpressionLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchExpressionLabelContext); ok {
			len++
		}
	}

	tst := make([]ISwitchExpressionLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchExpressionLabelContext); ok {
			tst[i] = t.(ISwitchExpressionLabelContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementExpressionGroupContext) SwitchExpressionLabel(i int) ISwitchExpressionLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchExpressionLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchExpressionLabelContext)
}

func (s *SwitchBlockStatementExpressionGroupContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementExpressionGroupContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SwitchBlockStatementExpressionGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockStatementExpressionGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockStatementExpressionGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitSwitchBlockStatementExpressionGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) SwitchBlockStatementExpressionGroup() (localctx ISwitchBlockStatementExpressionGroupContext) {
	localctx = NewSwitchBlockStatementExpressionGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, GroovyParserRULE_switchBlockStatementExpressionGroup)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1306)
				p.SwitchExpressionLabel()
			}
			{
				p.SetState(1307)
				p.Nls()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1311)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1313)
		p.BlockStatements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchExpressionLabelContext is an interface to support dynamic dispatch.
type ISwitchExpressionLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAc returns the ac token.
	GetAc() antlr.Token

	// SetAc sets the ac token.
	SetAc(antlr.Token)

	// Getter signatures
	CASE() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	DEFAULT() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	COLON() antlr.TerminalNode

	// IsSwitchExpressionLabelContext differentiates from other interfaces.
	IsSwitchExpressionLabelContext()
}

type SwitchExpressionLabelContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	ac     antlr.Token
}

func NewEmptySwitchExpressionLabelContext() *SwitchExpressionLabelContext {
	var p = new(SwitchExpressionLabelContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchExpressionLabel
	return p
}

func InitEmptySwitchExpressionLabelContext(p *SwitchExpressionLabelContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_switchExpressionLabel
}

func (*SwitchExpressionLabelContext) IsSwitchExpressionLabelContext() {}

func NewSwitchExpressionLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchExpressionLabelContext {
	var p = new(SwitchExpressionLabelContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchExpressionLabel

	return p
}

func (s *SwitchExpressionLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchExpressionLabelContext) GetAc() antlr.Token { return s.ac }

func (s *SwitchExpressionLabelContext) SetAc(v antlr.Token) { s.ac = v }

func (s *SwitchExpressionLabelContext) CASE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCASE, 0)
}

func (s *SwitchExpressionLabelContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *SwitchExpressionLabelContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *SwitchExpressionLabelContext) ARROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserARROW, 0)
}

func (s *SwitchExpressionLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *SwitchExpressionLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchExpressionLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchExpressionLabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitSwitchExpressionLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) SwitchExpressionLabel() (localctx ISwitchExpressionLabelContext) {
	localctx = NewSwitchExpressionLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, GroovyParserRULE_switchExpressionLabel)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserCASE:
		{
			p.SetState(1315)
			p.Match(GroovyParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1316)
			p.ExpressionList(true)
		}

	case GroovyParserDEFAULT:
		{
			p.SetState(1317)
			p.Match(GroovyParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1320)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SwitchExpressionLabelContext).ac = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == GroovyParserARROW || _la == GroovyParserCOLON) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SwitchExpressionLabelContext).ac = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PostfixExprAltContext struct {
	ExpressionContext
}

func NewPostfixExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixExprAltContext {
	var p = new(PostfixExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PostfixExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprAltContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostfixExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitPostfixExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryNotExprAltContext struct {
	ExpressionContext
}

func NewUnaryNotExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryNotExprAltContext {
	var p = new(UnaryNotExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryNotExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryNotExprAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *UnaryNotExprAltContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryNotExprAltContext) BITNOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITNOT, 0)
}

func (s *UnaryNotExprAltContext) NOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT, 0)
}

func (s *UnaryNotExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitUnaryNotExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShiftExprAltContext struct {
	ExpressionContext
	left    IExpressionContext
	dlOp    antlr.Token
	tgOp    antlr.Token
	dgOp    antlr.Token
	rangeOp antlr.Token
	right   IExpressionContext
}

func NewShiftExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShiftExprAltContext {
	var p = new(ShiftExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ShiftExprAltContext) GetDlOp() antlr.Token { return s.dlOp }

func (s *ShiftExprAltContext) GetTgOp() antlr.Token { return s.tgOp }

func (s *ShiftExprAltContext) GetDgOp() antlr.Token { return s.dgOp }

func (s *ShiftExprAltContext) GetRangeOp() antlr.Token { return s.rangeOp }

func (s *ShiftExprAltContext) SetDlOp(v antlr.Token) { s.dlOp = v }

func (s *ShiftExprAltContext) SetTgOp(v antlr.Token) { s.tgOp = v }

func (s *ShiftExprAltContext) SetDgOp(v antlr.Token) { s.dgOp = v }

func (s *ShiftExprAltContext) SetRangeOp(v antlr.Token) { s.rangeOp = v }

func (s *ShiftExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *ShiftExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *ShiftExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *ShiftExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *ShiftExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ShiftExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ShiftExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ShiftExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShiftExprAltContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserLT)
}

func (s *ShiftExprAltContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, i)
}

func (s *ShiftExprAltContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserGT)
}

func (s *ShiftExprAltContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, i)
}

func (s *ShiftExprAltContext) RANGE_INCLUSIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRANGE_INCLUSIVE, 0)
}

func (s *ShiftExprAltContext) RANGE_EXCLUSIVE_LEFT() antlr.TerminalNode {
	return s.GetToken(GroovyParserRANGE_EXCLUSIVE_LEFT, 0)
}

func (s *ShiftExprAltContext) RANGE_EXCLUSIVE_RIGHT() antlr.TerminalNode {
	return s.GetToken(GroovyParserRANGE_EXCLUSIVE_RIGHT, 0)
}

func (s *ShiftExprAltContext) RANGE_EXCLUSIVE_FULL() antlr.TerminalNode {
	return s.GetToken(GroovyParserRANGE_EXCLUSIVE_FULL, 0)
}

func (s *ShiftExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitShiftExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ImplicationExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewImplicationExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImplicationExprAltContext {
	var p = new(ImplicationExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ImplicationExprAltContext) GetOp() antlr.Token { return s.op }

func (s *ImplicationExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *ImplicationExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *ImplicationExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *ImplicationExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *ImplicationExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *ImplicationExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplicationExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ImplicationExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ImplicationExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ImplicationExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ImplicationExprAltContext) IMPLIES() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPLIES, 0)
}

func (s *ImplicationExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitImplicationExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastExprAltContext struct {
	ExpressionContext
}

func NewCastExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExprAltContext {
	var p = new(CastExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CastExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprAltContext) CastParExpression() ICastParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastParExpressionContext)
}

func (s *CastExprAltContext) CastOperandExpression() ICastOperandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *CastExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCastExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type SwitchExprAltContext struct {
	ExpressionContext
}

func NewSwitchExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SwitchExprAltContext {
	var p = new(SwitchExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *SwitchExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchExprAltContext) SwitchExpression() ISwitchExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchExpressionContext)
}

func (s *SwitchExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitSwitchExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultipleAssignmentExprAltContext struct {
	ExpressionContext
	left  IVariableNamesContext
	op    antlr.Token
	right IStatementExpressionContext
}

func NewMultipleAssignmentExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleAssignmentExprAltContext {
	var p = new(MultipleAssignmentExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MultipleAssignmentExprAltContext) GetOp() antlr.Token { return s.op }

func (s *MultipleAssignmentExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultipleAssignmentExprAltContext) GetLeft() IVariableNamesContext { return s.left }

func (s *MultipleAssignmentExprAltContext) GetRight() IStatementExpressionContext { return s.right }

func (s *MultipleAssignmentExprAltContext) SetLeft(v IVariableNamesContext) { s.left = v }

func (s *MultipleAssignmentExprAltContext) SetRight(v IStatementExpressionContext) { s.right = v }

func (s *MultipleAssignmentExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleAssignmentExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *MultipleAssignmentExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MultipleAssignmentExprAltContext) VariableNames() IVariableNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNamesContext)
}

func (s *MultipleAssignmentExprAltContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *MultipleAssignmentExprAltContext) StatementExpression() IStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *MultipleAssignmentExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMultipleAssignmentExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExclusiveOrExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewExclusiveOrExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExclusiveOrExprAltContext {
	var p = new(ExclusiveOrExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ExclusiveOrExprAltContext) GetOp() antlr.Token { return s.op }

func (s *ExclusiveOrExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExclusiveOrExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *ExclusiveOrExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *ExclusiveOrExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *ExclusiveOrExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *ExclusiveOrExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusiveOrExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ExclusiveOrExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ExclusiveOrExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExclusiveOrExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExclusiveOrExprAltContext) XOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserXOR, 0)
}

func (s *ExclusiveOrExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitExclusiveOrExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdditiveExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewAdditiveExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExprAltContext {
	var p = new(AdditiveExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AdditiveExprAltContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *AdditiveExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *AdditiveExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *AdditiveExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *AdditiveExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AdditiveExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AdditiveExprAltContext) ADD() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD, 0)
}

func (s *AdditiveExprAltContext) SUB() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB, 0)
}

func (s *AdditiveExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitAdditiveExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type RegexExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewRegexExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexExprAltContext {
	var p = new(RegexExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *RegexExprAltContext) GetOp() antlr.Token { return s.op }

func (s *RegexExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *RegexExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *RegexExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *RegexExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *RegexExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *RegexExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *RegexExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *RegexExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RegexExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RegexExprAltContext) REGEX_FIND() antlr.TerminalNode {
	return s.GetToken(GroovyParserREGEX_FIND, 0)
}

func (s *RegexExprAltContext) REGEX_MATCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserREGEX_MATCH, 0)
}

func (s *RegexExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitRegexExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConditionalExprAltContext struct {
	ExpressionContext
	con IExpressionContext
	tb  IExpressionContext
	fb  IExpressionContext
}

func NewConditionalExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConditionalExprAltContext {
	var p = new(ConditionalExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ConditionalExprAltContext) GetCon() IExpressionContext { return s.con }

func (s *ConditionalExprAltContext) GetTb() IExpressionContext { return s.tb }

func (s *ConditionalExprAltContext) GetFb() IExpressionContext { return s.fb }

func (s *ConditionalExprAltContext) SetCon(v IExpressionContext) { s.con = v }

func (s *ConditionalExprAltContext) SetTb(v IExpressionContext) { s.tb = v }

func (s *ConditionalExprAltContext) SetFb(v IExpressionContext) { s.fb = v }

func (s *ConditionalExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ConditionalExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ConditionalExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConditionalExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalExprAltContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(GroovyParserQUESTION, 0)
}

func (s *ConditionalExprAltContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *ConditionalExprAltContext) ELVIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserELVIS, 0)
}

func (s *ConditionalExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitConditionalExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type PowerExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewPowerExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExprAltContext {
	var p = new(PowerExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PowerExprAltContext) GetOp() antlr.Token { return s.op }

func (s *PowerExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *PowerExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *PowerExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *PowerExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *PowerExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *PowerExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExprAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *PowerExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PowerExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PowerExprAltContext) POWER() antlr.TerminalNode {
	return s.GetToken(GroovyParserPOWER, 0)
}

func (s *PowerExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitPowerExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationalExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewRelationalExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalExprAltContext {
	var p = new(RelationalExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *RelationalExprAltContext) GetOp() antlr.Token { return s.op }

func (s *RelationalExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *RelationalExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *RelationalExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *RelationalExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *RelationalExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *RelationalExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *RelationalExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RelationalExprAltContext) LE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLE, 0)
}

func (s *RelationalExprAltContext) GE() antlr.TerminalNode {
	return s.GetToken(GroovyParserGE, 0)
}

func (s *RelationalExprAltContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *RelationalExprAltContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *RelationalExprAltContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *RelationalExprAltContext) NOT_IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT_IN, 0)
}

func (s *RelationalExprAltContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *RelationalExprAltContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *RelationalExprAltContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserINSTANCEOF, 0)
}

func (s *RelationalExprAltContext) NOT_INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT_INSTANCEOF, 0)
}

func (s *RelationalExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitRelationalExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalAndExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewLogicalAndExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExprAltContext {
	var p = new(LogicalAndExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalAndExprAltContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *LogicalAndExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalAndExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *LogicalAndExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalAndExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LogicalAndExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalAndExprAltContext) AND() antlr.TerminalNode {
	return s.GetToken(GroovyParserAND, 0)
}

func (s *LogicalAndExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLogicalAndExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IEnhancedStatementExpressionContext
}

func NewAssignmentExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExprAltContext {
	var p = new(AssignmentExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AssignmentExprAltContext) GetOp() antlr.Token { return s.op }

func (s *AssignmentExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignmentExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *AssignmentExprAltContext) GetRight() IEnhancedStatementExpressionContext { return s.right }

func (s *AssignmentExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *AssignmentExprAltContext) SetRight(v IEnhancedStatementExpressionContext) { s.right = v }

func (s *AssignmentExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AssignmentExprAltContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentExprAltContext) EnhancedStatementExpression() IEnhancedStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedStatementExpressionContext)
}

func (s *AssignmentExprAltContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *AssignmentExprAltContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserDIV_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserAND_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserOR_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserXOR_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRSHIFT_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) URSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserURSHIFT_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLSHIFT_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserMOD_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) POWER_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserPOWER_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) ELVIS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserELVIS_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitAssignmentExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryAddExprAltContext struct {
	ExpressionContext
	op antlr.Token
}

func NewUnaryAddExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryAddExprAltContext {
	var p = new(UnaryAddExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryAddExprAltContext) GetOp() antlr.Token { return s.op }

func (s *UnaryAddExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryAddExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAddExprAltContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryAddExprAltContext) INC() antlr.TerminalNode {
	return s.GetToken(GroovyParserINC, 0)
}

func (s *UnaryAddExprAltContext) DEC() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEC, 0)
}

func (s *UnaryAddExprAltContext) ADD() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD, 0)
}

func (s *UnaryAddExprAltContext) SUB() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB, 0)
}

func (s *UnaryAddExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitUnaryAddExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiplicativeExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewMultiplicativeExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExprAltContext {
	var p = new(MultiplicativeExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MultiplicativeExprAltContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *MultiplicativeExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *MultiplicativeExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *MultiplicativeExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *MultiplicativeExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MultiplicativeExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiplicativeExprAltContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *MultiplicativeExprAltContext) DIV() antlr.TerminalNode {
	return s.GetToken(GroovyParserDIV, 0)
}

func (s *MultiplicativeExprAltContext) MOD() antlr.TerminalNode {
	return s.GetToken(GroovyParserMOD, 0)
}

func (s *MultiplicativeExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMultiplicativeExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type InclusiveOrExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewInclusiveOrExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InclusiveOrExprAltContext {
	var p = new(InclusiveOrExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *InclusiveOrExprAltContext) GetOp() antlr.Token { return s.op }

func (s *InclusiveOrExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *InclusiveOrExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *InclusiveOrExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *InclusiveOrExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *InclusiveOrExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *InclusiveOrExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InclusiveOrExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *InclusiveOrExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *InclusiveOrExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InclusiveOrExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InclusiveOrExprAltContext) BITOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITOR, 0)
}

func (s *InclusiveOrExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitInclusiveOrExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalOrExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewLogicalOrExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExprAltContext {
	var p = new(LogicalOrExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalOrExprAltContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *LogicalOrExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalOrExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *LogicalOrExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalOrExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LogicalOrExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalOrExprAltContext) OR() antlr.TerminalNode {
	return s.GetToken(GroovyParserOR, 0)
}

func (s *LogicalOrExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLogicalOrExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type EqualityExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewEqualityExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExprAltContext {
	var p = new(EqualityExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityExprAltContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *EqualityExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *EqualityExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *EqualityExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *EqualityExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *EqualityExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EqualityExprAltContext) IDENTICAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserIDENTICAL, 0)
}

func (s *EqualityExprAltContext) NOT_IDENTICAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT_IDENTICAL, 0)
}

func (s *EqualityExprAltContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserEQUAL, 0)
}

func (s *EqualityExprAltContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOTEQUAL, 0)
}

func (s *EqualityExprAltContext) SPACESHIP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSPACESHIP, 0)
}

func (s *EqualityExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitEqualityExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type AndExprAltContext struct {
	ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewAndExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AndExprAltContext {
	var p = new(AndExprAltContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AndExprAltContext) GetOp() antlr.Token { return s.op }

func (s *AndExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *AndExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *AndExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *AndExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *AndExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *AndExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExprAltContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *AndExprAltContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AndExprAltContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndExprAltContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AndExprAltContext) BITAND() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITAND, 0)
}

func (s *AndExprAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitAndExprAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *GroovyParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 238
	p.EnterRecursionRule(localctx, 238, GroovyParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCastExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1323)
			p.CastParExpression()
		}
		{
			p.SetState(1324)
			p.CastOperandExpression()
		}

	case 2:
		localctx = NewPostfixExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1326)
			p.PostfixExpression()
		}

	case 3:
		localctx = NewSwitchExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1327)
			p.SwitchExpression()
		}

	case 4:
		localctx = NewUnaryNotExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1328)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserNOT || _la == GroovyParserBITNOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1329)
			p.Nls()
		}
		{
			p.SetState(1330)
			p.expression(19)
		}

	case 5:
		localctx = NewUnaryAddExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1332)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryAddExprAltContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&15) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryAddExprAltContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1333)
			p.expression(17)
		}

	case 6:
		localctx = NewMultipleAssignmentExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1334)

			var _x = p.VariableNames()

			localctx.(*MultipleAssignmentExprAltContext).left = _x
		}
		{
			p.SetState(1335)
			p.Nls()
		}
		{
			p.SetState(1336)

			var _m = p.Match(GroovyParserASSIGN)

			localctx.(*MultipleAssignmentExprAltContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1337)
			p.Nls()
		}
		{
			p.SetState(1338)

			var _x = p.StatementExpression()

			localctx.(*MultipleAssignmentExprAltContext).right = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1456)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*PowerExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1342)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(1343)

					var _m = p.Match(GroovyParserPOWER)

					localctx.(*PowerExprAltContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1344)
					p.Nls()
				}
				{
					p.SetState(1345)

					var _x = p.expression(19)

					localctx.(*PowerExprAltContext).right = _x
				}

			case 2:
				localctx = NewMultiplicativeExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*MultiplicativeExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1347)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(1348)
					p.Nls()
				}
				{
					p.SetState(1349)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*MultiplicativeExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&35) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*MultiplicativeExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1350)
					p.Nls()
				}
				{
					p.SetState(1351)

					var _x = p.expression(17)

					localctx.(*MultiplicativeExprAltContext).right = _x
				}

			case 3:
				localctx = NewAdditiveExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*AdditiveExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1353)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(1354)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AdditiveExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserADD || _la == GroovyParserSUB) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AdditiveExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1355)
					p.Nls()
				}
				{
					p.SetState(1356)

					var _x = p.expression(16)

					localctx.(*AdditiveExprAltContext).right = _x
				}

			case 4:
				localctx = NewShiftExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*ShiftExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1358)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(1359)
					p.Nls()
				}
				p.SetState(1370)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case GroovyParserGT, GroovyParserLT:
					p.SetState(1367)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}

					switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) {
					case 1:
						{
							p.SetState(1360)

							var _m = p.Match(GroovyParserLT)

							localctx.(*ShiftExprAltContext).dlOp = _m
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1361)
							p.Match(GroovyParserLT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					case 2:
						{
							p.SetState(1362)

							var _m = p.Match(GroovyParserGT)

							localctx.(*ShiftExprAltContext).tgOp = _m
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1363)
							p.Match(GroovyParserGT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1364)
							p.Match(GroovyParserGT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					case 3:
						{
							p.SetState(1365)

							var _m = p.Match(GroovyParserGT)

							localctx.(*ShiftExprAltContext).dgOp = _m
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1366)
							p.Match(GroovyParserGT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					case antlr.ATNInvalidAltNumber:
						goto errorExit
					}

				case GroovyParserRANGE_INCLUSIVE, GroovyParserRANGE_EXCLUSIVE_LEFT, GroovyParserRANGE_EXCLUSIVE_RIGHT, GroovyParserRANGE_EXCLUSIVE_FULL:
					{
						p.SetState(1369)

						var _lt = p.GetTokenStream().LT(1)

						localctx.(*ShiftExprAltContext).rangeOp = _lt

						_la = p.GetTokenStream().LA(1)

						if !((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&15) != 0) {
							var _ri = p.GetErrorHandler().RecoverInline(p)

							localctx.(*ShiftExprAltContext).rangeOp = _ri
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}
				{
					p.SetState(1372)
					p.Nls()
				}
				{
					p.SetState(1373)

					var _x = p.expression(15)

					localctx.(*ShiftExprAltContext).right = _x
				}

			case 5:
				localctx = NewRelationalExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*RelationalExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1375)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(1376)
					p.Nls()
				}
				{
					p.SetState(1377)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RelationalExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserIN || ((int64((_la-86)) & ^0x3f) == 0 && ((int64(1)<<(_la-86))&792577) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RelationalExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1378)
					p.Nls()
				}
				{
					p.SetState(1379)

					var _x = p.expression(13)

					localctx.(*RelationalExprAltContext).right = _x
				}

			case 6:
				localctx = NewEqualityExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*EqualityExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1381)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(1382)
					p.Nls()
				}
				{
					p.SetState(1383)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*EqualityExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&75497483) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*EqualityExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1384)
					p.Nls()
				}
				{
					p.SetState(1385)

					var _x = p.expression(12)

					localctx.(*EqualityExprAltContext).right = _x
				}

			case 7:
				localctx = NewRegexExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*RegexExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1387)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(1388)
					p.Nls()
				}
				{
					p.SetState(1389)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RegexExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserREGEX_FIND || _la == GroovyParserREGEX_MATCH) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RegexExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1390)
					p.Nls()
				}
				{
					p.SetState(1391)

					var _x = p.expression(11)

					localctx.(*RegexExprAltContext).right = _x
				}

			case 8:
				localctx = NewAndExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*AndExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1393)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(1394)
					p.Nls()
				}
				{
					p.SetState(1395)

					var _m = p.Match(GroovyParserBITAND)

					localctx.(*AndExprAltContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1396)
					p.Nls()
				}
				{
					p.SetState(1397)

					var _x = p.expression(10)

					localctx.(*AndExprAltContext).right = _x
				}

			case 9:
				localctx = NewExclusiveOrExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*ExclusiveOrExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1399)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(1400)
					p.Nls()
				}
				{
					p.SetState(1401)

					var _m = p.Match(GroovyParserXOR)

					localctx.(*ExclusiveOrExprAltContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1402)
					p.Nls()
				}
				{
					p.SetState(1403)

					var _x = p.expression(9)

					localctx.(*ExclusiveOrExprAltContext).right = _x
				}

			case 10:
				localctx = NewInclusiveOrExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*InclusiveOrExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1405)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(1406)
					p.Nls()
				}
				{
					p.SetState(1407)

					var _m = p.Match(GroovyParserBITOR)

					localctx.(*InclusiveOrExprAltContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1408)
					p.Nls()
				}
				{
					p.SetState(1409)

					var _x = p.expression(8)

					localctx.(*InclusiveOrExprAltContext).right = _x
				}

			case 11:
				localctx = NewLogicalAndExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalAndExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1411)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1412)
					p.Nls()
				}
				{
					p.SetState(1413)

					var _m = p.Match(GroovyParserAND)

					localctx.(*LogicalAndExprAltContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1414)
					p.Nls()
				}
				{
					p.SetState(1415)

					var _x = p.expression(7)

					localctx.(*LogicalAndExprAltContext).right = _x
				}

			case 12:
				localctx = NewLogicalOrExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalOrExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1417)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1418)
					p.Nls()
				}
				{
					p.SetState(1419)

					var _m = p.Match(GroovyParserOR)

					localctx.(*LogicalOrExprAltContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1420)
					p.Nls()
				}
				{
					p.SetState(1421)

					var _x = p.expression(6)

					localctx.(*LogicalOrExprAltContext).right = _x
				}

			case 13:
				localctx = NewImplicationExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*ImplicationExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1423)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(1424)
					p.Nls()
				}
				{
					p.SetState(1425)

					var _m = p.Match(GroovyParserIMPLIES)

					localctx.(*ImplicationExprAltContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1426)
					p.Nls()
				}
				{
					p.SetState(1427)

					var _x = p.expression(4)

					localctx.(*ImplicationExprAltContext).right = _x
				}

			case 14:
				localctx = NewConditionalExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConditionalExprAltContext).con = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1429)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1430)
					p.Nls()
				}
				p.SetState(1440)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case GroovyParserQUESTION:
					{
						p.SetState(1431)
						p.Match(GroovyParserQUESTION)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1432)
						p.Nls()
					}
					{
						p.SetState(1433)

						var _x = p.expression(0)

						localctx.(*ConditionalExprAltContext).tb = _x
					}
					{
						p.SetState(1434)
						p.Nls()
					}
					{
						p.SetState(1435)
						p.Match(GroovyParserCOLON)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1436)
						p.Nls()
					}

				case GroovyParserELVIS:
					{
						p.SetState(1438)
						p.Match(GroovyParserELVIS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1439)
						p.Nls()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}
				{
					p.SetState(1442)

					var _x = p.expression(3)

					localctx.(*ConditionalExprAltContext).fb = _x
				}

			case 15:
				localctx = NewRelationalExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*RelationalExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1444)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(1445)
					p.Nls()
				}
				{
					p.SetState(1446)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RelationalExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserAS || _la == GroovyParserINSTANCEOF || _la == GroovyParserNOT_INSTANCEOF) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RelationalExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1447)
					p.Nls()
				}
				{
					p.SetState(1448)
					p.Type_()
				}

			case 16:
				localctx = NewAssignmentExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*AssignmentExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1450)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1451)
					p.Nls()
				}
				{
					p.SetState(1452)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AssignmentExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&4502500115873793) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AssignmentExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1453)
					p.Nls()
				}
				{
					p.SetState(1454)

					var _x = p.EnhancedStatementExpression()

					localctx.(*AssignmentExprAltContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastOperandExpressionContext is an interface to support dynamic dispatch.
type ICastOperandExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCastOperandExpressionContext differentiates from other interfaces.
	IsCastOperandExpressionContext()
}

type CastOperandExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastOperandExpressionContext() *CastOperandExpressionContext {
	var p = new(CastOperandExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_castOperandExpression
	return p
}

func InitEmptyCastOperandExpressionContext(p *CastOperandExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_castOperandExpression
}

func (*CastOperandExpressionContext) IsCastOperandExpressionContext() {}

func NewCastOperandExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastOperandExpressionContext {
	var p = new(CastOperandExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_castOperandExpression

	return p
}

func (s *CastOperandExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastOperandExpressionContext) CopyAll(ctx *CastOperandExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CastOperandExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastOperandExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnaryNotExprAltOperandContext struct {
	CastOperandExpressionContext
}

func NewUnaryNotExprAltOperandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryNotExprAltOperandContext {
	var p = new(UnaryNotExprAltOperandContext)

	InitEmptyCastOperandExpressionContext(&p.CastOperandExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *UnaryNotExprAltOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryNotExprAltOperandContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *UnaryNotExprAltOperandContext) CastOperandExpression() ICastOperandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *UnaryNotExprAltOperandContext) BITNOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITNOT, 0)
}

func (s *UnaryNotExprAltOperandContext) NOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT, 0)
}

func (s *UnaryNotExprAltOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitUnaryNotExprAltOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryAddExprAltOperandContext struct {
	CastOperandExpressionContext
	op antlr.Token
}

func NewUnaryAddExprAltOperandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryAddExprAltOperandContext {
	var p = new(UnaryAddExprAltOperandContext)

	InitEmptyCastOperandExpressionContext(&p.CastOperandExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *UnaryAddExprAltOperandContext) GetOp() antlr.Token { return s.op }

func (s *UnaryAddExprAltOperandContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryAddExprAltOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAddExprAltOperandContext) CastOperandExpression() ICastOperandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *UnaryAddExprAltOperandContext) INC() antlr.TerminalNode {
	return s.GetToken(GroovyParserINC, 0)
}

func (s *UnaryAddExprAltOperandContext) DEC() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEC, 0)
}

func (s *UnaryAddExprAltOperandContext) ADD() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD, 0)
}

func (s *UnaryAddExprAltOperandContext) SUB() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB, 0)
}

func (s *UnaryAddExprAltOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitUnaryAddExprAltOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostfixExprAltOperandContext struct {
	CastOperandExpressionContext
}

func NewPostfixExprAltOperandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixExprAltOperandContext {
	var p = new(PostfixExprAltOperandContext)

	InitEmptyCastOperandExpressionContext(&p.CastOperandExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *PostfixExprAltOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprAltOperandContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostfixExprAltOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitPostfixExprAltOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastExprAltOperandContext struct {
	CastOperandExpressionContext
}

func NewCastExprAltOperandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExprAltOperandContext {
	var p = new(CastExprAltOperandContext)

	InitEmptyCastOperandExpressionContext(&p.CastOperandExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *CastExprAltOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprAltOperandContext) CastParExpression() ICastParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastParExpressionContext)
}

func (s *CastExprAltOperandContext) CastOperandExpression() ICastOperandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *CastExprAltOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCastExprAltOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) CastOperandExpression() (localctx ICastOperandExpressionContext) {
	localctx = NewCastOperandExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, GroovyParserRULE_castOperandExpression)
	var _la int

	p.SetState(1471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCastExprAltOperandContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1461)
			p.CastParExpression()
		}
		{
			p.SetState(1462)
			p.CastOperandExpression()
		}

	case 2:
		localctx = NewPostfixExprAltOperandContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1464)
			p.PostfixExpression()
		}

	case 3:
		localctx = NewUnaryNotExprAltOperandContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1465)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserNOT || _la == GroovyParserBITNOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1466)
			p.Nls()
		}
		{
			p.SetState(1467)
			p.CastOperandExpression()
		}

	case 4:
		localctx = NewUnaryAddExprAltOperandContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1469)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryAddExprAltOperandContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&15) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryAddExprAltOperandContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1470)
			p.CastOperandExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommandExpressionContext is an interface to support dynamic dispatch.
type ICommandExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	ArgumentList() IArgumentListContext
	AllCommandArgument() []ICommandArgumentContext
	CommandArgument(i int) ICommandArgumentContext

	// IsCommandExpressionContext differentiates from other interfaces.
	IsCommandExpressionContext()
}

type CommandExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandExpressionContext() *CommandExpressionContext {
	var p = new(CommandExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_commandExpression
	return p
}

func InitEmptyCommandExpressionContext(p *CommandExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_commandExpression
}

func (*CommandExpressionContext) IsCommandExpressionContext() {}

func NewCommandExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandExpressionContext {
	var p = new(CommandExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_commandExpression

	return p
}

func (s *CommandExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CommandExpressionContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *CommandExpressionContext) AllCommandArgument() []ICommandArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommandArgumentContext); ok {
			len++
		}
	}

	tst := make([]ICommandArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommandArgumentContext); ok {
			tst[i] = t.(ICommandArgumentContext)
			i++
		}
	}

	return tst
}

func (s *CommandExpressionContext) CommandArgument(i int) ICommandArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandArgumentContext)
}

func (s *CommandExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCommandExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) CommandExpression() (localctx ICommandExpressionContext) {
	localctx = NewCommandExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, GroovyParserRULE_commandExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		p.expression(0)
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1474)

		if !(!isFollowingArgumentsOrClosure()) {
			p.SetError(antlr.NewFailedPredicateException(p, " !isFollowingArgumentsOrClosure() ", ""))
			goto errorExit
		}
		{
			p.SetState(1475)
			p.ArgumentList()
		}

	case 2:

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1479)
				p.CommandArgument()
			}

		}
		p.SetState(1484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommandArgumentContext is an interface to support dynamic dispatch.
type ICommandArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommandPrimary() ICommandPrimaryContext
	ArgumentList() IArgumentListContext
	AllPathElement() []IPathElementContext
	PathElement(i int) IPathElementContext

	// IsCommandArgumentContext differentiates from other interfaces.
	IsCommandArgumentContext()
}

type CommandArgumentContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandArgumentContext() *CommandArgumentContext {
	var p = new(CommandArgumentContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_commandArgument
	return p
}

func InitEmptyCommandArgumentContext(p *CommandArgumentContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_commandArgument
}

func (*CommandArgumentContext) IsCommandArgumentContext() {}

func NewCommandArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandArgumentContext {
	var p = new(CommandArgumentContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_commandArgument

	return p
}

func (s *CommandArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandArgumentContext) CommandPrimary() ICommandPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandPrimaryContext)
}

func (s *CommandArgumentContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *CommandArgumentContext) AllPathElement() []IPathElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathElementContext); ok {
			len++
		}
	}

	tst := make([]IPathElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathElementContext); ok {
			tst[i] = t.(IPathElementContext)
			i++
		}
	}

	return tst
}

func (s *CommandArgumentContext) PathElement(i int) IPathElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathElementContext)
}

func (s *CommandArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCommandArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) CommandArgument() (localctx ICommandArgumentContext) {
	localctx = NewCommandArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, GroovyParserRULE_commandArgument)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1485)
		p.CommandPrimary()
	}
	p.SetState(1492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1486)
					p.PathElement()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1489)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(1491)
			p.ArgumentList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathExpressionContext is an interface to support dynamic dispatch.
type IPathExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_pathElement returns the _pathElement rule contexts.
	Get_pathElement() IPathElementContext

	// Set_pathElement sets the _pathElement rule contexts.
	Set_pathElement(IPathElementContext)

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// Getter signatures
	Primary() IPrimaryContext
	STATIC() antlr.TerminalNode
	AllPathElement() []IPathElementContext
	PathElement(i int) IPathElementContext

	// IsPathExpressionContext differentiates from other interfaces.
	IsPathExpressionContext()
}

type PathExpressionContext struct {
	*GroovyParserRuleContext
	parser       antlr.Parser
	t            int
	_pathElement IPathElementContext
}

func NewEmptyPathExpressionContext() *PathExpressionContext {
	var p = new(PathExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_pathExpression
	return p
}

func InitEmptyPathExpressionContext(p *PathExpressionContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_pathExpression
}

func (*PathExpressionContext) IsPathExpressionContext() {}

func NewPathExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathExpressionContext {
	var p = new(PathExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_pathExpression

	return p
}

func (s *PathExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PathExpressionContext) Get_pathElement() IPathElementContext { return s._pathElement }

func (s *PathExpressionContext) Set_pathElement(v IPathElementContext) { s._pathElement = v }

func (s *PathExpressionContext) GetT() int { return s.t }

func (s *PathExpressionContext) SetT(v int) { s.t = v }

func (s *PathExpressionContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *PathExpressionContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *PathExpressionContext) AllPathElement() []IPathElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathElementContext); ok {
			len++
		}
	}

	tst := make([]IPathElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathElementContext); ok {
			tst[i] = t.(IPathElementContext)
			i++
		}
	}

	return tst
}

func (s *PathExpressionContext) PathElement(i int) IPathElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathElementContext)
}

func (s *PathExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitPathExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) PathExpression() (localctx IPathExpressionContext) {
	localctx = NewPathExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, GroovyParserRULE_pathExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1494)
			p.Primary()
		}

	case 2:
		p.SetState(1495)

		if !(p.GetTokenStream().LT(2).GetTokenType() == GroovyParserDOT) {
			p.SetError(antlr.NewFailedPredicateException(p, " p.GetTokenStream().LT(2).GetTokenType() == GroovyParserDOT ", ""))
			goto errorExit
		}
		{
			p.SetState(1496)
			p.Match(GroovyParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1499)

				var _x = p.PathElement()

				localctx.(*PathExpressionContext)._pathElement = _x
			}
			localctx.(*PathExpressionContext).SetT(localctx.(*PathExpressionContext).Get_pathElement().GetT())

		}
		p.SetState(1506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathElementContext is an interface to support dynamic dispatch.
type IPathElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// Getter signatures
	AllNls() []INlsContext
	Nls(i int) INlsContext
	DOT() antlr.TerminalNode
	NEW() antlr.TerminalNode
	Creator() ICreatorContext
	NamePart() INamePartContext
	ClosureOrLambdaExpression() IClosureOrLambdaExpressionContext
	METHOD_POINTER() antlr.TerminalNode
	METHOD_REFERENCE() antlr.TerminalNode
	SPREAD_DOT() antlr.TerminalNode
	SAFE_DOT() antlr.TerminalNode
	SAFE_CHAIN_DOT() antlr.TerminalNode
	AT() antlr.TerminalNode
	NonWildcardTypeArguments() INonWildcardTypeArgumentsContext
	Arguments() IArgumentsContext
	IndexPropertyArgs() IIndexPropertyArgsContext
	NamedPropertyArgs() INamedPropertyArgsContext

	// IsPathElementContext differentiates from other interfaces.
	IsPathElementContext()
}

type PathElementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyPathElementContext() *PathElementContext {
	var p = new(PathElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_pathElement
	return p
}

func InitEmptyPathElementContext(p *PathElementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_pathElement
}

func (*PathElementContext) IsPathElementContext() {}

func NewPathElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathElementContext {
	var p = new(PathElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_pathElement

	return p
}

func (s *PathElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PathElementContext) GetT() int { return s.t }

func (s *PathElementContext) SetT(v int) { s.t = v }

func (s *PathElementContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *PathElementContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *PathElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, 0)
}

func (s *PathElementContext) NEW() antlr.TerminalNode {
	return s.GetToken(GroovyParserNEW, 0)
}

func (s *PathElementContext) Creator() ICreatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}

func (s *PathElementContext) NamePart() INamePartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamePartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamePartContext)
}

func (s *PathElementContext) ClosureOrLambdaExpression() IClosureOrLambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureOrLambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureOrLambdaExpressionContext)
}

func (s *PathElementContext) METHOD_POINTER() antlr.TerminalNode {
	return s.GetToken(GroovyParserMETHOD_POINTER, 0)
}

func (s *PathElementContext) METHOD_REFERENCE() antlr.TerminalNode {
	return s.GetToken(GroovyParserMETHOD_REFERENCE, 0)
}

func (s *PathElementContext) SPREAD_DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserSPREAD_DOT, 0)
}

func (s *PathElementContext) SAFE_DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserSAFE_DOT, 0)
}

func (s *PathElementContext) SAFE_CHAIN_DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserSAFE_CHAIN_DOT, 0)
}

func (s *PathElementContext) AT() antlr.TerminalNode {
	return s.GetToken(GroovyParserAT, 0)
}

func (s *PathElementContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *PathElementContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *PathElementContext) IndexPropertyArgs() IIndexPropertyArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexPropertyArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexPropertyArgsContext)
}

func (s *PathElementContext) NamedPropertyArgs() INamedPropertyArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedPropertyArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedPropertyArgsContext)
}

func (s *PathElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitPathElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) PathElement() (localctx IPathElementContext) {
	localctx = NewPathElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, GroovyParserRULE_pathElement)
	var _la int

	p.SetState(1546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1507)
			p.Nls()
		}
		p.SetState(1535)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1508)
				p.Match(GroovyParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1509)
				p.Nls()
			}
			{
				p.SetState(1510)
				p.Match(GroovyParserNEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1511)
				p.Creator(1)
			}
			localctx.(*PathElementContext).SetT(6)

		case 2:
			p.SetState(1527)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case GroovyParserSPREAD_DOT, GroovyParserSAFE_DOT, GroovyParserSAFE_CHAIN_DOT, GroovyParserDOT:
				{
					p.SetState(1514)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&67108875) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1515)
					p.Nls()
				}
				p.SetState(1518)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				switch p.GetTokenStream().LA(1) {
				case GroovyParserAT:
					{
						p.SetState(1516)
						p.Match(GroovyParserAT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case GroovyParserLT:
					{
						p.SetState(1517)
						p.NonWildcardTypeArguments()
					}

				case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserTHREADSAFE, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserABSTRACT, GroovyParserASSERT, GroovyParserBREAK, GroovyParserYIELD, GroovyParserCASE, GroovyParserCATCH, GroovyParserCLASS, GroovyParserCONST, GroovyParserCONTINUE, GroovyParserDEFAULT, GroovyParserDO, GroovyParserELSE, GroovyParserENUM, GroovyParserEXTENDS, GroovyParserFINAL, GroovyParserFINALLY, GroovyParserFOR, GroovyParserIF, GroovyParserGOTO, GroovyParserIMPLEMENTS, GroovyParserIMPORT, GroovyParserINSTANCEOF, GroovyParserINTERFACE, GroovyParserNATIVE, GroovyParserNEW, GroovyParserNON_SEALED, GroovyParserPACKAGE, GroovyParserPERMITS, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserRECORD, GroovyParserRETURN, GroovyParserSEALED, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserSUPER, GroovyParserSWITCH, GroovyParserSYNCHRONIZED, GroovyParserTHIS, GroovyParserTHROW, GroovyParserTHROWS, GroovyParserTRANSIENT, GroovyParserTRY, GroovyParserVOID, GroovyParserVOLATILE, GroovyParserWHILE, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserLPAREN, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:

				default:
				}

			case GroovyParserMETHOD_POINTER:
				{
					p.SetState(1520)
					p.Match(GroovyParserMETHOD_POINTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1521)
					p.Nls()
				}

			case GroovyParserMETHOD_REFERENCE:
				{
					p.SetState(1522)
					p.Match(GroovyParserMETHOD_REFERENCE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1523)
					p.Nls()
				}
				p.SetState(1525)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == GroovyParserLT {
					{
						p.SetState(1524)
						p.NonWildcardTypeArguments()
					}

				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			{
				p.SetState(1529)
				p.NamePart()
			}
			localctx.(*PathElementContext).SetT(1)

		case 3:
			{
				p.SetState(1532)
				p.ClosureOrLambdaExpression()
			}
			localctx.(*PathElementContext).SetT(3)

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1537)
			p.Arguments()
		}
		localctx.(*PathElementContext).SetT(2)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1540)
			p.IndexPropertyArgs()
		}
		localctx.(*PathElementContext).SetT(4)

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1543)
			p.NamedPropertyArgs()
		}
		localctx.(*PathElementContext).SetT(5)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamePartContext is an interface to support dynamic dispatch.
type INamePartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	StringLiteral() IStringLiteralContext
	DynamicMemberName() IDynamicMemberNameContext
	Keywords() IKeywordsContext

	// IsNamePartContext differentiates from other interfaces.
	IsNamePartContext()
}

type NamePartContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamePartContext() *NamePartContext {
	var p = new(NamePartContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namePart
	return p
}

func InitEmptyNamePartContext(p *NamePartContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namePart
}

func (*NamePartContext) IsNamePartContext() {}

func NewNamePartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamePartContext {
	var p = new(NamePartContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namePart

	return p
}

func (s *NamePartContext) GetParser() antlr.Parser { return s.parser }

func (s *NamePartContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamePartContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *NamePartContext) DynamicMemberName() IDynamicMemberNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamicMemberNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamicMemberNameContext)
}

func (s *NamePartContext) Keywords() IKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *NamePartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamePartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamePartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNamePart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) NamePart() (localctx INamePartContext) {
	localctx = NewNamePartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, GroovyParserRULE_namePart)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1548)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(1549)
			p.StringLiteral()
		}

	case 3:
		{
			p.SetState(1550)
			p.DynamicMemberName()
		}

	case 4:
		{
			p.SetState(1551)
			p.Keywords()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDynamicMemberNameContext is an interface to support dynamic dispatch.
type IDynamicMemberNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParExpression() IParExpressionContext
	Gstring() IGstringContext

	// IsDynamicMemberNameContext differentiates from other interfaces.
	IsDynamicMemberNameContext()
}

type DynamicMemberNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyDynamicMemberNameContext() *DynamicMemberNameContext {
	var p = new(DynamicMemberNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_dynamicMemberName
	return p
}

func InitEmptyDynamicMemberNameContext(p *DynamicMemberNameContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_dynamicMemberName
}

func (*DynamicMemberNameContext) IsDynamicMemberNameContext() {}

func NewDynamicMemberNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DynamicMemberNameContext {
	var p = new(DynamicMemberNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_dynamicMemberName

	return p
}

func (s *DynamicMemberNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DynamicMemberNameContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *DynamicMemberNameContext) Gstring() IGstringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *DynamicMemberNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DynamicMemberNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DynamicMemberNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitDynamicMemberName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) DynamicMemberName() (localctx IDynamicMemberNameContext) {
	localctx = NewDynamicMemberNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, GroovyParserRULE_dynamicMemberName)
	p.SetState(1556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1554)
			p.ParExpression()
		}

	case GroovyParserGStringBegin:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1555)
			p.Gstring()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexPropertyArgsContext is an interface to support dynamic dispatch.
type IIndexPropertyArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RBRACK() antlr.TerminalNode
	SAFE_INDEX() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsIndexPropertyArgsContext differentiates from other interfaces.
	IsIndexPropertyArgsContext()
}

type IndexPropertyArgsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexPropertyArgsContext() *IndexPropertyArgsContext {
	var p = new(IndexPropertyArgsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_indexPropertyArgs
	return p
}

func InitEmptyIndexPropertyArgsContext(p *IndexPropertyArgsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_indexPropertyArgs
}

func (*IndexPropertyArgsContext) IsIndexPropertyArgsContext() {}

func NewIndexPropertyArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexPropertyArgsContext {
	var p = new(IndexPropertyArgsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_indexPropertyArgs

	return p
}

func (s *IndexPropertyArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexPropertyArgsContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *IndexPropertyArgsContext) SAFE_INDEX() antlr.TerminalNode {
	return s.GetToken(GroovyParserSAFE_INDEX, 0)
}

func (s *IndexPropertyArgsContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *IndexPropertyArgsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *IndexPropertyArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexPropertyArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexPropertyArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitIndexPropertyArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) IndexPropertyArgs() (localctx IIndexPropertyArgsContext) {
	localctx = NewIndexPropertyArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, GroovyParserRULE_indexPropertyArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1558)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GroovyParserSAFE_INDEX || _la == GroovyParserLBRACK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1560)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1559)
			p.ExpressionList(true)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1562)
		p.Match(GroovyParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedPropertyArgsContext is an interface to support dynamic dispatch.
type INamedPropertyArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RBRACK() antlr.TerminalNode
	SAFE_INDEX() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	NamedPropertyArgList() INamedPropertyArgListContext
	COLON() antlr.TerminalNode

	// IsNamedPropertyArgsContext differentiates from other interfaces.
	IsNamedPropertyArgsContext()
}

type NamedPropertyArgsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedPropertyArgsContext() *NamedPropertyArgsContext {
	var p = new(NamedPropertyArgsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedPropertyArgs
	return p
}

func InitEmptyNamedPropertyArgsContext(p *NamedPropertyArgsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedPropertyArgs
}

func (*NamedPropertyArgsContext) IsNamedPropertyArgsContext() {}

func NewNamedPropertyArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedPropertyArgsContext {
	var p = new(NamedPropertyArgsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namedPropertyArgs

	return p
}

func (s *NamedPropertyArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedPropertyArgsContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *NamedPropertyArgsContext) SAFE_INDEX() antlr.TerminalNode {
	return s.GetToken(GroovyParserSAFE_INDEX, 0)
}

func (s *NamedPropertyArgsContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *NamedPropertyArgsContext) NamedPropertyArgList() INamedPropertyArgListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedPropertyArgListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedPropertyArgListContext)
}

func (s *NamedPropertyArgsContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *NamedPropertyArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedPropertyArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedPropertyArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNamedPropertyArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) NamedPropertyArgs() (localctx INamedPropertyArgsContext) {
	localctx = NewNamedPropertyArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, GroovyParserRULE_namedPropertyArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1564)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GroovyParserSAFE_INDEX || _la == GroovyParserLBRACK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserTHREADSAFE, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserABSTRACT, GroovyParserASSERT, GroovyParserBREAK, GroovyParserYIELD, GroovyParserCASE, GroovyParserCATCH, GroovyParserCLASS, GroovyParserCONST, GroovyParserCONTINUE, GroovyParserDEFAULT, GroovyParserDO, GroovyParserELSE, GroovyParserENUM, GroovyParserEXTENDS, GroovyParserFINAL, GroovyParserFINALLY, GroovyParserFOR, GroovyParserIF, GroovyParserGOTO, GroovyParserIMPLEMENTS, GroovyParserIMPORT, GroovyParserINSTANCEOF, GroovyParserINTERFACE, GroovyParserNATIVE, GroovyParserNEW, GroovyParserNON_SEALED, GroovyParserPACKAGE, GroovyParserPERMITS, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserRECORD, GroovyParserRETURN, GroovyParserSEALED, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserSUPER, GroovyParserSWITCH, GroovyParserSYNCHRONIZED, GroovyParserTHIS, GroovyParserTHROW, GroovyParserTHROWS, GroovyParserTRANSIENT, GroovyParserTRY, GroovyParserVOID, GroovyParserVOLATILE, GroovyParserWHILE, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserLPAREN, GroovyParserLBRACK, GroovyParserMUL, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		{
			p.SetState(1565)
			p.NamedPropertyArgList()
		}

	case GroovyParserCOLON:
		{
			p.SetState(1566)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1569)
		p.Match(GroovyParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_primary
	return p
}

func InitEmptyPrimaryContext(p *PrimaryContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_primary
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) CopyAll(ctx *PrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MapPrmrAltContext struct {
	PrimaryContext
}

func NewMapPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapPrmrAltContext {
	var p = new(MapPrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *MapPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapPrmrAltContext) Map_() IMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapContext)
}

func (s *MapPrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMapPrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type GstringPrmrAltContext struct {
	PrimaryContext
}

func NewGstringPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GstringPrmrAltContext {
	var p = new(GstringPrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *GstringPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringPrmrAltContext) Gstring() IGstringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *GstringPrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitGstringPrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ListPrmrAltContext struct {
	PrimaryContext
}

func NewListPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListPrmrAltContext {
	var p = new(ListPrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *ListPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPrmrAltContext) List() IListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListContext)
}

func (s *ListPrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitListPrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type NewPrmrAltContext struct {
	PrimaryContext
}

func NewNewPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewPrmrAltContext {
	var p = new(NewPrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *NewPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewPrmrAltContext) NEW() antlr.TerminalNode {
	return s.GetToken(GroovyParserNEW, 0)
}

func (s *NewPrmrAltContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *NewPrmrAltContext) Creator() ICreatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}

func (s *NewPrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNewPrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralPrmrAltContext struct {
	PrimaryContext
}

func NewLiteralPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralPrmrAltContext {
	var p = new(LiteralPrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *LiteralPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralPrmrAltContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralPrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLiteralPrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ThisPrmrAltContext struct {
	PrimaryContext
}

func NewThisPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisPrmrAltContext {
	var p = new(ThisPrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *ThisPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisPrmrAltContext) THIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHIS, 0)
}

func (s *ThisPrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitThisPrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ClosureOrLambdaExpressionPrmrAltContext struct {
	PrimaryContext
}

func NewClosureOrLambdaExpressionPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClosureOrLambdaExpressionPrmrAltContext {
	var p = new(ClosureOrLambdaExpressionPrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) ClosureOrLambdaExpression() IClosureOrLambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureOrLambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureOrLambdaExpressionContext)
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClosureOrLambdaExpressionPrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type BuiltInTypePrmrAltContext struct {
	PrimaryContext
}

func NewBuiltInTypePrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BuiltInTypePrmrAltContext {
	var p = new(BuiltInTypePrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *BuiltInTypePrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltInTypePrmrAltContext) BuiltInType() IBuiltInTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBuiltInTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBuiltInTypeContext)
}

func (s *BuiltInTypePrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitBuiltInTypePrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdentifierPrmrAltContext struct {
	PrimaryContext
}

func NewIdentifierPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierPrmrAltContext {
	var p = new(IdentifierPrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *IdentifierPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPrmrAltContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierPrmrAltContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *IdentifierPrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitIdentifierPrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type SuperPrmrAltContext struct {
	PrimaryContext
}

func NewSuperPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperPrmrAltContext {
	var p = new(SuperPrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *SuperPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperPrmrAltContext) SUPER() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUPER, 0)
}

func (s *SuperPrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitSuperPrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenPrmrAltContext struct {
	PrimaryContext
}

func NewParenPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenPrmrAltContext {
	var p = new(ParenPrmrAltContext)

	InitEmptyPrimaryContext(&p.PrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryContext))

	return p
}

func (s *ParenPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenPrmrAltContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *ParenPrmrAltContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitParenPrmrAlt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, GroovyParserRULE_primary)
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIdentifierPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1571)
			p.Identifier()
		}
		p.SetState(1573)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1572)
				p.TypeArguments()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewLiteralPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1575)
			p.Literal()
		}

	case 3:
		localctx = NewGstringPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1576)
			p.Gstring()
		}

	case 4:
		localctx = NewNewPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1577)
			p.Match(GroovyParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1578)
			p.Nls()
		}
		{
			p.SetState(1579)
			p.Creator(0)
		}

	case 5:
		localctx = NewThisPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1581)
			p.Match(GroovyParserTHIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewSuperPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1582)
			p.Match(GroovyParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewParenPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1583)
			p.ParExpression()
		}

	case 8:
		localctx = NewClosureOrLambdaExpressionPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1584)
			p.ClosureOrLambdaExpression()
		}

	case 9:
		localctx = NewListPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1585)
			p.List()
		}

	case 10:
		localctx = NewMapPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1586)
			p.Map_()
		}

	case 11:
		localctx = NewBuiltInTypePrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1587)
			p.BuiltInType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedPropertyArgPrimaryContext is an interface to support dynamic dispatch.
type INamedPropertyArgPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNamedPropertyArgPrimaryContext differentiates from other interfaces.
	IsNamedPropertyArgPrimaryContext()
}

type NamedPropertyArgPrimaryContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedPropertyArgPrimaryContext() *NamedPropertyArgPrimaryContext {
	var p = new(NamedPropertyArgPrimaryContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedPropertyArgPrimary
	return p
}

func InitEmptyNamedPropertyArgPrimaryContext(p *NamedPropertyArgPrimaryContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedPropertyArgPrimary
}

func (*NamedPropertyArgPrimaryContext) IsNamedPropertyArgPrimaryContext() {}

func NewNamedPropertyArgPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedPropertyArgPrimaryContext {
	var p = new(NamedPropertyArgPrimaryContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namedPropertyArgPrimary

	return p
}

func (s *NamedPropertyArgPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedPropertyArgPrimaryContext) CopyAll(ctx *NamedPropertyArgPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NamedPropertyArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedPropertyArgPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LiteralPrmrAltNamedPropertyArgPrimaryContext struct {
	NamedPropertyArgPrimaryContext
}

func NewLiteralPrmrAltNamedPropertyArgPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralPrmrAltNamedPropertyArgPrimaryContext {
	var p = new(LiteralPrmrAltNamedPropertyArgPrimaryContext)

	InitEmptyNamedPropertyArgPrimaryContext(&p.NamedPropertyArgPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedPropertyArgPrimaryContext))

	return p
}

func (s *LiteralPrmrAltNamedPropertyArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralPrmrAltNamedPropertyArgPrimaryContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralPrmrAltNamedPropertyArgPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLiteralPrmrAltNamedPropertyArgPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type GstringPrmrAltNamedPropertyArgPrimaryContext struct {
	NamedPropertyArgPrimaryContext
}

func NewGstringPrmrAltNamedPropertyArgPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GstringPrmrAltNamedPropertyArgPrimaryContext {
	var p = new(GstringPrmrAltNamedPropertyArgPrimaryContext)

	InitEmptyNamedPropertyArgPrimaryContext(&p.NamedPropertyArgPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedPropertyArgPrimaryContext))

	return p
}

func (s *GstringPrmrAltNamedPropertyArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringPrmrAltNamedPropertyArgPrimaryContext) Gstring() IGstringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *GstringPrmrAltNamedPropertyArgPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitGstringPrmrAltNamedPropertyArgPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type MapPrmrAltNamedPropertyArgPrimaryContext struct {
	NamedPropertyArgPrimaryContext
}

func NewMapPrmrAltNamedPropertyArgPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapPrmrAltNamedPropertyArgPrimaryContext {
	var p = new(MapPrmrAltNamedPropertyArgPrimaryContext)

	InitEmptyNamedPropertyArgPrimaryContext(&p.NamedPropertyArgPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedPropertyArgPrimaryContext))

	return p
}

func (s *MapPrmrAltNamedPropertyArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapPrmrAltNamedPropertyArgPrimaryContext) Map_() IMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapContext)
}

func (s *MapPrmrAltNamedPropertyArgPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMapPrmrAltNamedPropertyArgPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdentifierPrmrAltNamedPropertyArgPrimaryContext struct {
	NamedPropertyArgPrimaryContext
}

func NewIdentifierPrmrAltNamedPropertyArgPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierPrmrAltNamedPropertyArgPrimaryContext {
	var p = new(IdentifierPrmrAltNamedPropertyArgPrimaryContext)

	InitEmptyNamedPropertyArgPrimaryContext(&p.NamedPropertyArgPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedPropertyArgPrimaryContext))

	return p
}

func (s *IdentifierPrmrAltNamedPropertyArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPrmrAltNamedPropertyArgPrimaryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierPrmrAltNamedPropertyArgPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitIdentifierPrmrAltNamedPropertyArgPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenPrmrAltNamedPropertyArgPrimaryContext struct {
	NamedPropertyArgPrimaryContext
}

func NewParenPrmrAltNamedPropertyArgPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenPrmrAltNamedPropertyArgPrimaryContext {
	var p = new(ParenPrmrAltNamedPropertyArgPrimaryContext)

	InitEmptyNamedPropertyArgPrimaryContext(&p.NamedPropertyArgPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedPropertyArgPrimaryContext))

	return p
}

func (s *ParenPrmrAltNamedPropertyArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenPrmrAltNamedPropertyArgPrimaryContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *ParenPrmrAltNamedPropertyArgPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitParenPrmrAltNamedPropertyArgPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type ListPrmrAltNamedPropertyArgPrimaryContext struct {
	NamedPropertyArgPrimaryContext
}

func NewListPrmrAltNamedPropertyArgPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListPrmrAltNamedPropertyArgPrimaryContext {
	var p = new(ListPrmrAltNamedPropertyArgPrimaryContext)

	InitEmptyNamedPropertyArgPrimaryContext(&p.NamedPropertyArgPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedPropertyArgPrimaryContext))

	return p
}

func (s *ListPrmrAltNamedPropertyArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPrmrAltNamedPropertyArgPrimaryContext) List() IListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListContext)
}

func (s *ListPrmrAltNamedPropertyArgPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitListPrmrAltNamedPropertyArgPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) NamedPropertyArgPrimary() (localctx INamedPropertyArgPrimaryContext) {
	localctx = NewNamedPropertyArgPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, GroovyParserRULE_namedPropertyArgPrimary)
	p.SetState(1596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIdentifierPrmrAltNamedPropertyArgPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1590)
			p.Identifier()
		}

	case 2:
		localctx = NewLiteralPrmrAltNamedPropertyArgPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1591)
			p.Literal()
		}

	case 3:
		localctx = NewGstringPrmrAltNamedPropertyArgPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1592)
			p.Gstring()
		}

	case 4:
		localctx = NewParenPrmrAltNamedPropertyArgPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1593)
			p.ParExpression()
		}

	case 5:
		localctx = NewListPrmrAltNamedPropertyArgPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1594)
			p.List()
		}

	case 6:
		localctx = NewMapPrmrAltNamedPropertyArgPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1595)
			p.Map_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgPrimaryContext is an interface to support dynamic dispatch.
type INamedArgPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNamedArgPrimaryContext differentiates from other interfaces.
	IsNamedArgPrimaryContext()
}

type NamedArgPrimaryContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgPrimaryContext() *NamedArgPrimaryContext {
	var p = new(NamedArgPrimaryContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedArgPrimary
	return p
}

func InitEmptyNamedArgPrimaryContext(p *NamedArgPrimaryContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedArgPrimary
}

func (*NamedArgPrimaryContext) IsNamedArgPrimaryContext() {}

func NewNamedArgPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgPrimaryContext {
	var p = new(NamedArgPrimaryContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namedArgPrimary

	return p
}

func (s *NamedArgPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgPrimaryContext) CopyAll(ctx *NamedArgPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NamedArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LiteralPrmrAltNamedArgPrimaryContext struct {
	NamedArgPrimaryContext
}

func NewLiteralPrmrAltNamedArgPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralPrmrAltNamedArgPrimaryContext {
	var p = new(LiteralPrmrAltNamedArgPrimaryContext)

	InitEmptyNamedArgPrimaryContext(&p.NamedArgPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedArgPrimaryContext))

	return p
}

func (s *LiteralPrmrAltNamedArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralPrmrAltNamedArgPrimaryContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralPrmrAltNamedArgPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLiteralPrmrAltNamedArgPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type GstringPrmrAltNamedArgPrimaryContext struct {
	NamedArgPrimaryContext
}

func NewGstringPrmrAltNamedArgPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GstringPrmrAltNamedArgPrimaryContext {
	var p = new(GstringPrmrAltNamedArgPrimaryContext)

	InitEmptyNamedArgPrimaryContext(&p.NamedArgPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedArgPrimaryContext))

	return p
}

func (s *GstringPrmrAltNamedArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringPrmrAltNamedArgPrimaryContext) Gstring() IGstringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *GstringPrmrAltNamedArgPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitGstringPrmrAltNamedArgPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdentifierPrmrAltNamedArgPrimaryContext struct {
	NamedArgPrimaryContext
}

func NewIdentifierPrmrAltNamedArgPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierPrmrAltNamedArgPrimaryContext {
	var p = new(IdentifierPrmrAltNamedArgPrimaryContext)

	InitEmptyNamedArgPrimaryContext(&p.NamedArgPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedArgPrimaryContext))

	return p
}

func (s *IdentifierPrmrAltNamedArgPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPrmrAltNamedArgPrimaryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierPrmrAltNamedArgPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitIdentifierPrmrAltNamedArgPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) NamedArgPrimary() (localctx INamedArgPrimaryContext) {
	localctx = NewNamedArgPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, GroovyParserRULE_namedArgPrimary)
	p.SetState(1601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAS, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserYIELD, GroovyParserPERMITS, GroovyParserRECORD, GroovyParserSEALED, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		localctx = NewIdentifierPrmrAltNamedArgPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1598)
			p.Identifier()
		}

	case GroovyParserStringLiteral, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral:
		localctx = NewLiteralPrmrAltNamedArgPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1599)
			p.Literal()
		}

	case GroovyParserGStringBegin:
		localctx = NewGstringPrmrAltNamedArgPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1600)
			p.Gstring()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommandPrimaryContext is an interface to support dynamic dispatch.
type ICommandPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCommandPrimaryContext differentiates from other interfaces.
	IsCommandPrimaryContext()
}

type CommandPrimaryContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandPrimaryContext() *CommandPrimaryContext {
	var p = new(CommandPrimaryContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_commandPrimary
	return p
}

func InitEmptyCommandPrimaryContext(p *CommandPrimaryContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_commandPrimary
}

func (*CommandPrimaryContext) IsCommandPrimaryContext() {}

func NewCommandPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandPrimaryContext {
	var p = new(CommandPrimaryContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_commandPrimary

	return p
}

func (s *CommandPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandPrimaryContext) CopyAll(ctx *CommandPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CommandPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IdentifierPrmrAltCommandPrimaryContext struct {
	CommandPrimaryContext
}

func NewIdentifierPrmrAltCommandPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierPrmrAltCommandPrimaryContext {
	var p = new(IdentifierPrmrAltCommandPrimaryContext)

	InitEmptyCommandPrimaryContext(&p.CommandPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*CommandPrimaryContext))

	return p
}

func (s *IdentifierPrmrAltCommandPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPrmrAltCommandPrimaryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierPrmrAltCommandPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitIdentifierPrmrAltCommandPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralPrmrAltCommandPrimaryContext struct {
	CommandPrimaryContext
}

func NewLiteralPrmrAltCommandPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralPrmrAltCommandPrimaryContext {
	var p = new(LiteralPrmrAltCommandPrimaryContext)

	InitEmptyCommandPrimaryContext(&p.CommandPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*CommandPrimaryContext))

	return p
}

func (s *LiteralPrmrAltCommandPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralPrmrAltCommandPrimaryContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralPrmrAltCommandPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitLiteralPrmrAltCommandPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type GstringPrmrAltCommandPrimaryContext struct {
	CommandPrimaryContext
}

func NewGstringPrmrAltCommandPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GstringPrmrAltCommandPrimaryContext {
	var p = new(GstringPrmrAltCommandPrimaryContext)

	InitEmptyCommandPrimaryContext(&p.CommandPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*CommandPrimaryContext))

	return p
}

func (s *GstringPrmrAltCommandPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringPrmrAltCommandPrimaryContext) Gstring() IGstringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGstringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *GstringPrmrAltCommandPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitGstringPrmrAltCommandPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) CommandPrimary() (localctx ICommandPrimaryContext) {
	localctx = NewCommandPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, GroovyParserRULE_commandPrimary)
	p.SetState(1606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAS, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserYIELD, GroovyParserPERMITS, GroovyParserRECORD, GroovyParserSEALED, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		localctx = NewIdentifierPrmrAltCommandPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1603)
			p.Identifier()
		}

	case GroovyParserStringLiteral, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral:
		localctx = NewLiteralPrmrAltCommandPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1604)
			p.Literal()
		}

	case GroovyParserGStringBegin:
		localctx = NewGstringPrmrAltCommandPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1605)
			p.Gstring()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListContext is an interface to support dynamic dispatch.
type IListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	COMMA() antlr.TerminalNode

	// IsListContext differentiates from other interfaces.
	IsListContext()
}

type ListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyListContext() *ListContext {
	var p = new(ListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_list
	return p
}

func InitEmptyListContext(p *ListContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_list
}

func (*ListContext) IsListContext() {}

func NewListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListContext {
	var p = new(ListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_list

	return p
}

func (s *ListContext) GetParser() antlr.Parser { return s.parser }

func (s *ListContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *ListContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *ListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *ListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) List() (localctx IListContext) {
	localctx = NewListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, GroovyParserRULE_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1608)
		p.Match(GroovyParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1610)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1609)
			p.ExpressionList(true)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserCOMMA {
		{
			p.SetState(1612)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1615)
		p.Match(GroovyParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapContext is an interface to support dynamic dispatch.
type IMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	MapEntryList() IMapEntryListContext
	COLON() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsMapContext differentiates from other interfaces.
	IsMapContext()
}

type MapContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapContext() *MapContext {
	var p = new(MapContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_map
	return p
}

func InitEmptyMapContext(p *MapContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_map
}

func (*MapContext) IsMapContext() {}

func NewMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapContext {
	var p = new(MapContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_map

	return p
}

func (s *MapContext) GetParser() antlr.Parser { return s.parser }

func (s *MapContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *MapContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *MapContext) MapEntryList() IMapEntryListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapEntryListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapEntryListContext)
}

func (s *MapContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *MapContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *MapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMap(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Map_() (localctx IMapContext) {
	localctx = NewMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, GroovyParserRULE_map)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1617)
		p.Match(GroovyParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserTHREADSAFE, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserABSTRACT, GroovyParserASSERT, GroovyParserBREAK, GroovyParserYIELD, GroovyParserCASE, GroovyParserCATCH, GroovyParserCLASS, GroovyParserCONST, GroovyParserCONTINUE, GroovyParserDEFAULT, GroovyParserDO, GroovyParserELSE, GroovyParserENUM, GroovyParserEXTENDS, GroovyParserFINAL, GroovyParserFINALLY, GroovyParserFOR, GroovyParserIF, GroovyParserGOTO, GroovyParserIMPLEMENTS, GroovyParserIMPORT, GroovyParserINSTANCEOF, GroovyParserINTERFACE, GroovyParserNATIVE, GroovyParserNEW, GroovyParserNON_SEALED, GroovyParserPACKAGE, GroovyParserPERMITS, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserRECORD, GroovyParserRETURN, GroovyParserSEALED, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserSUPER, GroovyParserSWITCH, GroovyParserSYNCHRONIZED, GroovyParserTHIS, GroovyParserTHROW, GroovyParserTHROWS, GroovyParserTRANSIENT, GroovyParserTRY, GroovyParserVOID, GroovyParserVOLATILE, GroovyParserWHILE, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserLPAREN, GroovyParserLBRACE, GroovyParserLBRACK, GroovyParserMUL, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		{
			p.SetState(1618)
			p.MapEntryList()
		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserCOMMA {
			{
				p.SetState(1619)
				p.Match(GroovyParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case GroovyParserCOLON:
		{
			p.SetState(1622)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1625)
		p.Match(GroovyParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapEntryListContext is an interface to support dynamic dispatch.
type IMapEntryListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapEntry() []IMapEntryContext
	MapEntry(i int) IMapEntryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapEntryListContext differentiates from other interfaces.
	IsMapEntryListContext()
}

type MapEntryListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapEntryListContext() *MapEntryListContext {
	var p = new(MapEntryListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_mapEntryList
	return p
}

func InitEmptyMapEntryListContext(p *MapEntryListContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_mapEntryList
}

func (*MapEntryListContext) IsMapEntryListContext() {}

func NewMapEntryListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapEntryListContext {
	var p = new(MapEntryListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_mapEntryList

	return p
}

func (s *MapEntryListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapEntryListContext) AllMapEntry() []IMapEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapEntryContext); ok {
			len++
		}
	}

	tst := make([]IMapEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapEntryContext); ok {
			tst[i] = t.(IMapEntryContext)
			i++
		}
	}

	return tst
}

func (s *MapEntryListContext) MapEntry(i int) IMapEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapEntryContext)
}

func (s *MapEntryListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *MapEntryListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *MapEntryListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapEntryListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapEntryListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMapEntryList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) MapEntryList() (localctx IMapEntryListContext) {
	localctx = NewMapEntryListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, GroovyParserRULE_mapEntryList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		p.MapEntry()
	}
	p.SetState(1632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1628)
				p.Match(GroovyParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1629)
				p.MapEntry()
			}

		}
		p.SetState(1634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedPropertyArgListContext is an interface to support dynamic dispatch.
type INamedPropertyArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedPropertyArg() []INamedPropertyArgContext
	NamedPropertyArg(i int) INamedPropertyArgContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamedPropertyArgListContext differentiates from other interfaces.
	IsNamedPropertyArgListContext()
}

type NamedPropertyArgListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedPropertyArgListContext() *NamedPropertyArgListContext {
	var p = new(NamedPropertyArgListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedPropertyArgList
	return p
}

func InitEmptyNamedPropertyArgListContext(p *NamedPropertyArgListContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedPropertyArgList
}

func (*NamedPropertyArgListContext) IsNamedPropertyArgListContext() {}

func NewNamedPropertyArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedPropertyArgListContext {
	var p = new(NamedPropertyArgListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namedPropertyArgList

	return p
}

func (s *NamedPropertyArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedPropertyArgListContext) AllNamedPropertyArg() []INamedPropertyArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedPropertyArgContext); ok {
			len++
		}
	}

	tst := make([]INamedPropertyArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedPropertyArgContext); ok {
			tst[i] = t.(INamedPropertyArgContext)
			i++
		}
	}

	return tst
}

func (s *NamedPropertyArgListContext) NamedPropertyArg(i int) INamedPropertyArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedPropertyArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedPropertyArgContext)
}

func (s *NamedPropertyArgListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *NamedPropertyArgListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *NamedPropertyArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedPropertyArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedPropertyArgListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNamedPropertyArgList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) NamedPropertyArgList() (localctx INamedPropertyArgListContext) {
	localctx = NewNamedPropertyArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, GroovyParserRULE_namedPropertyArgList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1635)
		p.NamedPropertyArg()
	}
	p.SetState(1640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(1636)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1637)
			p.NamedPropertyArg()
		}

		p.SetState(1642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapEntryContext is an interface to support dynamic dispatch.
type IMapEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MapEntryLabel() IMapEntryLabelContext
	COLON() antlr.TerminalNode
	Nls() INlsContext
	Expression() IExpressionContext
	MUL() antlr.TerminalNode

	// IsMapEntryContext differentiates from other interfaces.
	IsMapEntryContext()
}

type MapEntryContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapEntryContext() *MapEntryContext {
	var p = new(MapEntryContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_mapEntry
	return p
}

func InitEmptyMapEntryContext(p *MapEntryContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_mapEntry
}

func (*MapEntryContext) IsMapEntryContext() {}

func NewMapEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapEntryContext {
	var p = new(MapEntryContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_mapEntry

	return p
}

func (s *MapEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *MapEntryContext) MapEntryLabel() IMapEntryLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapEntryLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapEntryLabelContext)
}

func (s *MapEntryContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *MapEntryContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MapEntryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapEntryContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *MapEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMapEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) MapEntry() (localctx IMapEntryContext) {
	localctx = NewMapEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, GroovyParserRULE_mapEntry)
	p.SetState(1653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserTHREADSAFE, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserABSTRACT, GroovyParserASSERT, GroovyParserBREAK, GroovyParserYIELD, GroovyParserCASE, GroovyParserCATCH, GroovyParserCLASS, GroovyParserCONST, GroovyParserCONTINUE, GroovyParserDEFAULT, GroovyParserDO, GroovyParserELSE, GroovyParserENUM, GroovyParserEXTENDS, GroovyParserFINAL, GroovyParserFINALLY, GroovyParserFOR, GroovyParserIF, GroovyParserGOTO, GroovyParserIMPLEMENTS, GroovyParserIMPORT, GroovyParserINSTANCEOF, GroovyParserINTERFACE, GroovyParserNATIVE, GroovyParserNEW, GroovyParserNON_SEALED, GroovyParserPACKAGE, GroovyParserPERMITS, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserRECORD, GroovyParserRETURN, GroovyParserSEALED, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserSUPER, GroovyParserSWITCH, GroovyParserSYNCHRONIZED, GroovyParserTHIS, GroovyParserTHROW, GroovyParserTHROWS, GroovyParserTRANSIENT, GroovyParserTRY, GroovyParserVOID, GroovyParserVOLATILE, GroovyParserWHILE, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserLPAREN, GroovyParserLBRACE, GroovyParserLBRACK, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1643)
			p.MapEntryLabel()
		}
		{
			p.SetState(1644)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1645)
			p.Nls()
		}
		{
			p.SetState(1646)
			p.expression(0)
		}

	case GroovyParserMUL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1648)
			p.Match(GroovyParserMUL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1649)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1650)
			p.Nls()
		}
		{
			p.SetState(1651)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedPropertyArgContext is an interface to support dynamic dispatch.
type INamedPropertyArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedPropertyArgLabel() INamedPropertyArgLabelContext
	COLON() antlr.TerminalNode
	Nls() INlsContext
	Expression() IExpressionContext
	MUL() antlr.TerminalNode

	// IsNamedPropertyArgContext differentiates from other interfaces.
	IsNamedPropertyArgContext()
}

type NamedPropertyArgContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedPropertyArgContext() *NamedPropertyArgContext {
	var p = new(NamedPropertyArgContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedPropertyArg
	return p
}

func InitEmptyNamedPropertyArgContext(p *NamedPropertyArgContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedPropertyArg
}

func (*NamedPropertyArgContext) IsNamedPropertyArgContext() {}

func NewNamedPropertyArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedPropertyArgContext {
	var p = new(NamedPropertyArgContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namedPropertyArg

	return p
}

func (s *NamedPropertyArgContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedPropertyArgContext) NamedPropertyArgLabel() INamedPropertyArgLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedPropertyArgLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedPropertyArgLabelContext)
}

func (s *NamedPropertyArgContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *NamedPropertyArgContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *NamedPropertyArgContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedPropertyArgContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *NamedPropertyArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedPropertyArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedPropertyArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNamedPropertyArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) NamedPropertyArg() (localctx INamedPropertyArgContext) {
	localctx = NewNamedPropertyArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, GroovyParserRULE_namedPropertyArg)
	p.SetState(1665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserTHREADSAFE, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserABSTRACT, GroovyParserASSERT, GroovyParserBREAK, GroovyParserYIELD, GroovyParserCASE, GroovyParserCATCH, GroovyParserCLASS, GroovyParserCONST, GroovyParserCONTINUE, GroovyParserDEFAULT, GroovyParserDO, GroovyParserELSE, GroovyParserENUM, GroovyParserEXTENDS, GroovyParserFINAL, GroovyParserFINALLY, GroovyParserFOR, GroovyParserIF, GroovyParserGOTO, GroovyParserIMPLEMENTS, GroovyParserIMPORT, GroovyParserINSTANCEOF, GroovyParserINTERFACE, GroovyParserNATIVE, GroovyParserNEW, GroovyParserNON_SEALED, GroovyParserPACKAGE, GroovyParserPERMITS, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserRECORD, GroovyParserRETURN, GroovyParserSEALED, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserSUPER, GroovyParserSWITCH, GroovyParserSYNCHRONIZED, GroovyParserTHIS, GroovyParserTHROW, GroovyParserTHROWS, GroovyParserTRANSIENT, GroovyParserTRY, GroovyParserVOID, GroovyParserVOLATILE, GroovyParserWHILE, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserLPAREN, GroovyParserLBRACK, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1655)
			p.NamedPropertyArgLabel()
		}
		{
			p.SetState(1656)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1657)
			p.Nls()
		}
		{
			p.SetState(1658)
			p.expression(0)
		}

	case GroovyParserMUL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1660)
			p.Match(GroovyParserMUL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1661)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1662)
			p.Nls()
		}
		{
			p.SetState(1663)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgContext is an interface to support dynamic dispatch.
type INamedArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedArgLabel() INamedArgLabelContext
	COLON() antlr.TerminalNode
	Nls() INlsContext
	Expression() IExpressionContext
	MUL() antlr.TerminalNode

	// IsNamedArgContext differentiates from other interfaces.
	IsNamedArgContext()
}

type NamedArgContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgContext() *NamedArgContext {
	var p = new(NamedArgContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedArg
	return p
}

func InitEmptyNamedArgContext(p *NamedArgContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedArg
}

func (*NamedArgContext) IsNamedArgContext() {}

func NewNamedArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgContext {
	var p = new(NamedArgContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namedArg

	return p
}

func (s *NamedArgContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgContext) NamedArgLabel() INamedArgLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgLabelContext)
}

func (s *NamedArgContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *NamedArgContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *NamedArgContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *NamedArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNamedArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) NamedArg() (localctx INamedArgContext) {
	localctx = NewNamedArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, GroovyParserRULE_namedArg)
	p.SetState(1677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserStringLiteral, GroovyParserGStringBegin, GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserTHREADSAFE, GroovyParserVAR, GroovyParserBuiltInPrimitiveType, GroovyParserABSTRACT, GroovyParserASSERT, GroovyParserBREAK, GroovyParserYIELD, GroovyParserCASE, GroovyParserCATCH, GroovyParserCLASS, GroovyParserCONST, GroovyParserCONTINUE, GroovyParserDEFAULT, GroovyParserDO, GroovyParserELSE, GroovyParserENUM, GroovyParserEXTENDS, GroovyParserFINAL, GroovyParserFINALLY, GroovyParserFOR, GroovyParserIF, GroovyParserGOTO, GroovyParserIMPLEMENTS, GroovyParserIMPORT, GroovyParserINSTANCEOF, GroovyParserINTERFACE, GroovyParserNATIVE, GroovyParserNEW, GroovyParserNON_SEALED, GroovyParserPACKAGE, GroovyParserPERMITS, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserRECORD, GroovyParserRETURN, GroovyParserSEALED, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserSUPER, GroovyParserSWITCH, GroovyParserSYNCHRONIZED, GroovyParserTHIS, GroovyParserTHROW, GroovyParserTHROWS, GroovyParserTRANSIENT, GroovyParserTRY, GroovyParserVOID, GroovyParserVOLATILE, GroovyParserWHILE, GroovyParserIntegerLiteral, GroovyParserFloatingPointLiteral, GroovyParserBooleanLiteral, GroovyParserNullLiteral, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1667)
			p.NamedArgLabel()
		}
		{
			p.SetState(1668)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1669)
			p.Nls()
		}
		{
			p.SetState(1670)
			p.expression(0)
		}

	case GroovyParserMUL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1672)
			p.Match(GroovyParserMUL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1673)
			p.Match(GroovyParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1674)
			p.Nls()
		}
		{
			p.SetState(1675)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapEntryLabelContext is an interface to support dynamic dispatch.
type IMapEntryLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Keywords() IKeywordsContext
	Primary() IPrimaryContext

	// IsMapEntryLabelContext differentiates from other interfaces.
	IsMapEntryLabelContext()
}

type MapEntryLabelContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapEntryLabelContext() *MapEntryLabelContext {
	var p = new(MapEntryLabelContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_mapEntryLabel
	return p
}

func InitEmptyMapEntryLabelContext(p *MapEntryLabelContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_mapEntryLabel
}

func (*MapEntryLabelContext) IsMapEntryLabelContext() {}

func NewMapEntryLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapEntryLabelContext {
	var p = new(MapEntryLabelContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_mapEntryLabel

	return p
}

func (s *MapEntryLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *MapEntryLabelContext) Keywords() IKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *MapEntryLabelContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *MapEntryLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapEntryLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapEntryLabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitMapEntryLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) MapEntryLabel() (localctx IMapEntryLabelContext) {
	localctx = NewMapEntryLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, GroovyParserRULE_mapEntryLabel)
	p.SetState(1681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1679)
			p.Keywords()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1680)
			p.Primary()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedPropertyArgLabelContext is an interface to support dynamic dispatch.
type INamedPropertyArgLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Keywords() IKeywordsContext
	NamedPropertyArgPrimary() INamedPropertyArgPrimaryContext

	// IsNamedPropertyArgLabelContext differentiates from other interfaces.
	IsNamedPropertyArgLabelContext()
}

type NamedPropertyArgLabelContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedPropertyArgLabelContext() *NamedPropertyArgLabelContext {
	var p = new(NamedPropertyArgLabelContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedPropertyArgLabel
	return p
}

func InitEmptyNamedPropertyArgLabelContext(p *NamedPropertyArgLabelContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedPropertyArgLabel
}

func (*NamedPropertyArgLabelContext) IsNamedPropertyArgLabelContext() {}

func NewNamedPropertyArgLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedPropertyArgLabelContext {
	var p = new(NamedPropertyArgLabelContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namedPropertyArgLabel

	return p
}

func (s *NamedPropertyArgLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedPropertyArgLabelContext) Keywords() IKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *NamedPropertyArgLabelContext) NamedPropertyArgPrimary() INamedPropertyArgPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedPropertyArgPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedPropertyArgPrimaryContext)
}

func (s *NamedPropertyArgLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedPropertyArgLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedPropertyArgLabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNamedPropertyArgLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) NamedPropertyArgLabel() (localctx INamedPropertyArgLabelContext) {
	localctx = NewNamedPropertyArgLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, GroovyParserRULE_namedPropertyArgLabel)
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1683)
			p.Keywords()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1684)
			p.NamedPropertyArgPrimary()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgLabelContext is an interface to support dynamic dispatch.
type INamedArgLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Keywords() IKeywordsContext
	NamedArgPrimary() INamedArgPrimaryContext

	// IsNamedArgLabelContext differentiates from other interfaces.
	IsNamedArgLabelContext()
}

type NamedArgLabelContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgLabelContext() *NamedArgLabelContext {
	var p = new(NamedArgLabelContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedArgLabel
	return p
}

func InitEmptyNamedArgLabelContext(p *NamedArgLabelContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_namedArgLabel
}

func (*NamedArgLabelContext) IsNamedArgLabelContext() {}

func NewNamedArgLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgLabelContext {
	var p = new(NamedArgLabelContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namedArgLabel

	return p
}

func (s *NamedArgLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgLabelContext) Keywords() IKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *NamedArgLabelContext) NamedArgPrimary() INamedArgPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgPrimaryContext)
}

func (s *NamedArgLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgLabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNamedArgLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) NamedArgLabel() (localctx INamedArgLabelContext) {
	localctx = NewNamedArgLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, GroovyParserRULE_namedArgLabel)
	p.SetState(1689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1687)
			p.Keywords()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1688)
			p.NamedArgPrimary()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatorContext is an interface to support dynamic dispatch.
type ICreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// Getter signatures
	CreatedName() ICreatedNameContext
	Nls() INlsContext
	Arguments() IArgumentsContext
	AnonymousInnerClassDeclaration() IAnonymousInnerClassDeclarationContext
	AllDim() []IDimContext
	Dim(i int) IDimContext
	ArrayInitializer() IArrayInitializerContext

	// IsCreatorContext differentiates from other interfaces.
	IsCreatorContext()
}

type CreatorContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyCreatorContext() *CreatorContext {
	var p = new(CreatorContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_creator
	return p
}

func InitEmptyCreatorContext(p *CreatorContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_creator
}

func (*CreatorContext) IsCreatorContext() {}

func NewCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *CreatorContext {
	var p = new(CreatorContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_creator

	p.t = t

	return p
}

func (s *CreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatorContext) GetT() int { return s.t }

func (s *CreatorContext) SetT(v int) { s.t = v }

func (s *CreatorContext) CreatedName() ICreatedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatedNameContext)
}

func (s *CreatorContext) Nls() INlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *CreatorContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *CreatorContext) AnonymousInnerClassDeclaration() IAnonymousInnerClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousInnerClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousInnerClassDeclarationContext)
}

func (s *CreatorContext) AllDim() []IDimContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDimContext); ok {
			len++
		}
	}

	tst := make([]IDimContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDimContext); ok {
			tst[i] = t.(IDimContext)
			i++
		}
	}

	return tst
}

func (s *CreatorContext) Dim(i int) IDimContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimContext)
}

func (s *CreatorContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *CreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCreator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Creator(t int) (localctx ICreatorContext) {
	localctx = NewCreatorContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 286, GroovyParserRULE_creator)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1691)
		p.CreatedName()
	}
	p.SetState(1707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserLPAREN, GroovyParserNL:
		{
			p.SetState(1692)
			p.Nls()
		}
		{
			p.SetState(1693)
			p.Arguments()
		}
		p.SetState(1695)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1694)
				p.AnonymousInnerClassDeclaration(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GroovyParserLBRACK, GroovyParserAT:
		p.SetState(1698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1697)
					p.Dim()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1700)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1705)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1702)
				p.Nls()
			}
			{
				p.SetState(1703)
				p.ArrayInitializer()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDimContext is an interface to support dynamic dispatch.
type IDimContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationsOpt() IAnnotationsOptContext
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDimContext differentiates from other interfaces.
	IsDimContext()
}

type DimContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimContext() *DimContext {
	var p = new(DimContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_dim
	return p
}

func InitEmptyDimContext(p *DimContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_dim
}

func (*DimContext) IsDimContext() {}

func NewDimContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimContext {
	var p = new(DimContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_dim

	return p
}

func (s *DimContext) GetParser() antlr.Parser { return s.parser }

func (s *DimContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *DimContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *DimContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *DimContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitDim(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Dim() (localctx IDimContext) {
	localctx = NewDimContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, GroovyParserRULE_dim)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1709)
		p.AnnotationsOpt()
	}
	{
		p.SetState(1710)
		p.Match(GroovyParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1711)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1714)
		p.Match(GroovyParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext
	RBRACE() antlr.TerminalNode
	VariableInitializers() IVariableInitializersContext

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_arrayInitializer
	return p
}

func InitEmptyArrayInitializerContext(p *ArrayInitializerContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_arrayInitializer
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *ArrayInitializerContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ArrayInitializerContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *ArrayInitializerContext) VariableInitializers() IVariableInitializersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializersContext)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitArrayInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ArrayInitializer() (localctx IArrayInitializerContext) {
	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, GroovyParserRULE_arrayInitializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1716)
		p.Match(GroovyParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1717)
		p.Nls()
	}
	p.SetState(1721)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1718)
			p.VariableInitializers()
		}
		{
			p.SetState(1719)
			p.Nls()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1723)
		p.Match(GroovyParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnonymousInnerClassDeclarationContext is an interface to support dynamic dispatch.
type IAnonymousInnerClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// Getter signatures
	ClassBody() IClassBodyContext

	// IsAnonymousInnerClassDeclarationContext differentiates from other interfaces.
	IsAnonymousInnerClassDeclarationContext()
}

type AnonymousInnerClassDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyAnonymousInnerClassDeclarationContext() *AnonymousInnerClassDeclarationContext {
	var p = new(AnonymousInnerClassDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_anonymousInnerClassDeclaration
	return p
}

func InitEmptyAnonymousInnerClassDeclarationContext(p *AnonymousInnerClassDeclarationContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_anonymousInnerClassDeclaration
}

func (*AnonymousInnerClassDeclarationContext) IsAnonymousInnerClassDeclarationContext() {}

func NewAnonymousInnerClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *AnonymousInnerClassDeclarationContext {
	var p = new(AnonymousInnerClassDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_anonymousInnerClassDeclaration

	p.t = t

	return p
}

func (s *AnonymousInnerClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousInnerClassDeclarationContext) GetT() int { return s.t }

func (s *AnonymousInnerClassDeclarationContext) SetT(v int) { s.t = v }

func (s *AnonymousInnerClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *AnonymousInnerClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousInnerClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousInnerClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitAnonymousInnerClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) AnonymousInnerClassDeclaration(t int) (localctx IAnonymousInnerClassDeclarationContext) {
	localctx = NewAnonymousInnerClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 292, GroovyParserRULE_anonymousInnerClassDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1725)
		p.ClassBody(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatedNameContext is an interface to support dynamic dispatch.
type ICreatedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationsOpt() IAnnotationsOptContext
	PrimitiveType() IPrimitiveTypeContext
	QualifiedClassName() IQualifiedClassNameContext
	TypeArgumentsOrDiamond() ITypeArgumentsOrDiamondContext

	// IsCreatedNameContext differentiates from other interfaces.
	IsCreatedNameContext()
}

type CreatedNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatedNameContext() *CreatedNameContext {
	var p = new(CreatedNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_createdName
	return p
}

func InitEmptyCreatedNameContext(p *CreatedNameContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_createdName
}

func (*CreatedNameContext) IsCreatedNameContext() {}

func NewCreatedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatedNameContext {
	var p = new(CreatedNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_createdName

	return p
}

func (s *CreatedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatedNameContext) AnnotationsOpt() IAnnotationsOptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationsOptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *CreatedNameContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *CreatedNameContext) QualifiedClassName() IQualifiedClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *CreatedNameContext) TypeArgumentsOrDiamond() ITypeArgumentsOrDiamondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsOrDiamondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsOrDiamondContext)
}

func (s *CreatedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitCreatedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) CreatedName() (localctx ICreatedNameContext) {
	localctx = NewCreatedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, GroovyParserRULE_createdName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1727)
		p.AnnotationsOpt()
	}
	p.SetState(1733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GroovyParserBuiltInPrimitiveType:
		{
			p.SetState(1728)
			p.PrimitiveType()
		}

	case GroovyParserAS, GroovyParserDEF, GroovyParserIN, GroovyParserTRAIT, GroovyParserVAR, GroovyParserYIELD, GroovyParserPERMITS, GroovyParserRECORD, GroovyParserSEALED, GroovyParserCapitalizedIdentifier, GroovyParserIdentifier:
		{
			p.SetState(1729)
			p.QualifiedClassName()
		}
		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserLT {
			{
				p.SetState(1730)
				p.TypeArgumentsOrDiamond()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonWildcardTypeArgumentsContext is an interface to support dynamic dispatch.
type INonWildcardTypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext
	TypeList() ITypeListContext
	GT() antlr.TerminalNode

	// IsNonWildcardTypeArgumentsContext differentiates from other interfaces.
	IsNonWildcardTypeArgumentsContext()
}

type NonWildcardTypeArgumentsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonWildcardTypeArgumentsContext() *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_nonWildcardTypeArguments
	return p
}

func InitEmptyNonWildcardTypeArgumentsContext(p *NonWildcardTypeArgumentsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_nonWildcardTypeArguments
}

func (*NonWildcardTypeArgumentsContext) IsNonWildcardTypeArgumentsContext() {}

func NewNonWildcardTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_nonWildcardTypeArguments

	return p
}

func (s *NonWildcardTypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *NonWildcardTypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *NonWildcardTypeArgumentsContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *NonWildcardTypeArgumentsContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *NonWildcardTypeArgumentsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *NonWildcardTypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *NonWildcardTypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonWildcardTypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonWildcardTypeArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNonWildcardTypeArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) NonWildcardTypeArguments() (localctx INonWildcardTypeArgumentsContext) {
	localctx = NewNonWildcardTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, GroovyParserRULE_nonWildcardTypeArguments)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1735)
		p.Match(GroovyParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1736)
		p.Nls()
	}
	{
		p.SetState(1737)
		p.TypeList()
	}
	{
		p.SetState(1738)
		p.Nls()
	}
	{
		p.SetState(1739)
		p.Match(GroovyParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type ITypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	TypeArguments() ITypeArgumentsContext

	// IsTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsTypeArgumentsOrDiamondContext()
}

type TypeArgumentsOrDiamondContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsOrDiamondContext() *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeArgumentsOrDiamond
	return p
}

func InitEmptyTypeArgumentsOrDiamondContext(p *TypeArgumentsOrDiamondContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_typeArgumentsOrDiamond
}

func (*TypeArgumentsOrDiamondContext) IsTypeArgumentsOrDiamondContext() {}

func NewTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeArgumentsOrDiamond

	return p
}

func (s *TypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsOrDiamondContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *TypeArgumentsOrDiamondContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *TypeArgumentsOrDiamondContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *TypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsOrDiamondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitTypeArgumentsOrDiamond(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) TypeArgumentsOrDiamond() (localctx ITypeArgumentsOrDiamondContext) {
	localctx = NewTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, GroovyParserRULE_typeArgumentsOrDiamond)
	p.SetState(1744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1741)
			p.Match(GroovyParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1742)
			p.Match(GroovyParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1743)
			p.TypeArguments()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Rparen() IRparenContext
	EnhancedArgumentListInPar() IEnhancedArgumentListInParContext
	COMMA() antlr.TerminalNode

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ArgumentsContext) Rparen() IRparenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRparenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ArgumentsContext) EnhancedArgumentListInPar() IEnhancedArgumentListInParContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedArgumentListInParContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedArgumentListInParContext)
}

func (s *ArgumentsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, GroovyParserRULE_arguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1746)
		p.Match(GroovyParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1748)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1747)
			p.EnhancedArgumentListInPar()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserCOMMA {
		{
			p.SetState(1750)
			p.Match(GroovyParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1753)
		p.Rparen()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FirstArgumentListElement() IFirstArgumentListElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext
	AllArgumentListElement() []IArgumentListElementContext
	ArgumentListElement(i int) IArgumentListElementContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) FirstArgumentListElement() IFirstArgumentListElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFirstArgumentListElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFirstArgumentListElementContext)
}

func (s *ArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ArgumentListContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ArgumentListContext) AllArgumentListElement() []IArgumentListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentListElementContext); ok {
			len++
		}
	}

	tst := make([]IArgumentListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentListElementContext); ok {
			tst[i] = t.(IArgumentListElementContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) ArgumentListElement(i int) IArgumentListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListElementContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, GroovyParserRULE_argumentList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1755)
		p.FirstArgumentListElement()
	}
	p.SetState(1762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1756)
				p.Match(GroovyParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1757)
				p.Nls()
			}
			{
				p.SetState(1758)
				p.ArgumentListElement()
			}

		}
		p.SetState(1764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnhancedArgumentListInParContext is an interface to support dynamic dispatch.
type IEnhancedArgumentListInParContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnhancedArgumentListElement() []IEnhancedArgumentListElementContext
	EnhancedArgumentListElement(i int) IEnhancedArgumentListElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNls() []INlsContext
	Nls(i int) INlsContext

	// IsEnhancedArgumentListInParContext differentiates from other interfaces.
	IsEnhancedArgumentListInParContext()
}

type EnhancedArgumentListInParContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedArgumentListInParContext() *EnhancedArgumentListInParContext {
	var p = new(EnhancedArgumentListInParContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enhancedArgumentListInPar
	return p
}

func InitEmptyEnhancedArgumentListInParContext(p *EnhancedArgumentListInParContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enhancedArgumentListInPar
}

func (*EnhancedArgumentListInParContext) IsEnhancedArgumentListInParContext() {}

func NewEnhancedArgumentListInParContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedArgumentListInParContext {
	var p = new(EnhancedArgumentListInParContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedArgumentListInPar

	return p
}

func (s *EnhancedArgumentListInParContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedArgumentListInParContext) AllEnhancedArgumentListElement() []IEnhancedArgumentListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnhancedArgumentListElementContext); ok {
			len++
		}
	}

	tst := make([]IEnhancedArgumentListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnhancedArgumentListElementContext); ok {
			tst[i] = t.(IEnhancedArgumentListElementContext)
			i++
		}
	}

	return tst
}

func (s *EnhancedArgumentListInParContext) EnhancedArgumentListElement(i int) IEnhancedArgumentListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedArgumentListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedArgumentListElementContext)
}

func (s *EnhancedArgumentListInParContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *EnhancedArgumentListInParContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *EnhancedArgumentListInParContext) AllNls() []INlsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INlsContext); ok {
			len++
		}
	}

	tst := make([]INlsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INlsContext); ok {
			tst[i] = t.(INlsContext)
			i++
		}
	}

	return tst
}

func (s *EnhancedArgumentListInParContext) Nls(i int) INlsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INlsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *EnhancedArgumentListInParContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedArgumentListInParContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedArgumentListInParContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitEnhancedArgumentListInPar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) EnhancedArgumentListInPar() (localctx IEnhancedArgumentListInParContext) {
	localctx = NewEnhancedArgumentListInParContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, GroovyParserRULE_enhancedArgumentListInPar)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1765)
		p.EnhancedArgumentListElement()
	}
	p.SetState(1772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1766)
				p.Match(GroovyParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1767)
				p.Nls()
			}
			{
				p.SetState(1768)
				p.EnhancedArgumentListElement()
			}

		}
		p.SetState(1774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFirstArgumentListElementContext is an interface to support dynamic dispatch.
type IFirstArgumentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionListElement() IExpressionListElementContext
	NamedArg() INamedArgContext

	// IsFirstArgumentListElementContext differentiates from other interfaces.
	IsFirstArgumentListElementContext()
}

type FirstArgumentListElementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFirstArgumentListElementContext() *FirstArgumentListElementContext {
	var p = new(FirstArgumentListElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_firstArgumentListElement
	return p
}

func InitEmptyFirstArgumentListElementContext(p *FirstArgumentListElementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_firstArgumentListElement
}

func (*FirstArgumentListElementContext) IsFirstArgumentListElementContext() {}

func NewFirstArgumentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FirstArgumentListElementContext {
	var p = new(FirstArgumentListElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_firstArgumentListElement

	return p
}

func (s *FirstArgumentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *FirstArgumentListElementContext) ExpressionListElement() IExpressionListElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListElementContext)
}

func (s *FirstArgumentListElementContext) NamedArg() INamedArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgContext)
}

func (s *FirstArgumentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FirstArgumentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FirstArgumentListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitFirstArgumentListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) FirstArgumentListElement() (localctx IFirstArgumentListElementContext) {
	localctx = NewFirstArgumentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, GroovyParserRULE_firstArgumentListElement)
	p.SetState(1777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1775)
			p.ExpressionListElement(true)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1776)
			p.NamedArg()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListElementContext is an interface to support dynamic dispatch.
type IArgumentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionListElement() IExpressionListElementContext
	NamedPropertyArg() INamedPropertyArgContext

	// IsArgumentListElementContext differentiates from other interfaces.
	IsArgumentListElementContext()
}

type ArgumentListElementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListElementContext() *ArgumentListElementContext {
	var p = new(ArgumentListElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_argumentListElement
	return p
}

func InitEmptyArgumentListElementContext(p *ArgumentListElementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_argumentListElement
}

func (*ArgumentListElementContext) IsArgumentListElementContext() {}

func NewArgumentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListElementContext {
	var p = new(ArgumentListElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_argumentListElement

	return p
}

func (s *ArgumentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListElementContext) ExpressionListElement() IExpressionListElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListElementContext)
}

func (s *ArgumentListElementContext) NamedPropertyArg() INamedPropertyArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedPropertyArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedPropertyArgContext)
}

func (s *ArgumentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitArgumentListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ArgumentListElement() (localctx IArgumentListElementContext) {
	localctx = NewArgumentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, GroovyParserRULE_argumentListElement)
	p.SetState(1781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1779)
			p.ExpressionListElement(true)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1780)
			p.NamedPropertyArg()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnhancedArgumentListElementContext is an interface to support dynamic dispatch.
type IEnhancedArgumentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionListElement() IExpressionListElementContext
	StandardLambdaExpression() IStandardLambdaExpressionContext
	NamedPropertyArg() INamedPropertyArgContext

	// IsEnhancedArgumentListElementContext differentiates from other interfaces.
	IsEnhancedArgumentListElementContext()
}

type EnhancedArgumentListElementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedArgumentListElementContext() *EnhancedArgumentListElementContext {
	var p = new(EnhancedArgumentListElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enhancedArgumentListElement
	return p
}

func InitEmptyEnhancedArgumentListElementContext(p *EnhancedArgumentListElementContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_enhancedArgumentListElement
}

func (*EnhancedArgumentListElementContext) IsEnhancedArgumentListElementContext() {}

func NewEnhancedArgumentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedArgumentListElementContext {
	var p = new(EnhancedArgumentListElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedArgumentListElement

	return p
}

func (s *EnhancedArgumentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedArgumentListElementContext) ExpressionListElement() IExpressionListElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListElementContext)
}

func (s *EnhancedArgumentListElementContext) StandardLambdaExpression() IStandardLambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardLambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardLambdaExpressionContext)
}

func (s *EnhancedArgumentListElementContext) NamedPropertyArg() INamedPropertyArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedPropertyArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedPropertyArgContext)
}

func (s *EnhancedArgumentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedArgumentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedArgumentListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitEnhancedArgumentListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) EnhancedArgumentListElement() (localctx IEnhancedArgumentListElementContext) {
	localctx = NewEnhancedArgumentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, GroovyParserRULE_enhancedArgumentListElement)
	p.SetState(1786)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1783)
			p.ExpressionListElement(true)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1784)
			p.StandardLambdaExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1785)
			p.NamedPropertyArg()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserStringLiteral, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, GroovyParserRULE_stringLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1788)
		p.Match(GroovyParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassNameContext is an interface to support dynamic dispatch.
type IClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CapitalizedIdentifier() antlr.TerminalNode

	// IsClassNameContext differentiates from other interfaces.
	IsClassNameContext()
}

type ClassNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNameContext() *ClassNameContext {
	var p = new(ClassNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_className
	return p
}

func InitEmptyClassNameContext(p *ClassNameContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_className
}

func (*ClassNameContext) IsClassNameContext() {}

func NewClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNameContext {
	var p = new(ClassNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_className

	return p
}

func (s *ClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNameContext) CapitalizedIdentifier() antlr.TerminalNode {
	return s.GetToken(GroovyParserCapitalizedIdentifier, 0)
}

func (s *ClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitClassName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) ClassName() (localctx IClassNameContext) {
	localctx = NewClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, GroovyParserRULE_className)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1790)
		p.Match(GroovyParserCapitalizedIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	CapitalizedIdentifier() antlr.TerminalNode
	AS() antlr.TerminalNode
	IN() antlr.TerminalNode
	PERMITS() antlr.TerminalNode
	RECORD() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	TRAIT() antlr.TerminalNode
	VAR() antlr.TerminalNode
	YIELD() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(GroovyParserIdentifier, 0)
}

func (s *IdentifierContext) CapitalizedIdentifier() antlr.TerminalNode {
	return s.GetToken(GroovyParserCapitalizedIdentifier, 0)
}

func (s *IdentifierContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *IdentifierContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *IdentifierContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(GroovyParserPERMITS, 0)
}

func (s *IdentifierContext) RECORD() antlr.TerminalNode {
	return s.GetToken(GroovyParserRECORD, 0)
}

func (s *IdentifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSEALED, 0)
}

func (s *IdentifierContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *IdentifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *IdentifierContext) YIELD() antlr.TerminalNode {
	return s.GetToken(GroovyParserYIELD, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, GroovyParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1792)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&178120883836544) != 0) || _la == GroovyParserCapitalizedIdentifier || _la == GroovyParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBuiltInTypeContext is an interface to support dynamic dispatch.
type IBuiltInTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BuiltInPrimitiveType() antlr.TerminalNode
	VOID() antlr.TerminalNode

	// IsBuiltInTypeContext differentiates from other interfaces.
	IsBuiltInTypeContext()
}

type BuiltInTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltInTypeContext() *BuiltInTypeContext {
	var p = new(BuiltInTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_builtInType
	return p
}

func InitEmptyBuiltInTypeContext(p *BuiltInTypeContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_builtInType
}

func (*BuiltInTypeContext) IsBuiltInTypeContext() {}

func NewBuiltInTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltInTypeContext {
	var p = new(BuiltInTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_builtInType

	return p
}

func (s *BuiltInTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltInTypeContext) BuiltInPrimitiveType() antlr.TerminalNode {
	return s.GetToken(GroovyParserBuiltInPrimitiveType, 0)
}

func (s *BuiltInTypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *BuiltInTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltInTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltInTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitBuiltInType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) BuiltInType() (localctx IBuiltInTypeContext) {
	localctx = NewBuiltInTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, GroovyParserRULE_builtInType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1794)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GroovyParserBuiltInPrimitiveType || _la == GroovyParserVOID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordsContext is an interface to support dynamic dispatch.
type IKeywordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABSTRACT() antlr.TerminalNode
	AS() antlr.TerminalNode
	ASSERT() antlr.TerminalNode
	BREAK() antlr.TerminalNode
	CASE() antlr.TerminalNode
	CATCH() antlr.TerminalNode
	CLASS() antlr.TerminalNode
	CONST() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode
	DEF() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DO() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	FINALLY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	GOTO() antlr.TerminalNode
	IF() antlr.TerminalNode
	IMPLEMENTS() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	IN() antlr.TerminalNode
	INSTANCEOF() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode
	NATIVE() antlr.TerminalNode
	NEW() antlr.TerminalNode
	NON_SEALED() antlr.TerminalNode
	PACKAGE() antlr.TerminalNode
	PERMITS() antlr.TerminalNode
	RECORD() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	STRICTFP() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	SWITCH() antlr.TerminalNode
	SYNCHRONIZED() antlr.TerminalNode
	THIS() antlr.TerminalNode
	THROW() antlr.TerminalNode
	THROWS() antlr.TerminalNode
	TRANSIENT() antlr.TerminalNode
	TRAIT() antlr.TerminalNode
	THREADSAFE() antlr.TerminalNode
	TRY() antlr.TerminalNode
	VAR() antlr.TerminalNode
	VOLATILE() antlr.TerminalNode
	WHILE() antlr.TerminalNode
	YIELD() antlr.TerminalNode
	NullLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode
	BuiltInPrimitiveType() antlr.TerminalNode
	VOID() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode

	// IsKeywordsContext differentiates from other interfaces.
	IsKeywordsContext()
}

type KeywordsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsContext() *KeywordsContext {
	var p = new(KeywordsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_keywords
	return p
}

func InitEmptyKeywordsContext(p *KeywordsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_keywords
}

func (*KeywordsContext) IsKeywordsContext() {}

func NewKeywordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsContext {
	var p = new(KeywordsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_keywords

	return p
}

func (s *KeywordsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(GroovyParserABSTRACT, 0)
}

func (s *KeywordsContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *KeywordsContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSERT, 0)
}

func (s *KeywordsContext) BREAK() antlr.TerminalNode {
	return s.GetToken(GroovyParserBREAK, 0)
}

func (s *KeywordsContext) CASE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCASE, 0)
}

func (s *KeywordsContext) CATCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserCATCH, 0)
}

func (s *KeywordsContext) CLASS() antlr.TerminalNode {
	return s.GetToken(GroovyParserCLASS, 0)
}

func (s *KeywordsContext) CONST() antlr.TerminalNode {
	return s.GetToken(GroovyParserCONST, 0)
}

func (s *KeywordsContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCONTINUE, 0)
}

func (s *KeywordsContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *KeywordsContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *KeywordsContext) DO() antlr.TerminalNode {
	return s.GetToken(GroovyParserDO, 0)
}

func (s *KeywordsContext) ELSE() antlr.TerminalNode {
	return s.GetToken(GroovyParserELSE, 0)
}

func (s *KeywordsContext) ENUM() antlr.TerminalNode {
	return s.GetToken(GroovyParserENUM, 0)
}

func (s *KeywordsContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *KeywordsContext) FINAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINAL, 0)
}

func (s *KeywordsContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINALLY, 0)
}

func (s *KeywordsContext) FOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserFOR, 0)
}

func (s *KeywordsContext) GOTO() antlr.TerminalNode {
	return s.GetToken(GroovyParserGOTO, 0)
}

func (s *KeywordsContext) IF() antlr.TerminalNode {
	return s.GetToken(GroovyParserIF, 0)
}

func (s *KeywordsContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPLEMENTS, 0)
}

func (s *KeywordsContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPORT, 0)
}

func (s *KeywordsContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *KeywordsContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserINSTANCEOF, 0)
}

func (s *KeywordsContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserINTERFACE, 0)
}

func (s *KeywordsContext) NATIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserNATIVE, 0)
}

func (s *KeywordsContext) NEW() antlr.TerminalNode {
	return s.GetToken(GroovyParserNEW, 0)
}

func (s *KeywordsContext) NON_SEALED() antlr.TerminalNode {
	return s.GetToken(GroovyParserNON_SEALED, 0)
}

func (s *KeywordsContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPACKAGE, 0)
}

func (s *KeywordsContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(GroovyParserPERMITS, 0)
}

func (s *KeywordsContext) RECORD() antlr.TerminalNode {
	return s.GetToken(GroovyParserRECORD, 0)
}

func (s *KeywordsContext) RETURN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRETURN, 0)
}

func (s *KeywordsContext) SEALED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSEALED, 0)
}

func (s *KeywordsContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *KeywordsContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTRICTFP, 0)
}

func (s *KeywordsContext) SUPER() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUPER, 0)
}

func (s *KeywordsContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserSWITCH, 0)
}

func (s *KeywordsContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSYNCHRONIZED, 0)
}

func (s *KeywordsContext) THIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHIS, 0)
}

func (s *KeywordsContext) THROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROW, 0)
}

func (s *KeywordsContext) THROWS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROWS, 0)
}

func (s *KeywordsContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRANSIENT, 0)
}

func (s *KeywordsContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *KeywordsContext) THREADSAFE() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHREADSAFE, 0)
}

func (s *KeywordsContext) TRY() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRY, 0)
}

func (s *KeywordsContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *KeywordsContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOLATILE, 0)
}

func (s *KeywordsContext) WHILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserWHILE, 0)
}

func (s *KeywordsContext) YIELD() antlr.TerminalNode {
	return s.GetToken(GroovyParserYIELD, 0)
}

func (s *KeywordsContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserNullLiteral, 0)
}

func (s *KeywordsContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserBooleanLiteral, 0)
}

func (s *KeywordsContext) BuiltInPrimitiveType() antlr.TerminalNode {
	return s.GetToken(GroovyParserBuiltInPrimitiveType, 0)
}

func (s *KeywordsContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *KeywordsContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserPUBLIC, 0)
}

func (s *KeywordsContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(GroovyParserPROTECTED, 0)
}

func (s *KeywordsContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPRIVATE, 0)
}

func (s *KeywordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitKeywords(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Keywords() (localctx IKeywordsContext) {
	localctx = NewKeywordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, GroovyParserRULE_keywords)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1796)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-7)) & ^0x3f) == 0 && ((int64(1)<<(_la-7))&234187180623265791) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRparenContext is an interface to support dynamic dispatch.
type IRparenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RPAREN() antlr.TerminalNode

	// IsRparenContext differentiates from other interfaces.
	IsRparenContext()
}

type RparenContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyRparenContext() *RparenContext {
	var p = new(RparenContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_rparen
	return p
}

func InitEmptyRparenContext(p *RparenContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_rparen
}

func (*RparenContext) IsRparenContext() {}

func NewRparenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RparenContext {
	var p = new(RparenContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_rparen

	return p
}

func (s *RparenContext) GetParser() antlr.Parser { return s.parser }

func (s *RparenContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRPAREN, 0)
}

func (s *RparenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RparenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RparenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitRparen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Rparen() (localctx IRparenContext) {
	localctx = NewRparenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, GroovyParserRULE_rparen)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1798)
		p.Match(GroovyParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INlsContext is an interface to support dynamic dispatch.
type INlsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsNlsContext differentiates from other interfaces.
	IsNlsContext()
}

type NlsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNlsContext() *NlsContext {
	var p = new(NlsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_nls
	return p
}

func InitEmptyNlsContext(p *NlsContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_nls
}

func (*NlsContext) IsNlsContext() {}

func NewNlsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NlsContext {
	var p = new(NlsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_nls

	return p
}

func (s *NlsContext) GetParser() antlr.Parser { return s.parser }

func (s *NlsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserNL)
}

func (s *NlsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserNL, i)
}

func (s *NlsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NlsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NlsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitNls(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Nls() (localctx INlsContext) {
	localctx = NewNlsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, GroovyParserRULE_nls)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1800)
				p.Match(GroovyParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISepContext is an interface to support dynamic dispatch.
type ISepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsSepContext differentiates from other interfaces.
	IsSepContext()
}

type SepContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptySepContext() *SepContext {
	var p = new(SepContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_sep
	return p
}

func InitEmptySepContext(p *SepContext) {
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1) // Jim super
	p.RuleIndex = GroovyParserRULE_sep
}

func (*SepContext) IsSepContext() {}

func NewSepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SepContext {
	var p = new(SepContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)
	p.parser = parser
	p.RuleIndex = GroovyParserRULE_sep

	return p
}

func (s *SepContext) GetParser() antlr.Parser { return s.parser }

func (s *SepContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserNL)
}

func (s *SepContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserNL, i)
}

func (s *SepContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserSEMI)
}

func (s *SepContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, i)
}

func (s *SepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case GroovyParserVisitor:
		return t.VisitSep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *GroovyParser) Sep() (localctx ISepContext) {
	localctx = NewSepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, GroovyParserRULE_sep)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1806)
				_la = p.GetTokenStream().LA(1)

				if !(_la == GroovyParserSEMI || _la == GroovyParserNL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1809)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *GroovyParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 2:
		var t *ScriptStatementContext = nil
		if localctx != nil {
			t = localctx.(*ScriptStatementContext)
		}
		return p.ScriptStatement_Sempred(t, predIndex)

	case 20:
		var t *ClassBodyContext = nil
		if localctx != nil {
			t = localctx.(*ClassBodyContext)
		}
		return p.ClassBody_Sempred(t, predIndex)

	case 80:
		var t *LocalVariableDeclarationContext = nil
		if localctx != nil {
			t = localctx.(*LocalVariableDeclarationContext)
		}
		return p.LocalVariableDeclaration_Sempred(t, predIndex)

	case 94:
		var t *StatementContext = nil
		if localctx != nil {
			t = localctx.(*StatementContext)
		}
		return p.Statement_Sempred(t, predIndex)

	case 119:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 121:
		var t *CommandExpressionContext = nil
		if localctx != nil {
			t = localctx.(*CommandExpressionContext)
		}
		return p.CommandExpression_Sempred(t, predIndex)

	case 123:
		var t *PathExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PathExpressionContext)
		}
		return p.PathExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *GroovyParser) ScriptStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return !isInvalidMethodDeclaration(p.GetTokenStream())

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) ClassBody_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return 2 == localctx.(*ClassBodyContext).t

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) LocalVariableDeclaration_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return !isInvalidLocalVariableDeclaration(p.GetTokenStream())

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) Statement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.inSwitchExpressionLevel > 0

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) CommandExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 20:
		return !isFollowingArgumentsOrClosure()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) PathExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 21:
		return p.GetTokenStream().LT(2).GetTokenType() == GroovyParserDOT

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
